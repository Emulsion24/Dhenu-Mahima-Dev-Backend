
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Donation
 * 
 */
export type Donation = $Result.DefaultSelection<Prisma.$DonationPayload>
/**
 * Model Book
 * 
 */
export type Book = $Result.DefaultSelection<Prisma.$BookPayload>
/**
 * Model BookCoupon
 * 
 */
export type BookCoupon = $Result.DefaultSelection<Prisma.$BookCouponPayload>
/**
 * Model BookOrder
 * 
 */
export type BookOrder = $Result.DefaultSelection<Prisma.$BookOrderPayload>
/**
 * Model BookOrderItem
 * 
 */
export type BookOrderItem = $Result.DefaultSelection<Prisma.$BookOrderItemPayload>
/**
 * Model BookPurchase
 * 
 */
export type BookPurchase = $Result.DefaultSelection<Prisma.$BookPurchasePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model News
 * 
 */
export type News = $Result.DefaultSelection<Prisma.$NewsPayload>
/**
 * Model GopalPariwar
 * 
 */
export type GopalPariwar = $Result.DefaultSelection<Prisma.$GopalPariwarPayload>
/**
 * Model Gaushala
 * 
 */
export type Gaushala = $Result.DefaultSelection<Prisma.$GaushalaPayload>
/**
 * Model Card
 * 
 */
export type Card = $Result.DefaultSelection<Prisma.$CardPayload>
/**
 * Model DtaSanssthan
 * 
 */
export type DtaSanssthan = $Result.DefaultSelection<Prisma.$DtaSanssthanPayload>
/**
 * Model PrivacyPolicy
 * 
 */
export type PrivacyPolicy = $Result.DefaultSelection<Prisma.$PrivacyPolicyPayload>
/**
 * Model TermsConditions
 * 
 */
export type TermsConditions = $Result.DefaultSelection<Prisma.$TermsConditionsPayload>
/**
 * Model Banner
 * 
 */
export type Banner = $Result.DefaultSelection<Prisma.$BannerPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Foundation
 * 
 */
export type Foundation = $Result.DefaultSelection<Prisma.$FoundationPayload>
/**
 * Model FoundationStat
 * 
 */
export type FoundationStat = $Result.DefaultSelection<Prisma.$FoundationStatPayload>
/**
 * Model FoundationActivity
 * 
 */
export type FoundationActivity = $Result.DefaultSelection<Prisma.$FoundationActivityPayload>
/**
 * Model FoundationObjective
 * 
 */
export type FoundationObjective = $Result.DefaultSelection<Prisma.$FoundationObjectivePayload>
/**
 * Model FoundationContact
 * 
 */
export type FoundationContact = $Result.DefaultSelection<Prisma.$FoundationContactPayload>
/**
 * Model FoundationMedia
 * 
 */
export type FoundationMedia = $Result.DefaultSelection<Prisma.$FoundationMediaPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model Bhajan
 * 
 */
export type Bhajan = $Result.DefaultSelection<Prisma.$BhajanPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ObjectiveType: {
  main: 'main',
  supportive: 'supportive'
};

export type ObjectiveType = (typeof ObjectiveType)[keyof typeof ObjectiveType]


export const UserRole: {
  super_admin: 'super_admin',
  admin: 'admin',
  editor: 'editor'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const MediaType: {
  logo: 'logo',
  banner: 'banner',
  gallery: 'gallery',
  document: 'document'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]

}

export type ObjectiveType = $Enums.ObjectiveType

export const ObjectiveType: typeof $Enums.ObjectiveType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.donation`: Exposes CRUD operations for the **Donation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Donations
    * const donations = await prisma.donation.findMany()
    * ```
    */
  get donation(): Prisma.DonationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book`: Exposes CRUD operations for the **Book** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Books
    * const books = await prisma.book.findMany()
    * ```
    */
  get book(): Prisma.BookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookCoupon`: Exposes CRUD operations for the **BookCoupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookCoupons
    * const bookCoupons = await prisma.bookCoupon.findMany()
    * ```
    */
  get bookCoupon(): Prisma.BookCouponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookOrder`: Exposes CRUD operations for the **BookOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookOrders
    * const bookOrders = await prisma.bookOrder.findMany()
    * ```
    */
  get bookOrder(): Prisma.BookOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookOrderItem`: Exposes CRUD operations for the **BookOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookOrderItems
    * const bookOrderItems = await prisma.bookOrderItem.findMany()
    * ```
    */
  get bookOrderItem(): Prisma.BookOrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookPurchase`: Exposes CRUD operations for the **BookPurchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookPurchases
    * const bookPurchases = await prisma.bookPurchase.findMany()
    * ```
    */
  get bookPurchase(): Prisma.BookPurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.news`: Exposes CRUD operations for the **News** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News
    * const news = await prisma.news.findMany()
    * ```
    */
  get news(): Prisma.NewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gopalPariwar`: Exposes CRUD operations for the **GopalPariwar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GopalPariwars
    * const gopalPariwars = await prisma.gopalPariwar.findMany()
    * ```
    */
  get gopalPariwar(): Prisma.GopalPariwarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gaushala`: Exposes CRUD operations for the **Gaushala** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gaushalas
    * const gaushalas = await prisma.gaushala.findMany()
    * ```
    */
  get gaushala(): Prisma.GaushalaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.card`: Exposes CRUD operations for the **Card** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cards
    * const cards = await prisma.card.findMany()
    * ```
    */
  get card(): Prisma.CardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dtaSanssthan`: Exposes CRUD operations for the **DtaSanssthan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DtaSanssthans
    * const dtaSanssthans = await prisma.dtaSanssthan.findMany()
    * ```
    */
  get dtaSanssthan(): Prisma.DtaSanssthanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privacyPolicy`: Exposes CRUD operations for the **PrivacyPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrivacyPolicies
    * const privacyPolicies = await prisma.privacyPolicy.findMany()
    * ```
    */
  get privacyPolicy(): Prisma.PrivacyPolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.termsConditions`: Exposes CRUD operations for the **TermsConditions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TermsConditions
    * const termsConditions = await prisma.termsConditions.findMany()
    * ```
    */
  get termsConditions(): Prisma.TermsConditionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.banner`: Exposes CRUD operations for the **Banner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banner.findMany()
    * ```
    */
  get banner(): Prisma.BannerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foundation`: Exposes CRUD operations for the **Foundation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Foundations
    * const foundations = await prisma.foundation.findMany()
    * ```
    */
  get foundation(): Prisma.FoundationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foundationStat`: Exposes CRUD operations for the **FoundationStat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoundationStats
    * const foundationStats = await prisma.foundationStat.findMany()
    * ```
    */
  get foundationStat(): Prisma.FoundationStatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foundationActivity`: Exposes CRUD operations for the **FoundationActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoundationActivities
    * const foundationActivities = await prisma.foundationActivity.findMany()
    * ```
    */
  get foundationActivity(): Prisma.FoundationActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foundationObjective`: Exposes CRUD operations for the **FoundationObjective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoundationObjectives
    * const foundationObjectives = await prisma.foundationObjective.findMany()
    * ```
    */
  get foundationObjective(): Prisma.FoundationObjectiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foundationContact`: Exposes CRUD operations for the **FoundationContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoundationContacts
    * const foundationContacts = await prisma.foundationContact.findMany()
    * ```
    */
  get foundationContact(): Prisma.FoundationContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foundationMedia`: Exposes CRUD operations for the **FoundationMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoundationMedias
    * const foundationMedias = await prisma.foundationMedia.findMany()
    * ```
    */
  get foundationMedia(): Prisma.FoundationMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bhajan`: Exposes CRUD operations for the **Bhajan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bhajans
    * const bhajans = await prisma.bhajan.findMany()
    * ```
    */
  get bhajan(): Prisma.BhajanDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Donation: 'Donation',
    Book: 'Book',
    BookCoupon: 'BookCoupon',
    BookOrder: 'BookOrder',
    BookOrderItem: 'BookOrderItem',
    BookPurchase: 'BookPurchase',
    Payment: 'Payment',
    News: 'News',
    GopalPariwar: 'GopalPariwar',
    Gaushala: 'Gaushala',
    Card: 'Card',
    DtaSanssthan: 'DtaSanssthan',
    PrivacyPolicy: 'PrivacyPolicy',
    TermsConditions: 'TermsConditions',
    Banner: 'Banner',
    Message: 'Message',
    Foundation: 'Foundation',
    FoundationStat: 'FoundationStat',
    FoundationActivity: 'FoundationActivity',
    FoundationObjective: 'FoundationObjective',
    FoundationContact: 'FoundationContact',
    FoundationMedia: 'FoundationMedia',
    Event: 'Event',
    Bhajan: 'Bhajan'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "donation" | "book" | "bookCoupon" | "bookOrder" | "bookOrderItem" | "bookPurchase" | "payment" | "news" | "gopalPariwar" | "gaushala" | "card" | "dtaSanssthan" | "privacyPolicy" | "termsConditions" | "banner" | "message" | "foundation" | "foundationStat" | "foundationActivity" | "foundationObjective" | "foundationContact" | "foundationMedia" | "event" | "bhajan"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Donation: {
        payload: Prisma.$DonationPayload<ExtArgs>
        fields: Prisma.DonationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DonationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DonationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          findFirst: {
            args: Prisma.DonationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DonationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          findMany: {
            args: Prisma.DonationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>[]
          }
          create: {
            args: Prisma.DonationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          createMany: {
            args: Prisma.DonationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DonationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          update: {
            args: Prisma.DonationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          deleteMany: {
            args: Prisma.DonationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DonationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DonationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          aggregate: {
            args: Prisma.DonationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDonation>
          }
          groupBy: {
            args: Prisma.DonationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DonationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DonationCountArgs<ExtArgs>
            result: $Utils.Optional<DonationCountAggregateOutputType> | number
          }
        }
      }
      Book: {
        payload: Prisma.$BookPayload<ExtArgs>
        fields: Prisma.BookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          findFirst: {
            args: Prisma.BookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          findMany: {
            args: Prisma.BookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>[]
          }
          create: {
            args: Prisma.BookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          createMany: {
            args: Prisma.BookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          update: {
            args: Prisma.BookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          deleteMany: {
            args: Prisma.BookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          aggregate: {
            args: Prisma.BookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook>
          }
          groupBy: {
            args: Prisma.BookGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookCountArgs<ExtArgs>
            result: $Utils.Optional<BookCountAggregateOutputType> | number
          }
        }
      }
      BookCoupon: {
        payload: Prisma.$BookCouponPayload<ExtArgs>
        fields: Prisma.BookCouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookCouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookCouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCouponPayload>
          }
          findFirst: {
            args: Prisma.BookCouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookCouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCouponPayload>
          }
          findMany: {
            args: Prisma.BookCouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCouponPayload>[]
          }
          create: {
            args: Prisma.BookCouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCouponPayload>
          }
          createMany: {
            args: Prisma.BookCouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BookCouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCouponPayload>
          }
          update: {
            args: Prisma.BookCouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCouponPayload>
          }
          deleteMany: {
            args: Prisma.BookCouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookCouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookCouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookCouponPayload>
          }
          aggregate: {
            args: Prisma.BookCouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookCoupon>
          }
          groupBy: {
            args: Prisma.BookCouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookCouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookCouponCountArgs<ExtArgs>
            result: $Utils.Optional<BookCouponCountAggregateOutputType> | number
          }
        }
      }
      BookOrder: {
        payload: Prisma.$BookOrderPayload<ExtArgs>
        fields: Prisma.BookOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderPayload>
          }
          findFirst: {
            args: Prisma.BookOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderPayload>
          }
          findMany: {
            args: Prisma.BookOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderPayload>[]
          }
          create: {
            args: Prisma.BookOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderPayload>
          }
          createMany: {
            args: Prisma.BookOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BookOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderPayload>
          }
          update: {
            args: Prisma.BookOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderPayload>
          }
          deleteMany: {
            args: Prisma.BookOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderPayload>
          }
          aggregate: {
            args: Prisma.BookOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookOrder>
          }
          groupBy: {
            args: Prisma.BookOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookOrderCountArgs<ExtArgs>
            result: $Utils.Optional<BookOrderCountAggregateOutputType> | number
          }
        }
      }
      BookOrderItem: {
        payload: Prisma.$BookOrderItemPayload<ExtArgs>
        fields: Prisma.BookOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderItemPayload>
          }
          findFirst: {
            args: Prisma.BookOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderItemPayload>
          }
          findMany: {
            args: Prisma.BookOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderItemPayload>[]
          }
          create: {
            args: Prisma.BookOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderItemPayload>
          }
          createMany: {
            args: Prisma.BookOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BookOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderItemPayload>
          }
          update: {
            args: Prisma.BookOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.BookOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookOrderItemPayload>
          }
          aggregate: {
            args: Prisma.BookOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookOrderItem>
          }
          groupBy: {
            args: Prisma.BookOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookOrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<BookOrderItemCountAggregateOutputType> | number
          }
        }
      }
      BookPurchase: {
        payload: Prisma.$BookPurchasePayload<ExtArgs>
        fields: Prisma.BookPurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookPurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookPurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPurchasePayload>
          }
          findFirst: {
            args: Prisma.BookPurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookPurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPurchasePayload>
          }
          findMany: {
            args: Prisma.BookPurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPurchasePayload>[]
          }
          create: {
            args: Prisma.BookPurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPurchasePayload>
          }
          createMany: {
            args: Prisma.BookPurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BookPurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPurchasePayload>
          }
          update: {
            args: Prisma.BookPurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPurchasePayload>
          }
          deleteMany: {
            args: Prisma.BookPurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookPurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookPurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPurchasePayload>
          }
          aggregate: {
            args: Prisma.BookPurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookPurchase>
          }
          groupBy: {
            args: Prisma.BookPurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookPurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookPurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<BookPurchaseCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      News: {
        payload: Prisma.$NewsPayload<ExtArgs>
        fields: Prisma.NewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findFirst: {
            args: Prisma.NewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findMany: {
            args: Prisma.NewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          create: {
            args: Prisma.NewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          createMany: {
            args: Prisma.NewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          update: {
            args: Prisma.NewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          deleteMany: {
            args: Prisma.NewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          aggregate: {
            args: Prisma.NewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNews>
          }
          groupBy: {
            args: Prisma.NewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsCountArgs<ExtArgs>
            result: $Utils.Optional<NewsCountAggregateOutputType> | number
          }
        }
      }
      GopalPariwar: {
        payload: Prisma.$GopalPariwarPayload<ExtArgs>
        fields: Prisma.GopalPariwarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GopalPariwarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GopalPariwarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload>
          }
          findFirst: {
            args: Prisma.GopalPariwarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GopalPariwarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload>
          }
          findMany: {
            args: Prisma.GopalPariwarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload>[]
          }
          create: {
            args: Prisma.GopalPariwarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload>
          }
          createMany: {
            args: Prisma.GopalPariwarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GopalPariwarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload>
          }
          update: {
            args: Prisma.GopalPariwarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload>
          }
          deleteMany: {
            args: Prisma.GopalPariwarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GopalPariwarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GopalPariwarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload>
          }
          aggregate: {
            args: Prisma.GopalPariwarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGopalPariwar>
          }
          groupBy: {
            args: Prisma.GopalPariwarGroupByArgs<ExtArgs>
            result: $Utils.Optional<GopalPariwarGroupByOutputType>[]
          }
          count: {
            args: Prisma.GopalPariwarCountArgs<ExtArgs>
            result: $Utils.Optional<GopalPariwarCountAggregateOutputType> | number
          }
        }
      }
      Gaushala: {
        payload: Prisma.$GaushalaPayload<ExtArgs>
        fields: Prisma.GaushalaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GaushalaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GaushalaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload>
          }
          findFirst: {
            args: Prisma.GaushalaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GaushalaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload>
          }
          findMany: {
            args: Prisma.GaushalaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload>[]
          }
          create: {
            args: Prisma.GaushalaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload>
          }
          createMany: {
            args: Prisma.GaushalaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GaushalaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload>
          }
          update: {
            args: Prisma.GaushalaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload>
          }
          deleteMany: {
            args: Prisma.GaushalaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GaushalaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GaushalaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload>
          }
          aggregate: {
            args: Prisma.GaushalaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGaushala>
          }
          groupBy: {
            args: Prisma.GaushalaGroupByArgs<ExtArgs>
            result: $Utils.Optional<GaushalaGroupByOutputType>[]
          }
          count: {
            args: Prisma.GaushalaCountArgs<ExtArgs>
            result: $Utils.Optional<GaushalaCountAggregateOutputType> | number
          }
        }
      }
      Card: {
        payload: Prisma.$CardPayload<ExtArgs>
        fields: Prisma.CardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          findFirst: {
            args: Prisma.CardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          findMany: {
            args: Prisma.CardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>[]
          }
          create: {
            args: Prisma.CardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          createMany: {
            args: Prisma.CardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          update: {
            args: Prisma.CardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          deleteMany: {
            args: Prisma.CardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          aggregate: {
            args: Prisma.CardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCard>
          }
          groupBy: {
            args: Prisma.CardGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardCountArgs<ExtArgs>
            result: $Utils.Optional<CardCountAggregateOutputType> | number
          }
        }
      }
      DtaSanssthan: {
        payload: Prisma.$DtaSanssthanPayload<ExtArgs>
        fields: Prisma.DtaSanssthanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DtaSanssthanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DtaSanssthanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload>
          }
          findFirst: {
            args: Prisma.DtaSanssthanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DtaSanssthanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload>
          }
          findMany: {
            args: Prisma.DtaSanssthanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload>[]
          }
          create: {
            args: Prisma.DtaSanssthanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload>
          }
          createMany: {
            args: Prisma.DtaSanssthanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DtaSanssthanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload>
          }
          update: {
            args: Prisma.DtaSanssthanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload>
          }
          deleteMany: {
            args: Prisma.DtaSanssthanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DtaSanssthanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DtaSanssthanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload>
          }
          aggregate: {
            args: Prisma.DtaSanssthanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDtaSanssthan>
          }
          groupBy: {
            args: Prisma.DtaSanssthanGroupByArgs<ExtArgs>
            result: $Utils.Optional<DtaSanssthanGroupByOutputType>[]
          }
          count: {
            args: Prisma.DtaSanssthanCountArgs<ExtArgs>
            result: $Utils.Optional<DtaSanssthanCountAggregateOutputType> | number
          }
        }
      }
      PrivacyPolicy: {
        payload: Prisma.$PrivacyPolicyPayload<ExtArgs>
        fields: Prisma.PrivacyPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrivacyPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrivacyPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          findFirst: {
            args: Prisma.PrivacyPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrivacyPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          findMany: {
            args: Prisma.PrivacyPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>[]
          }
          create: {
            args: Prisma.PrivacyPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          createMany: {
            args: Prisma.PrivacyPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PrivacyPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          update: {
            args: Prisma.PrivacyPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          deleteMany: {
            args: Prisma.PrivacyPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrivacyPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrivacyPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          aggregate: {
            args: Prisma.PrivacyPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivacyPolicy>
          }
          groupBy: {
            args: Prisma.PrivacyPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivacyPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrivacyPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PrivacyPolicyCountAggregateOutputType> | number
          }
        }
      }
      TermsConditions: {
        payload: Prisma.$TermsConditionsPayload<ExtArgs>
        fields: Prisma.TermsConditionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TermsConditionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TermsConditionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload>
          }
          findFirst: {
            args: Prisma.TermsConditionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TermsConditionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload>
          }
          findMany: {
            args: Prisma.TermsConditionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload>[]
          }
          create: {
            args: Prisma.TermsConditionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload>
          }
          createMany: {
            args: Prisma.TermsConditionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TermsConditionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload>
          }
          update: {
            args: Prisma.TermsConditionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload>
          }
          deleteMany: {
            args: Prisma.TermsConditionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TermsConditionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TermsConditionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload>
          }
          aggregate: {
            args: Prisma.TermsConditionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTermsConditions>
          }
          groupBy: {
            args: Prisma.TermsConditionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TermsConditionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TermsConditionsCountArgs<ExtArgs>
            result: $Utils.Optional<TermsConditionsCountAggregateOutputType> | number
          }
        }
      }
      Banner: {
        payload: Prisma.$BannerPayload<ExtArgs>
        fields: Prisma.BannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findFirst: {
            args: Prisma.BannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findMany: {
            args: Prisma.BannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          create: {
            args: Prisma.BannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          createMany: {
            args: Prisma.BannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          update: {
            args: Prisma.BannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          deleteMany: {
            args: Prisma.BannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          aggregate: {
            args: Prisma.BannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanner>
          }
          groupBy: {
            args: Prisma.BannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerCountArgs<ExtArgs>
            result: $Utils.Optional<BannerCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Foundation: {
        payload: Prisma.$FoundationPayload<ExtArgs>
        fields: Prisma.FoundationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoundationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoundationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload>
          }
          findFirst: {
            args: Prisma.FoundationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoundationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload>
          }
          findMany: {
            args: Prisma.FoundationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload>[]
          }
          create: {
            args: Prisma.FoundationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload>
          }
          createMany: {
            args: Prisma.FoundationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FoundationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload>
          }
          update: {
            args: Prisma.FoundationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload>
          }
          deleteMany: {
            args: Prisma.FoundationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoundationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoundationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload>
          }
          aggregate: {
            args: Prisma.FoundationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoundation>
          }
          groupBy: {
            args: Prisma.FoundationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoundationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoundationCountArgs<ExtArgs>
            result: $Utils.Optional<FoundationCountAggregateOutputType> | number
          }
        }
      }
      FoundationStat: {
        payload: Prisma.$FoundationStatPayload<ExtArgs>
        fields: Prisma.FoundationStatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoundationStatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoundationStatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload>
          }
          findFirst: {
            args: Prisma.FoundationStatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoundationStatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload>
          }
          findMany: {
            args: Prisma.FoundationStatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload>[]
          }
          create: {
            args: Prisma.FoundationStatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload>
          }
          createMany: {
            args: Prisma.FoundationStatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FoundationStatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload>
          }
          update: {
            args: Prisma.FoundationStatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload>
          }
          deleteMany: {
            args: Prisma.FoundationStatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoundationStatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoundationStatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload>
          }
          aggregate: {
            args: Prisma.FoundationStatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoundationStat>
          }
          groupBy: {
            args: Prisma.FoundationStatGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoundationStatGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoundationStatCountArgs<ExtArgs>
            result: $Utils.Optional<FoundationStatCountAggregateOutputType> | number
          }
        }
      }
      FoundationActivity: {
        payload: Prisma.$FoundationActivityPayload<ExtArgs>
        fields: Prisma.FoundationActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoundationActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoundationActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload>
          }
          findFirst: {
            args: Prisma.FoundationActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoundationActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload>
          }
          findMany: {
            args: Prisma.FoundationActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload>[]
          }
          create: {
            args: Prisma.FoundationActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload>
          }
          createMany: {
            args: Prisma.FoundationActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FoundationActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload>
          }
          update: {
            args: Prisma.FoundationActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload>
          }
          deleteMany: {
            args: Prisma.FoundationActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoundationActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoundationActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload>
          }
          aggregate: {
            args: Prisma.FoundationActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoundationActivity>
          }
          groupBy: {
            args: Prisma.FoundationActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoundationActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoundationActivityCountArgs<ExtArgs>
            result: $Utils.Optional<FoundationActivityCountAggregateOutputType> | number
          }
        }
      }
      FoundationObjective: {
        payload: Prisma.$FoundationObjectivePayload<ExtArgs>
        fields: Prisma.FoundationObjectiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoundationObjectiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoundationObjectiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload>
          }
          findFirst: {
            args: Prisma.FoundationObjectiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoundationObjectiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload>
          }
          findMany: {
            args: Prisma.FoundationObjectiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload>[]
          }
          create: {
            args: Prisma.FoundationObjectiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload>
          }
          createMany: {
            args: Prisma.FoundationObjectiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FoundationObjectiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload>
          }
          update: {
            args: Prisma.FoundationObjectiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload>
          }
          deleteMany: {
            args: Prisma.FoundationObjectiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoundationObjectiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoundationObjectiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload>
          }
          aggregate: {
            args: Prisma.FoundationObjectiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoundationObjective>
          }
          groupBy: {
            args: Prisma.FoundationObjectiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoundationObjectiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoundationObjectiveCountArgs<ExtArgs>
            result: $Utils.Optional<FoundationObjectiveCountAggregateOutputType> | number
          }
        }
      }
      FoundationContact: {
        payload: Prisma.$FoundationContactPayload<ExtArgs>
        fields: Prisma.FoundationContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoundationContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoundationContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload>
          }
          findFirst: {
            args: Prisma.FoundationContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoundationContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload>
          }
          findMany: {
            args: Prisma.FoundationContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload>[]
          }
          create: {
            args: Prisma.FoundationContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload>
          }
          createMany: {
            args: Prisma.FoundationContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FoundationContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload>
          }
          update: {
            args: Prisma.FoundationContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload>
          }
          deleteMany: {
            args: Prisma.FoundationContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoundationContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoundationContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload>
          }
          aggregate: {
            args: Prisma.FoundationContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoundationContact>
          }
          groupBy: {
            args: Prisma.FoundationContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoundationContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoundationContactCountArgs<ExtArgs>
            result: $Utils.Optional<FoundationContactCountAggregateOutputType> | number
          }
        }
      }
      FoundationMedia: {
        payload: Prisma.$FoundationMediaPayload<ExtArgs>
        fields: Prisma.FoundationMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoundationMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoundationMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload>
          }
          findFirst: {
            args: Prisma.FoundationMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoundationMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload>
          }
          findMany: {
            args: Prisma.FoundationMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload>[]
          }
          create: {
            args: Prisma.FoundationMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload>
          }
          createMany: {
            args: Prisma.FoundationMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FoundationMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload>
          }
          update: {
            args: Prisma.FoundationMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload>
          }
          deleteMany: {
            args: Prisma.FoundationMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoundationMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoundationMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload>
          }
          aggregate: {
            args: Prisma.FoundationMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoundationMedia>
          }
          groupBy: {
            args: Prisma.FoundationMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoundationMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoundationMediaCountArgs<ExtArgs>
            result: $Utils.Optional<FoundationMediaCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      Bhajan: {
        payload: Prisma.$BhajanPayload<ExtArgs>
        fields: Prisma.BhajanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BhajanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BhajanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BhajanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BhajanPayload>
          }
          findFirst: {
            args: Prisma.BhajanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BhajanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BhajanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BhajanPayload>
          }
          findMany: {
            args: Prisma.BhajanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BhajanPayload>[]
          }
          create: {
            args: Prisma.BhajanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BhajanPayload>
          }
          createMany: {
            args: Prisma.BhajanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BhajanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BhajanPayload>
          }
          update: {
            args: Prisma.BhajanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BhajanPayload>
          }
          deleteMany: {
            args: Prisma.BhajanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BhajanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BhajanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BhajanPayload>
          }
          aggregate: {
            args: Prisma.BhajanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBhajan>
          }
          groupBy: {
            args: Prisma.BhajanGroupByArgs<ExtArgs>
            result: $Utils.Optional<BhajanGroupByOutputType>[]
          }
          count: {
            args: Prisma.BhajanCountArgs<ExtArgs>
            result: $Utils.Optional<BhajanCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    donation?: DonationOmit
    book?: BookOmit
    bookCoupon?: BookCouponOmit
    bookOrder?: BookOrderOmit
    bookOrderItem?: BookOrderItemOmit
    bookPurchase?: BookPurchaseOmit
    payment?: PaymentOmit
    news?: NewsOmit
    gopalPariwar?: GopalPariwarOmit
    gaushala?: GaushalaOmit
    card?: CardOmit
    dtaSanssthan?: DtaSanssthanOmit
    privacyPolicy?: PrivacyPolicyOmit
    termsConditions?: TermsConditionsOmit
    banner?: BannerOmit
    message?: MessageOmit
    foundation?: FoundationOmit
    foundationStat?: FoundationStatOmit
    foundationActivity?: FoundationActivityOmit
    foundationObjective?: FoundationObjectiveOmit
    foundationContact?: FoundationContactOmit
    foundationMedia?: FoundationMediaOmit
    event?: EventOmit
    bhajan?: BhajanOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    bookOrders: number
    bookPurchases: number
    donations: number
    payments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookOrders?: boolean | UserCountOutputTypeCountBookOrdersArgs
    bookPurchases?: boolean | UserCountOutputTypeCountBookPurchasesArgs
    donations?: boolean | UserCountOutputTypeCountDonationsArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookPurchaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDonationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type BookCountOutputType
   */

  export type BookCountOutputType = {
    purchases: number
    orderItems: number
  }

  export type BookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | BookCountOutputTypeCountPurchasesArgs
    orderItems?: boolean | BookCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCountOutputType
     */
    select?: BookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookPurchaseWhereInput
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookOrderItemWhereInput
  }


  /**
   * Count Type BookCouponCountOutputType
   */

  export type BookCouponCountOutputType = {
    orders: number
  }

  export type BookCouponCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | BookCouponCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * BookCouponCountOutputType without action
   */
  export type BookCouponCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCouponCountOutputType
     */
    select?: BookCouponCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookCouponCountOutputType without action
   */
  export type BookCouponCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookOrderWhereInput
  }


  /**
   * Count Type BookOrderCountOutputType
   */

  export type BookOrderCountOutputType = {
    items: number
    purchases: number
  }

  export type BookOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | BookOrderCountOutputTypeCountItemsArgs
    purchases?: boolean | BookOrderCountOutputTypeCountPurchasesArgs
  }

  // Custom InputTypes
  /**
   * BookOrderCountOutputType without action
   */
  export type BookOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrderCountOutputType
     */
    select?: BookOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookOrderCountOutputType without action
   */
  export type BookOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookOrderItemWhereInput
  }

  /**
   * BookOrderCountOutputType without action
   */
  export type BookOrderCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookPurchaseWhereInput
  }


  /**
   * Count Type FoundationCountOutputType
   */

  export type FoundationCountOutputType = {
    stats: number
    activities: number
    objectives: number
    media: number
  }

  export type FoundationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stats?: boolean | FoundationCountOutputTypeCountStatsArgs
    activities?: boolean | FoundationCountOutputTypeCountActivitiesArgs
    objectives?: boolean | FoundationCountOutputTypeCountObjectivesArgs
    media?: boolean | FoundationCountOutputTypeCountMediaArgs
  }

  // Custom InputTypes
  /**
   * FoundationCountOutputType without action
   */
  export type FoundationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationCountOutputType
     */
    select?: FoundationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FoundationCountOutputType without action
   */
  export type FoundationCountOutputTypeCountStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationStatWhereInput
  }

  /**
   * FoundationCountOutputType without action
   */
  export type FoundationCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationActivityWhereInput
  }

  /**
   * FoundationCountOutputType without action
   */
  export type FoundationCountOutputTypeCountObjectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationObjectiveWhereInput
  }

  /**
   * FoundationCountOutputType without action
   */
  export type FoundationCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationMediaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    image: string | null
    address: string | null
    phone: string | null
    otpCode: string | null
    otpExpires: Date | null
    resetToken: string | null
    resetTokenExpires: Date | null
    isVerified: boolean | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    image: string | null
    address: string | null
    phone: string | null
    otpCode: string | null
    otpExpires: Date | null
    resetToken: string | null
    resetTokenExpires: Date | null
    isVerified: boolean | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    image: number
    address: number
    phone: number
    otpCode: number
    otpExpires: number
    resetToken: number
    resetTokenExpires: number
    isVerified: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    image?: true
    address?: true
    phone?: true
    otpCode?: true
    otpExpires?: true
    resetToken?: true
    resetTokenExpires?: true
    isVerified?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    image?: true
    address?: true
    phone?: true
    otpCode?: true
    otpExpires?: true
    resetToken?: true
    resetTokenExpires?: true
    isVerified?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    image?: true
    address?: true
    phone?: true
    otpCode?: true
    otpExpires?: true
    resetToken?: true
    resetTokenExpires?: true
    isVerified?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string | null
    image: string | null
    address: string | null
    phone: string | null
    otpCode: string | null
    otpExpires: Date | null
    resetToken: string | null
    resetTokenExpires: Date | null
    isVerified: boolean
    role: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    image?: boolean
    address?: boolean
    phone?: boolean
    otpCode?: boolean
    otpExpires?: boolean
    resetToken?: boolean
    resetTokenExpires?: boolean
    isVerified?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookOrders?: boolean | User$bookOrdersArgs<ExtArgs>
    bookPurchases?: boolean | User$bookPurchasesArgs<ExtArgs>
    donations?: boolean | User$donationsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    image?: boolean
    address?: boolean
    phone?: boolean
    otpCode?: boolean
    otpExpires?: boolean
    resetToken?: boolean
    resetTokenExpires?: boolean
    isVerified?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "image" | "address" | "phone" | "otpCode" | "otpExpires" | "resetToken" | "resetTokenExpires" | "isVerified" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookOrders?: boolean | User$bookOrdersArgs<ExtArgs>
    bookPurchases?: boolean | User$bookPurchasesArgs<ExtArgs>
    donations?: boolean | User$donationsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      bookOrders: Prisma.$BookOrderPayload<ExtArgs>[]
      bookPurchases: Prisma.$BookPurchasePayload<ExtArgs>[]
      donations: Prisma.$DonationPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string | null
      image: string | null
      address: string | null
      phone: string | null
      otpCode: string | null
      otpExpires: Date | null
      resetToken: string | null
      resetTokenExpires: Date | null
      isVerified: boolean
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookOrders<T extends User$bookOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$bookOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookPurchases<T extends User$bookPurchasesArgs<ExtArgs> = {}>(args?: Subset<T, User$bookPurchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    donations<T extends User$donationsArgs<ExtArgs> = {}>(args?: Subset<T, User$donationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly otpCode: FieldRef<"User", 'String'>
    readonly otpExpires: FieldRef<"User", 'DateTime'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpires: FieldRef<"User", 'DateTime'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.bookOrders
   */
  export type User$bookOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrder
     */
    select?: BookOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrder
     */
    omit?: BookOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderInclude<ExtArgs> | null
    where?: BookOrderWhereInput
    orderBy?: BookOrderOrderByWithRelationInput | BookOrderOrderByWithRelationInput[]
    cursor?: BookOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookOrderScalarFieldEnum | BookOrderScalarFieldEnum[]
  }

  /**
   * User.bookPurchases
   */
  export type User$bookPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPurchase
     */
    select?: BookPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPurchase
     */
    omit?: BookPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPurchaseInclude<ExtArgs> | null
    where?: BookPurchaseWhereInput
    orderBy?: BookPurchaseOrderByWithRelationInput | BookPurchaseOrderByWithRelationInput[]
    cursor?: BookPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookPurchaseScalarFieldEnum | BookPurchaseScalarFieldEnum[]
  }

  /**
   * User.donations
   */
  export type User$donationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    where?: DonationWhereInput
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    cursor?: DonationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Donation
   */

  export type AggregateDonation = {
    _count: DonationCountAggregateOutputType | null
    _avg: DonationAvgAggregateOutputType | null
    _sum: DonationSumAggregateOutputType | null
    _min: DonationMinAggregateOutputType | null
    _max: DonationMaxAggregateOutputType | null
  }

  export type DonationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
  }

  export type DonationSumAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
  }

  export type DonationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    status: string | null
    paymentMethod: string | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DonationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    status: string | null
    paymentMethod: string | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DonationCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    status: number
    paymentMethod: number
    transactionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DonationAvgAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
  }

  export type DonationSumAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
  }

  export type DonationMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DonationMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DonationCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DonationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donation to aggregate.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Donations
    **/
    _count?: true | DonationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DonationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DonationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DonationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DonationMaxAggregateInputType
  }

  export type GetDonationAggregateType<T extends DonationAggregateArgs> = {
        [P in keyof T & keyof AggregateDonation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDonation[P]>
      : GetScalarType<T[P], AggregateDonation[P]>
  }




  export type DonationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonationWhereInput
    orderBy?: DonationOrderByWithAggregationInput | DonationOrderByWithAggregationInput[]
    by: DonationScalarFieldEnum[] | DonationScalarFieldEnum
    having?: DonationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DonationCountAggregateInputType | true
    _avg?: DonationAvgAggregateInputType
    _sum?: DonationSumAggregateInputType
    _min?: DonationMinAggregateInputType
    _max?: DonationMaxAggregateInputType
  }

  export type DonationGroupByOutputType = {
    id: number
    userId: number
    amount: number
    status: string
    paymentMethod: string | null
    transactionId: string
    createdAt: Date
    updatedAt: Date
    _count: DonationCountAggregateOutputType | null
    _avg: DonationAvgAggregateOutputType | null
    _sum: DonationSumAggregateOutputType | null
    _min: DonationMinAggregateOutputType | null
    _max: DonationMaxAggregateOutputType | null
  }

  type GetDonationGroupByPayload<T extends DonationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DonationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DonationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DonationGroupByOutputType[P]>
            : GetScalarType<T[P], DonationGroupByOutputType[P]>
        }
      >
    >


  export type DonationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["donation"]>



  export type DonationSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DonationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "amount" | "status" | "paymentMethod" | "transactionId" | "createdAt" | "updatedAt", ExtArgs["result"]["donation"]>
  export type DonationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DonationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Donation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      amount: number
      status: string
      paymentMethod: string | null
      transactionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["donation"]>
    composites: {}
  }

  type DonationGetPayload<S extends boolean | null | undefined | DonationDefaultArgs> = $Result.GetResult<Prisma.$DonationPayload, S>

  type DonationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DonationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DonationCountAggregateInputType | true
    }

  export interface DonationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Donation'], meta: { name: 'Donation' } }
    /**
     * Find zero or one Donation that matches the filter.
     * @param {DonationFindUniqueArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DonationFindUniqueArgs>(args: SelectSubset<T, DonationFindUniqueArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Donation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DonationFindUniqueOrThrowArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DonationFindUniqueOrThrowArgs>(args: SelectSubset<T, DonationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Donation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindFirstArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DonationFindFirstArgs>(args?: SelectSubset<T, DonationFindFirstArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Donation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindFirstOrThrowArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DonationFindFirstOrThrowArgs>(args?: SelectSubset<T, DonationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Donations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Donations
     * const donations = await prisma.donation.findMany()
     * 
     * // Get first 10 Donations
     * const donations = await prisma.donation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const donationWithIdOnly = await prisma.donation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DonationFindManyArgs>(args?: SelectSubset<T, DonationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Donation.
     * @param {DonationCreateArgs} args - Arguments to create a Donation.
     * @example
     * // Create one Donation
     * const Donation = await prisma.donation.create({
     *   data: {
     *     // ... data to create a Donation
     *   }
     * })
     * 
     */
    create<T extends DonationCreateArgs>(args: SelectSubset<T, DonationCreateArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Donations.
     * @param {DonationCreateManyArgs} args - Arguments to create many Donations.
     * @example
     * // Create many Donations
     * const donation = await prisma.donation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DonationCreateManyArgs>(args?: SelectSubset<T, DonationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Donation.
     * @param {DonationDeleteArgs} args - Arguments to delete one Donation.
     * @example
     * // Delete one Donation
     * const Donation = await prisma.donation.delete({
     *   where: {
     *     // ... filter to delete one Donation
     *   }
     * })
     * 
     */
    delete<T extends DonationDeleteArgs>(args: SelectSubset<T, DonationDeleteArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Donation.
     * @param {DonationUpdateArgs} args - Arguments to update one Donation.
     * @example
     * // Update one Donation
     * const donation = await prisma.donation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DonationUpdateArgs>(args: SelectSubset<T, DonationUpdateArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Donations.
     * @param {DonationDeleteManyArgs} args - Arguments to filter Donations to delete.
     * @example
     * // Delete a few Donations
     * const { count } = await prisma.donation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DonationDeleteManyArgs>(args?: SelectSubset<T, DonationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Donations
     * const donation = await prisma.donation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DonationUpdateManyArgs>(args: SelectSubset<T, DonationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Donation.
     * @param {DonationUpsertArgs} args - Arguments to update or create a Donation.
     * @example
     * // Update or create a Donation
     * const donation = await prisma.donation.upsert({
     *   create: {
     *     // ... data to create a Donation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Donation we want to update
     *   }
     * })
     */
    upsert<T extends DonationUpsertArgs>(args: SelectSubset<T, DonationUpsertArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationCountArgs} args - Arguments to filter Donations to count.
     * @example
     * // Count the number of Donations
     * const count = await prisma.donation.count({
     *   where: {
     *     // ... the filter for the Donations we want to count
     *   }
     * })
    **/
    count<T extends DonationCountArgs>(
      args?: Subset<T, DonationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DonationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Donation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DonationAggregateArgs>(args: Subset<T, DonationAggregateArgs>): Prisma.PrismaPromise<GetDonationAggregateType<T>>

    /**
     * Group by Donation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DonationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DonationGroupByArgs['orderBy'] }
        : { orderBy?: DonationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DonationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDonationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Donation model
   */
  readonly fields: DonationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Donation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DonationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Donation model
   */
  interface DonationFieldRefs {
    readonly id: FieldRef<"Donation", 'Int'>
    readonly userId: FieldRef<"Donation", 'Int'>
    readonly amount: FieldRef<"Donation", 'Float'>
    readonly status: FieldRef<"Donation", 'String'>
    readonly paymentMethod: FieldRef<"Donation", 'String'>
    readonly transactionId: FieldRef<"Donation", 'String'>
    readonly createdAt: FieldRef<"Donation", 'DateTime'>
    readonly updatedAt: FieldRef<"Donation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Donation findUnique
   */
  export type DonationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where: DonationWhereUniqueInput
  }

  /**
   * Donation findUniqueOrThrow
   */
  export type DonationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where: DonationWhereUniqueInput
  }

  /**
   * Donation findFirst
   */
  export type DonationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donations.
     */
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * Donation findFirstOrThrow
   */
  export type DonationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donations.
     */
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * Donation findMany
   */
  export type DonationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donations to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * Donation create
   */
  export type DonationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The data needed to create a Donation.
     */
    data: XOR<DonationCreateInput, DonationUncheckedCreateInput>
  }

  /**
   * Donation createMany
   */
  export type DonationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Donations.
     */
    data: DonationCreateManyInput | DonationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Donation update
   */
  export type DonationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The data needed to update a Donation.
     */
    data: XOR<DonationUpdateInput, DonationUncheckedUpdateInput>
    /**
     * Choose, which Donation to update.
     */
    where: DonationWhereUniqueInput
  }

  /**
   * Donation updateMany
   */
  export type DonationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Donations.
     */
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyInput>
    /**
     * Filter which Donations to update
     */
    where?: DonationWhereInput
    /**
     * Limit how many Donations to update.
     */
    limit?: number
  }

  /**
   * Donation upsert
   */
  export type DonationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The filter to search for the Donation to update in case it exists.
     */
    where: DonationWhereUniqueInput
    /**
     * In case the Donation found by the `where` argument doesn't exist, create a new Donation with this data.
     */
    create: XOR<DonationCreateInput, DonationUncheckedCreateInput>
    /**
     * In case the Donation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DonationUpdateInput, DonationUncheckedUpdateInput>
  }

  /**
   * Donation delete
   */
  export type DonationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter which Donation to delete.
     */
    where: DonationWhereUniqueInput
  }

  /**
   * Donation deleteMany
   */
  export type DonationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donations to delete
     */
    where?: DonationWhereInput
    /**
     * Limit how many Donations to delete.
     */
    limit?: number
  }

  /**
   * Donation without action
   */
  export type DonationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
  }


  /**
   * Model Book
   */

  export type AggregateBook = {
    _count: BookCountAggregateOutputType | null
    _avg: BookAvgAggregateOutputType | null
    _sum: BookSumAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  export type BookAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type BookSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type BookMinAggregateOutputType = {
    id: number | null
    name: string | null
    author: string | null
    fileName: string | null
    filePath: string | null
    fileSize: string | null
    price: number | null
    description: string | null
    coverImage: string | null
    uploadDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookMaxAggregateOutputType = {
    id: number | null
    name: string | null
    author: string | null
    fileName: string | null
    filePath: string | null
    fileSize: string | null
    price: number | null
    description: string | null
    coverImage: string | null
    uploadDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookCountAggregateOutputType = {
    id: number
    name: number
    author: number
    fileName: number
    filePath: number
    fileSize: number
    price: number
    description: number
    coverImage: number
    uploadDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type BookSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type BookMinAggregateInputType = {
    id?: true
    name?: true
    author?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    price?: true
    description?: true
    coverImage?: true
    uploadDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookMaxAggregateInputType = {
    id?: true
    name?: true
    author?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    price?: true
    description?: true
    coverImage?: true
    uploadDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookCountAggregateInputType = {
    id?: true
    name?: true
    author?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    price?: true
    description?: true
    coverImage?: true
    uploadDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Book to aggregate.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Books
    **/
    _count?: true | BookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookMaxAggregateInputType
  }

  export type GetBookAggregateType<T extends BookAggregateArgs> = {
        [P in keyof T & keyof AggregateBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook[P]>
      : GetScalarType<T[P], AggregateBook[P]>
  }




  export type BookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
    orderBy?: BookOrderByWithAggregationInput | BookOrderByWithAggregationInput[]
    by: BookScalarFieldEnum[] | BookScalarFieldEnum
    having?: BookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookCountAggregateInputType | true
    _avg?: BookAvgAggregateInputType
    _sum?: BookSumAggregateInputType
    _min?: BookMinAggregateInputType
    _max?: BookMaxAggregateInputType
  }

  export type BookGroupByOutputType = {
    id: number
    name: string
    author: string
    fileName: string
    filePath: string
    fileSize: string
    price: number
    description: string | null
    coverImage: string | null
    uploadDate: Date
    createdAt: Date
    updatedAt: Date
    _count: BookCountAggregateOutputType | null
    _avg: BookAvgAggregateOutputType | null
    _sum: BookSumAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  type GetBookGroupByPayload<T extends BookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookGroupByOutputType[P]>
            : GetScalarType<T[P], BookGroupByOutputType[P]>
        }
      >
    >


  export type BookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    author?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    price?: boolean
    description?: boolean
    coverImage?: boolean
    uploadDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchases?: boolean | Book$purchasesArgs<ExtArgs>
    orderItems?: boolean | Book$orderItemsArgs<ExtArgs>
    _count?: boolean | BookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book"]>



  export type BookSelectScalar = {
    id?: boolean
    name?: boolean
    author?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    price?: boolean
    description?: boolean
    coverImage?: boolean
    uploadDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "author" | "fileName" | "filePath" | "fileSize" | "price" | "description" | "coverImage" | "uploadDate" | "createdAt" | "updatedAt", ExtArgs["result"]["book"]>
  export type BookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | Book$purchasesArgs<ExtArgs>
    orderItems?: boolean | Book$orderItemsArgs<ExtArgs>
    _count?: boolean | BookCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Book"
    objects: {
      purchases: Prisma.$BookPurchasePayload<ExtArgs>[]
      orderItems: Prisma.$BookOrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      author: string
      fileName: string
      filePath: string
      fileSize: string
      price: number
      description: string | null
      coverImage: string | null
      uploadDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["book"]>
    composites: {}
  }

  type BookGetPayload<S extends boolean | null | undefined | BookDefaultArgs> = $Result.GetResult<Prisma.$BookPayload, S>

  type BookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookCountAggregateInputType | true
    }

  export interface BookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Book'], meta: { name: 'Book' } }
    /**
     * Find zero or one Book that matches the filter.
     * @param {BookFindUniqueArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookFindUniqueArgs>(args: SelectSubset<T, BookFindUniqueArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookFindUniqueOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookFindUniqueOrThrowArgs>(args: SelectSubset<T, BookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookFindFirstArgs>(args?: SelectSubset<T, BookFindFirstArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookFindFirstOrThrowArgs>(args?: SelectSubset<T, BookFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Books
     * const books = await prisma.book.findMany()
     * 
     * // Get first 10 Books
     * const books = await prisma.book.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookWithIdOnly = await prisma.book.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookFindManyArgs>(args?: SelectSubset<T, BookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book.
     * @param {BookCreateArgs} args - Arguments to create a Book.
     * @example
     * // Create one Book
     * const Book = await prisma.book.create({
     *   data: {
     *     // ... data to create a Book
     *   }
     * })
     * 
     */
    create<T extends BookCreateArgs>(args: SelectSubset<T, BookCreateArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Books.
     * @param {BookCreateManyArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const book = await prisma.book.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookCreateManyArgs>(args?: SelectSubset<T, BookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Book.
     * @param {BookDeleteArgs} args - Arguments to delete one Book.
     * @example
     * // Delete one Book
     * const Book = await prisma.book.delete({
     *   where: {
     *     // ... filter to delete one Book
     *   }
     * })
     * 
     */
    delete<T extends BookDeleteArgs>(args: SelectSubset<T, BookDeleteArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book.
     * @param {BookUpdateArgs} args - Arguments to update one Book.
     * @example
     * // Update one Book
     * const book = await prisma.book.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookUpdateArgs>(args: SelectSubset<T, BookUpdateArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Books.
     * @param {BookDeleteManyArgs} args - Arguments to filter Books to delete.
     * @example
     * // Delete a few Books
     * const { count } = await prisma.book.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookDeleteManyArgs>(args?: SelectSubset<T, BookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Books
     * const book = await prisma.book.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookUpdateManyArgs>(args: SelectSubset<T, BookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Book.
     * @param {BookUpsertArgs} args - Arguments to update or create a Book.
     * @example
     * // Update or create a Book
     * const book = await prisma.book.upsert({
     *   create: {
     *     // ... data to create a Book
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book we want to update
     *   }
     * })
     */
    upsert<T extends BookUpsertArgs>(args: SelectSubset<T, BookUpsertArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCountArgs} args - Arguments to filter Books to count.
     * @example
     * // Count the number of Books
     * const count = await prisma.book.count({
     *   where: {
     *     // ... the filter for the Books we want to count
     *   }
     * })
    **/
    count<T extends BookCountArgs>(
      args?: Subset<T, BookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookAggregateArgs>(args: Subset<T, BookAggregateArgs>): Prisma.PrismaPromise<GetBookAggregateType<T>>

    /**
     * Group by Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookGroupByArgs['orderBy'] }
        : { orderBy?: BookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Book model
   */
  readonly fields: BookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Book.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchases<T extends Book$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Book$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Book$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Book$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Book model
   */
  interface BookFieldRefs {
    readonly id: FieldRef<"Book", 'Int'>
    readonly name: FieldRef<"Book", 'String'>
    readonly author: FieldRef<"Book", 'String'>
    readonly fileName: FieldRef<"Book", 'String'>
    readonly filePath: FieldRef<"Book", 'String'>
    readonly fileSize: FieldRef<"Book", 'String'>
    readonly price: FieldRef<"Book", 'Float'>
    readonly description: FieldRef<"Book", 'String'>
    readonly coverImage: FieldRef<"Book", 'String'>
    readonly uploadDate: FieldRef<"Book", 'DateTime'>
    readonly createdAt: FieldRef<"Book", 'DateTime'>
    readonly updatedAt: FieldRef<"Book", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Book findUnique
   */
  export type BookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book findUniqueOrThrow
   */
  export type BookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book findFirst
   */
  export type BookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book findFirstOrThrow
   */
  export type BookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book findMany
   */
  export type BookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Books to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book create
   */
  export type BookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * The data needed to create a Book.
     */
    data: XOR<BookCreateInput, BookUncheckedCreateInput>
  }

  /**
   * Book createMany
   */
  export type BookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Books.
     */
    data: BookCreateManyInput | BookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Book update
   */
  export type BookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * The data needed to update a Book.
     */
    data: XOR<BookUpdateInput, BookUncheckedUpdateInput>
    /**
     * Choose, which Book to update.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book updateMany
   */
  export type BookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Books.
     */
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyInput>
    /**
     * Filter which Books to update
     */
    where?: BookWhereInput
    /**
     * Limit how many Books to update.
     */
    limit?: number
  }

  /**
   * Book upsert
   */
  export type BookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * The filter to search for the Book to update in case it exists.
     */
    where: BookWhereUniqueInput
    /**
     * In case the Book found by the `where` argument doesn't exist, create a new Book with this data.
     */
    create: XOR<BookCreateInput, BookUncheckedCreateInput>
    /**
     * In case the Book was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookUpdateInput, BookUncheckedUpdateInput>
  }

  /**
   * Book delete
   */
  export type BookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter which Book to delete.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book deleteMany
   */
  export type BookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Books to delete
     */
    where?: BookWhereInput
    /**
     * Limit how many Books to delete.
     */
    limit?: number
  }

  /**
   * Book.purchases
   */
  export type Book$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPurchase
     */
    select?: BookPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPurchase
     */
    omit?: BookPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPurchaseInclude<ExtArgs> | null
    where?: BookPurchaseWhereInput
    orderBy?: BookPurchaseOrderByWithRelationInput | BookPurchaseOrderByWithRelationInput[]
    cursor?: BookPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookPurchaseScalarFieldEnum | BookPurchaseScalarFieldEnum[]
  }

  /**
   * Book.orderItems
   */
  export type Book$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrderItem
     */
    select?: BookOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrderItem
     */
    omit?: BookOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderItemInclude<ExtArgs> | null
    where?: BookOrderItemWhereInput
    orderBy?: BookOrderItemOrderByWithRelationInput | BookOrderItemOrderByWithRelationInput[]
    cursor?: BookOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookOrderItemScalarFieldEnum | BookOrderItemScalarFieldEnum[]
  }

  /**
   * Book without action
   */
  export type BookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
  }


  /**
   * Model BookCoupon
   */

  export type AggregateBookCoupon = {
    _count: BookCouponCountAggregateOutputType | null
    _avg: BookCouponAvgAggregateOutputType | null
    _sum: BookCouponSumAggregateOutputType | null
    _min: BookCouponMinAggregateOutputType | null
    _max: BookCouponMaxAggregateOutputType | null
  }

  export type BookCouponAvgAggregateOutputType = {
    id: number | null
    discount: number | null
  }

  export type BookCouponSumAggregateOutputType = {
    id: number | null
    discount: number | null
  }

  export type BookCouponMinAggregateOutputType = {
    id: number | null
    code: string | null
    discount: number | null
    type: string | null
    description: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookCouponMaxAggregateOutputType = {
    id: number | null
    code: string | null
    discount: number | null
    type: string | null
    description: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookCouponCountAggregateOutputType = {
    id: number
    code: number
    discount: number
    type: number
    description: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookCouponAvgAggregateInputType = {
    id?: true
    discount?: true
  }

  export type BookCouponSumAggregateInputType = {
    id?: true
    discount?: true
  }

  export type BookCouponMinAggregateInputType = {
    id?: true
    code?: true
    discount?: true
    type?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookCouponMaxAggregateInputType = {
    id?: true
    code?: true
    discount?: true
    type?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookCouponCountAggregateInputType = {
    id?: true
    code?: true
    discount?: true
    type?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookCouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookCoupon to aggregate.
     */
    where?: BookCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookCoupons to fetch.
     */
    orderBy?: BookCouponOrderByWithRelationInput | BookCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookCoupons
    **/
    _count?: true | BookCouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookCouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookCouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookCouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookCouponMaxAggregateInputType
  }

  export type GetBookCouponAggregateType<T extends BookCouponAggregateArgs> = {
        [P in keyof T & keyof AggregateBookCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookCoupon[P]>
      : GetScalarType<T[P], AggregateBookCoupon[P]>
  }




  export type BookCouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookCouponWhereInput
    orderBy?: BookCouponOrderByWithAggregationInput | BookCouponOrderByWithAggregationInput[]
    by: BookCouponScalarFieldEnum[] | BookCouponScalarFieldEnum
    having?: BookCouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookCouponCountAggregateInputType | true
    _avg?: BookCouponAvgAggregateInputType
    _sum?: BookCouponSumAggregateInputType
    _min?: BookCouponMinAggregateInputType
    _max?: BookCouponMaxAggregateInputType
  }

  export type BookCouponGroupByOutputType = {
    id: number
    code: string
    discount: number
    type: string
    description: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: BookCouponCountAggregateOutputType | null
    _avg: BookCouponAvgAggregateOutputType | null
    _sum: BookCouponSumAggregateOutputType | null
    _min: BookCouponMinAggregateOutputType | null
    _max: BookCouponMaxAggregateOutputType | null
  }

  type GetBookCouponGroupByPayload<T extends BookCouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookCouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookCouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookCouponGroupByOutputType[P]>
            : GetScalarType<T[P], BookCouponGroupByOutputType[P]>
        }
      >
    >


  export type BookCouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    discount?: boolean
    type?: boolean
    description?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | BookCoupon$ordersArgs<ExtArgs>
    _count?: boolean | BookCouponCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookCoupon"]>



  export type BookCouponSelectScalar = {
    id?: boolean
    code?: boolean
    discount?: boolean
    type?: boolean
    description?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookCouponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "discount" | "type" | "description" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["bookCoupon"]>
  export type BookCouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | BookCoupon$ordersArgs<ExtArgs>
    _count?: boolean | BookCouponCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BookCouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookCoupon"
    objects: {
      orders: Prisma.$BookOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      discount: number
      type: string
      description: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bookCoupon"]>
    composites: {}
  }

  type BookCouponGetPayload<S extends boolean | null | undefined | BookCouponDefaultArgs> = $Result.GetResult<Prisma.$BookCouponPayload, S>

  type BookCouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookCouponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookCouponCountAggregateInputType | true
    }

  export interface BookCouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookCoupon'], meta: { name: 'BookCoupon' } }
    /**
     * Find zero or one BookCoupon that matches the filter.
     * @param {BookCouponFindUniqueArgs} args - Arguments to find a BookCoupon
     * @example
     * // Get one BookCoupon
     * const bookCoupon = await prisma.bookCoupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookCouponFindUniqueArgs>(args: SelectSubset<T, BookCouponFindUniqueArgs<ExtArgs>>): Prisma__BookCouponClient<$Result.GetResult<Prisma.$BookCouponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookCoupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookCouponFindUniqueOrThrowArgs} args - Arguments to find a BookCoupon
     * @example
     * // Get one BookCoupon
     * const bookCoupon = await prisma.bookCoupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookCouponFindUniqueOrThrowArgs>(args: SelectSubset<T, BookCouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookCouponClient<$Result.GetResult<Prisma.$BookCouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookCoupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCouponFindFirstArgs} args - Arguments to find a BookCoupon
     * @example
     * // Get one BookCoupon
     * const bookCoupon = await prisma.bookCoupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookCouponFindFirstArgs>(args?: SelectSubset<T, BookCouponFindFirstArgs<ExtArgs>>): Prisma__BookCouponClient<$Result.GetResult<Prisma.$BookCouponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookCoupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCouponFindFirstOrThrowArgs} args - Arguments to find a BookCoupon
     * @example
     * // Get one BookCoupon
     * const bookCoupon = await prisma.bookCoupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookCouponFindFirstOrThrowArgs>(args?: SelectSubset<T, BookCouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookCouponClient<$Result.GetResult<Prisma.$BookCouponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookCoupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookCoupons
     * const bookCoupons = await prisma.bookCoupon.findMany()
     * 
     * // Get first 10 BookCoupons
     * const bookCoupons = await prisma.bookCoupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookCouponWithIdOnly = await prisma.bookCoupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookCouponFindManyArgs>(args?: SelectSubset<T, BookCouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookCouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookCoupon.
     * @param {BookCouponCreateArgs} args - Arguments to create a BookCoupon.
     * @example
     * // Create one BookCoupon
     * const BookCoupon = await prisma.bookCoupon.create({
     *   data: {
     *     // ... data to create a BookCoupon
     *   }
     * })
     * 
     */
    create<T extends BookCouponCreateArgs>(args: SelectSubset<T, BookCouponCreateArgs<ExtArgs>>): Prisma__BookCouponClient<$Result.GetResult<Prisma.$BookCouponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookCoupons.
     * @param {BookCouponCreateManyArgs} args - Arguments to create many BookCoupons.
     * @example
     * // Create many BookCoupons
     * const bookCoupon = await prisma.bookCoupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookCouponCreateManyArgs>(args?: SelectSubset<T, BookCouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BookCoupon.
     * @param {BookCouponDeleteArgs} args - Arguments to delete one BookCoupon.
     * @example
     * // Delete one BookCoupon
     * const BookCoupon = await prisma.bookCoupon.delete({
     *   where: {
     *     // ... filter to delete one BookCoupon
     *   }
     * })
     * 
     */
    delete<T extends BookCouponDeleteArgs>(args: SelectSubset<T, BookCouponDeleteArgs<ExtArgs>>): Prisma__BookCouponClient<$Result.GetResult<Prisma.$BookCouponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookCoupon.
     * @param {BookCouponUpdateArgs} args - Arguments to update one BookCoupon.
     * @example
     * // Update one BookCoupon
     * const bookCoupon = await prisma.bookCoupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookCouponUpdateArgs>(args: SelectSubset<T, BookCouponUpdateArgs<ExtArgs>>): Prisma__BookCouponClient<$Result.GetResult<Prisma.$BookCouponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookCoupons.
     * @param {BookCouponDeleteManyArgs} args - Arguments to filter BookCoupons to delete.
     * @example
     * // Delete a few BookCoupons
     * const { count } = await prisma.bookCoupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookCouponDeleteManyArgs>(args?: SelectSubset<T, BookCouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookCoupons
     * const bookCoupon = await prisma.bookCoupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookCouponUpdateManyArgs>(args: SelectSubset<T, BookCouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookCoupon.
     * @param {BookCouponUpsertArgs} args - Arguments to update or create a BookCoupon.
     * @example
     * // Update or create a BookCoupon
     * const bookCoupon = await prisma.bookCoupon.upsert({
     *   create: {
     *     // ... data to create a BookCoupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookCoupon we want to update
     *   }
     * })
     */
    upsert<T extends BookCouponUpsertArgs>(args: SelectSubset<T, BookCouponUpsertArgs<ExtArgs>>): Prisma__BookCouponClient<$Result.GetResult<Prisma.$BookCouponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookCoupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCouponCountArgs} args - Arguments to filter BookCoupons to count.
     * @example
     * // Count the number of BookCoupons
     * const count = await prisma.bookCoupon.count({
     *   where: {
     *     // ... the filter for the BookCoupons we want to count
     *   }
     * })
    **/
    count<T extends BookCouponCountArgs>(
      args?: Subset<T, BookCouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookCouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookCoupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookCouponAggregateArgs>(args: Subset<T, BookCouponAggregateArgs>): Prisma.PrismaPromise<GetBookCouponAggregateType<T>>

    /**
     * Group by BookCoupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookCouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookCouponGroupByArgs['orderBy'] }
        : { orderBy?: BookCouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookCouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookCoupon model
   */
  readonly fields: BookCouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookCoupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookCouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends BookCoupon$ordersArgs<ExtArgs> = {}>(args?: Subset<T, BookCoupon$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookCoupon model
   */
  interface BookCouponFieldRefs {
    readonly id: FieldRef<"BookCoupon", 'Int'>
    readonly code: FieldRef<"BookCoupon", 'String'>
    readonly discount: FieldRef<"BookCoupon", 'Float'>
    readonly type: FieldRef<"BookCoupon", 'String'>
    readonly description: FieldRef<"BookCoupon", 'String'>
    readonly active: FieldRef<"BookCoupon", 'Boolean'>
    readonly createdAt: FieldRef<"BookCoupon", 'DateTime'>
    readonly updatedAt: FieldRef<"BookCoupon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookCoupon findUnique
   */
  export type BookCouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCoupon
     */
    select?: BookCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCoupon
     */
    omit?: BookCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCouponInclude<ExtArgs> | null
    /**
     * Filter, which BookCoupon to fetch.
     */
    where: BookCouponWhereUniqueInput
  }

  /**
   * BookCoupon findUniqueOrThrow
   */
  export type BookCouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCoupon
     */
    select?: BookCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCoupon
     */
    omit?: BookCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCouponInclude<ExtArgs> | null
    /**
     * Filter, which BookCoupon to fetch.
     */
    where: BookCouponWhereUniqueInput
  }

  /**
   * BookCoupon findFirst
   */
  export type BookCouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCoupon
     */
    select?: BookCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCoupon
     */
    omit?: BookCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCouponInclude<ExtArgs> | null
    /**
     * Filter, which BookCoupon to fetch.
     */
    where?: BookCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookCoupons to fetch.
     */
    orderBy?: BookCouponOrderByWithRelationInput | BookCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookCoupons.
     */
    cursor?: BookCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookCoupons.
     */
    distinct?: BookCouponScalarFieldEnum | BookCouponScalarFieldEnum[]
  }

  /**
   * BookCoupon findFirstOrThrow
   */
  export type BookCouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCoupon
     */
    select?: BookCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCoupon
     */
    omit?: BookCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCouponInclude<ExtArgs> | null
    /**
     * Filter, which BookCoupon to fetch.
     */
    where?: BookCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookCoupons to fetch.
     */
    orderBy?: BookCouponOrderByWithRelationInput | BookCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookCoupons.
     */
    cursor?: BookCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookCoupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookCoupons.
     */
    distinct?: BookCouponScalarFieldEnum | BookCouponScalarFieldEnum[]
  }

  /**
   * BookCoupon findMany
   */
  export type BookCouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCoupon
     */
    select?: BookCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCoupon
     */
    omit?: BookCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCouponInclude<ExtArgs> | null
    /**
     * Filter, which BookCoupons to fetch.
     */
    where?: BookCouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookCoupons to fetch.
     */
    orderBy?: BookCouponOrderByWithRelationInput | BookCouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookCoupons.
     */
    cursor?: BookCouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookCoupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookCoupons.
     */
    skip?: number
    distinct?: BookCouponScalarFieldEnum | BookCouponScalarFieldEnum[]
  }

  /**
   * BookCoupon create
   */
  export type BookCouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCoupon
     */
    select?: BookCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCoupon
     */
    omit?: BookCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCouponInclude<ExtArgs> | null
    /**
     * The data needed to create a BookCoupon.
     */
    data: XOR<BookCouponCreateInput, BookCouponUncheckedCreateInput>
  }

  /**
   * BookCoupon createMany
   */
  export type BookCouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookCoupons.
     */
    data: BookCouponCreateManyInput | BookCouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookCoupon update
   */
  export type BookCouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCoupon
     */
    select?: BookCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCoupon
     */
    omit?: BookCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCouponInclude<ExtArgs> | null
    /**
     * The data needed to update a BookCoupon.
     */
    data: XOR<BookCouponUpdateInput, BookCouponUncheckedUpdateInput>
    /**
     * Choose, which BookCoupon to update.
     */
    where: BookCouponWhereUniqueInput
  }

  /**
   * BookCoupon updateMany
   */
  export type BookCouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookCoupons.
     */
    data: XOR<BookCouponUpdateManyMutationInput, BookCouponUncheckedUpdateManyInput>
    /**
     * Filter which BookCoupons to update
     */
    where?: BookCouponWhereInput
    /**
     * Limit how many BookCoupons to update.
     */
    limit?: number
  }

  /**
   * BookCoupon upsert
   */
  export type BookCouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCoupon
     */
    select?: BookCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCoupon
     */
    omit?: BookCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCouponInclude<ExtArgs> | null
    /**
     * The filter to search for the BookCoupon to update in case it exists.
     */
    where: BookCouponWhereUniqueInput
    /**
     * In case the BookCoupon found by the `where` argument doesn't exist, create a new BookCoupon with this data.
     */
    create: XOR<BookCouponCreateInput, BookCouponUncheckedCreateInput>
    /**
     * In case the BookCoupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookCouponUpdateInput, BookCouponUncheckedUpdateInput>
  }

  /**
   * BookCoupon delete
   */
  export type BookCouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCoupon
     */
    select?: BookCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCoupon
     */
    omit?: BookCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCouponInclude<ExtArgs> | null
    /**
     * Filter which BookCoupon to delete.
     */
    where: BookCouponWhereUniqueInput
  }

  /**
   * BookCoupon deleteMany
   */
  export type BookCouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookCoupons to delete
     */
    where?: BookCouponWhereInput
    /**
     * Limit how many BookCoupons to delete.
     */
    limit?: number
  }

  /**
   * BookCoupon.orders
   */
  export type BookCoupon$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrder
     */
    select?: BookOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrder
     */
    omit?: BookOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderInclude<ExtArgs> | null
    where?: BookOrderWhereInput
    orderBy?: BookOrderOrderByWithRelationInput | BookOrderOrderByWithRelationInput[]
    cursor?: BookOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookOrderScalarFieldEnum | BookOrderScalarFieldEnum[]
  }

  /**
   * BookCoupon without action
   */
  export type BookCouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCoupon
     */
    select?: BookCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCoupon
     */
    omit?: BookCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCouponInclude<ExtArgs> | null
  }


  /**
   * Model BookOrder
   */

  export type AggregateBookOrder = {
    _count: BookOrderCountAggregateOutputType | null
    _avg: BookOrderAvgAggregateOutputType | null
    _sum: BookOrderSumAggregateOutputType | null
    _min: BookOrderMinAggregateOutputType | null
    _max: BookOrderMaxAggregateOutputType | null
  }

  export type BookOrderAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    totalAmount: number | null
    discountAmount: number | null
    finalAmount: number | null
    couponId: number | null
  }

  export type BookOrderSumAggregateOutputType = {
    id: number | null
    userId: number | null
    totalAmount: number | null
    discountAmount: number | null
    finalAmount: number | null
    couponId: number | null
  }

  export type BookOrderMinAggregateOutputType = {
    id: number | null
    userId: number | null
    totalAmount: number | null
    discountAmount: number | null
    finalAmount: number | null
    couponId: number | null
    paymentId: string | null
    orderId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookOrderMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    totalAmount: number | null
    discountAmount: number | null
    finalAmount: number | null
    couponId: number | null
    paymentId: string | null
    orderId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookOrderCountAggregateOutputType = {
    id: number
    userId: number
    totalAmount: number
    discountAmount: number
    finalAmount: number
    couponId: number
    paymentId: number
    orderId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookOrderAvgAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    couponId?: true
  }

  export type BookOrderSumAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    couponId?: true
  }

  export type BookOrderMinAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    couponId?: true
    paymentId?: true
    orderId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookOrderMaxAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    couponId?: true
    paymentId?: true
    orderId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookOrderCountAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    couponId?: true
    paymentId?: true
    orderId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookOrder to aggregate.
     */
    where?: BookOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookOrders to fetch.
     */
    orderBy?: BookOrderOrderByWithRelationInput | BookOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookOrders
    **/
    _count?: true | BookOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookOrderMaxAggregateInputType
  }

  export type GetBookOrderAggregateType<T extends BookOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateBookOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookOrder[P]>
      : GetScalarType<T[P], AggregateBookOrder[P]>
  }




  export type BookOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookOrderWhereInput
    orderBy?: BookOrderOrderByWithAggregationInput | BookOrderOrderByWithAggregationInput[]
    by: BookOrderScalarFieldEnum[] | BookOrderScalarFieldEnum
    having?: BookOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookOrderCountAggregateInputType | true
    _avg?: BookOrderAvgAggregateInputType
    _sum?: BookOrderSumAggregateInputType
    _min?: BookOrderMinAggregateInputType
    _max?: BookOrderMaxAggregateInputType
  }

  export type BookOrderGroupByOutputType = {
    id: number
    userId: number
    totalAmount: number
    discountAmount: number
    finalAmount: number
    couponId: number | null
    paymentId: string | null
    orderId: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: BookOrderCountAggregateOutputType | null
    _avg: BookOrderAvgAggregateOutputType | null
    _sum: BookOrderSumAggregateOutputType | null
    _min: BookOrderMinAggregateOutputType | null
    _max: BookOrderMaxAggregateOutputType | null
  }

  type GetBookOrderGroupByPayload<T extends BookOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookOrderGroupByOutputType[P]>
            : GetScalarType<T[P], BookOrderGroupByOutputType[P]>
        }
      >
    >


  export type BookOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    finalAmount?: boolean
    couponId?: boolean
    paymentId?: boolean
    orderId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | BookOrder$couponArgs<ExtArgs>
    items?: boolean | BookOrder$itemsArgs<ExtArgs>
    purchases?: boolean | BookOrder$purchasesArgs<ExtArgs>
    _count?: boolean | BookOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookOrder"]>



  export type BookOrderSelectScalar = {
    id?: boolean
    userId?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    finalAmount?: boolean
    couponId?: boolean
    paymentId?: boolean
    orderId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "totalAmount" | "discountAmount" | "finalAmount" | "couponId" | "paymentId" | "orderId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["bookOrder"]>
  export type BookOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | BookOrder$couponArgs<ExtArgs>
    items?: boolean | BookOrder$itemsArgs<ExtArgs>
    purchases?: boolean | BookOrder$purchasesArgs<ExtArgs>
    _count?: boolean | BookOrderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BookOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookOrder"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      coupon: Prisma.$BookCouponPayload<ExtArgs> | null
      items: Prisma.$BookOrderItemPayload<ExtArgs>[]
      purchases: Prisma.$BookPurchasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      totalAmount: number
      discountAmount: number
      finalAmount: number
      couponId: number | null
      paymentId: string | null
      orderId: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bookOrder"]>
    composites: {}
  }

  type BookOrderGetPayload<S extends boolean | null | undefined | BookOrderDefaultArgs> = $Result.GetResult<Prisma.$BookOrderPayload, S>

  type BookOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookOrderCountAggregateInputType | true
    }

  export interface BookOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookOrder'], meta: { name: 'BookOrder' } }
    /**
     * Find zero or one BookOrder that matches the filter.
     * @param {BookOrderFindUniqueArgs} args - Arguments to find a BookOrder
     * @example
     * // Get one BookOrder
     * const bookOrder = await prisma.bookOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookOrderFindUniqueArgs>(args: SelectSubset<T, BookOrderFindUniqueArgs<ExtArgs>>): Prisma__BookOrderClient<$Result.GetResult<Prisma.$BookOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookOrderFindUniqueOrThrowArgs} args - Arguments to find a BookOrder
     * @example
     * // Get one BookOrder
     * const bookOrder = await prisma.bookOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, BookOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookOrderClient<$Result.GetResult<Prisma.$BookOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookOrderFindFirstArgs} args - Arguments to find a BookOrder
     * @example
     * // Get one BookOrder
     * const bookOrder = await prisma.bookOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookOrderFindFirstArgs>(args?: SelectSubset<T, BookOrderFindFirstArgs<ExtArgs>>): Prisma__BookOrderClient<$Result.GetResult<Prisma.$BookOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookOrderFindFirstOrThrowArgs} args - Arguments to find a BookOrder
     * @example
     * // Get one BookOrder
     * const bookOrder = await prisma.bookOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, BookOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookOrderClient<$Result.GetResult<Prisma.$BookOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookOrders
     * const bookOrders = await prisma.bookOrder.findMany()
     * 
     * // Get first 10 BookOrders
     * const bookOrders = await prisma.bookOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookOrderWithIdOnly = await prisma.bookOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookOrderFindManyArgs>(args?: SelectSubset<T, BookOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookOrder.
     * @param {BookOrderCreateArgs} args - Arguments to create a BookOrder.
     * @example
     * // Create one BookOrder
     * const BookOrder = await prisma.bookOrder.create({
     *   data: {
     *     // ... data to create a BookOrder
     *   }
     * })
     * 
     */
    create<T extends BookOrderCreateArgs>(args: SelectSubset<T, BookOrderCreateArgs<ExtArgs>>): Prisma__BookOrderClient<$Result.GetResult<Prisma.$BookOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookOrders.
     * @param {BookOrderCreateManyArgs} args - Arguments to create many BookOrders.
     * @example
     * // Create many BookOrders
     * const bookOrder = await prisma.bookOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookOrderCreateManyArgs>(args?: SelectSubset<T, BookOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BookOrder.
     * @param {BookOrderDeleteArgs} args - Arguments to delete one BookOrder.
     * @example
     * // Delete one BookOrder
     * const BookOrder = await prisma.bookOrder.delete({
     *   where: {
     *     // ... filter to delete one BookOrder
     *   }
     * })
     * 
     */
    delete<T extends BookOrderDeleteArgs>(args: SelectSubset<T, BookOrderDeleteArgs<ExtArgs>>): Prisma__BookOrderClient<$Result.GetResult<Prisma.$BookOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookOrder.
     * @param {BookOrderUpdateArgs} args - Arguments to update one BookOrder.
     * @example
     * // Update one BookOrder
     * const bookOrder = await prisma.bookOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookOrderUpdateArgs>(args: SelectSubset<T, BookOrderUpdateArgs<ExtArgs>>): Prisma__BookOrderClient<$Result.GetResult<Prisma.$BookOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookOrders.
     * @param {BookOrderDeleteManyArgs} args - Arguments to filter BookOrders to delete.
     * @example
     * // Delete a few BookOrders
     * const { count } = await prisma.bookOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookOrderDeleteManyArgs>(args?: SelectSubset<T, BookOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookOrders
     * const bookOrder = await prisma.bookOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookOrderUpdateManyArgs>(args: SelectSubset<T, BookOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookOrder.
     * @param {BookOrderUpsertArgs} args - Arguments to update or create a BookOrder.
     * @example
     * // Update or create a BookOrder
     * const bookOrder = await prisma.bookOrder.upsert({
     *   create: {
     *     // ... data to create a BookOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookOrder we want to update
     *   }
     * })
     */
    upsert<T extends BookOrderUpsertArgs>(args: SelectSubset<T, BookOrderUpsertArgs<ExtArgs>>): Prisma__BookOrderClient<$Result.GetResult<Prisma.$BookOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookOrderCountArgs} args - Arguments to filter BookOrders to count.
     * @example
     * // Count the number of BookOrders
     * const count = await prisma.bookOrder.count({
     *   where: {
     *     // ... the filter for the BookOrders we want to count
     *   }
     * })
    **/
    count<T extends BookOrderCountArgs>(
      args?: Subset<T, BookOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookOrderAggregateArgs>(args: Subset<T, BookOrderAggregateArgs>): Prisma.PrismaPromise<GetBookOrderAggregateType<T>>

    /**
     * Group by BookOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookOrderGroupByArgs['orderBy'] }
        : { orderBy?: BookOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookOrder model
   */
  readonly fields: BookOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    coupon<T extends BookOrder$couponArgs<ExtArgs> = {}>(args?: Subset<T, BookOrder$couponArgs<ExtArgs>>): Prisma__BookCouponClient<$Result.GetResult<Prisma.$BookCouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends BookOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, BookOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchases<T extends BookOrder$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, BookOrder$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookOrder model
   */
  interface BookOrderFieldRefs {
    readonly id: FieldRef<"BookOrder", 'Int'>
    readonly userId: FieldRef<"BookOrder", 'Int'>
    readonly totalAmount: FieldRef<"BookOrder", 'Float'>
    readonly discountAmount: FieldRef<"BookOrder", 'Float'>
    readonly finalAmount: FieldRef<"BookOrder", 'Float'>
    readonly couponId: FieldRef<"BookOrder", 'Int'>
    readonly paymentId: FieldRef<"BookOrder", 'String'>
    readonly orderId: FieldRef<"BookOrder", 'String'>
    readonly status: FieldRef<"BookOrder", 'String'>
    readonly createdAt: FieldRef<"BookOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"BookOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookOrder findUnique
   */
  export type BookOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrder
     */
    select?: BookOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrder
     */
    omit?: BookOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderInclude<ExtArgs> | null
    /**
     * Filter, which BookOrder to fetch.
     */
    where: BookOrderWhereUniqueInput
  }

  /**
   * BookOrder findUniqueOrThrow
   */
  export type BookOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrder
     */
    select?: BookOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrder
     */
    omit?: BookOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderInclude<ExtArgs> | null
    /**
     * Filter, which BookOrder to fetch.
     */
    where: BookOrderWhereUniqueInput
  }

  /**
   * BookOrder findFirst
   */
  export type BookOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrder
     */
    select?: BookOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrder
     */
    omit?: BookOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderInclude<ExtArgs> | null
    /**
     * Filter, which BookOrder to fetch.
     */
    where?: BookOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookOrders to fetch.
     */
    orderBy?: BookOrderOrderByWithRelationInput | BookOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookOrders.
     */
    cursor?: BookOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookOrders.
     */
    distinct?: BookOrderScalarFieldEnum | BookOrderScalarFieldEnum[]
  }

  /**
   * BookOrder findFirstOrThrow
   */
  export type BookOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrder
     */
    select?: BookOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrder
     */
    omit?: BookOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderInclude<ExtArgs> | null
    /**
     * Filter, which BookOrder to fetch.
     */
    where?: BookOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookOrders to fetch.
     */
    orderBy?: BookOrderOrderByWithRelationInput | BookOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookOrders.
     */
    cursor?: BookOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookOrders.
     */
    distinct?: BookOrderScalarFieldEnum | BookOrderScalarFieldEnum[]
  }

  /**
   * BookOrder findMany
   */
  export type BookOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrder
     */
    select?: BookOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrder
     */
    omit?: BookOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderInclude<ExtArgs> | null
    /**
     * Filter, which BookOrders to fetch.
     */
    where?: BookOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookOrders to fetch.
     */
    orderBy?: BookOrderOrderByWithRelationInput | BookOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookOrders.
     */
    cursor?: BookOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookOrders.
     */
    skip?: number
    distinct?: BookOrderScalarFieldEnum | BookOrderScalarFieldEnum[]
  }

  /**
   * BookOrder create
   */
  export type BookOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrder
     */
    select?: BookOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrder
     */
    omit?: BookOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a BookOrder.
     */
    data: XOR<BookOrderCreateInput, BookOrderUncheckedCreateInput>
  }

  /**
   * BookOrder createMany
   */
  export type BookOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookOrders.
     */
    data: BookOrderCreateManyInput | BookOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookOrder update
   */
  export type BookOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrder
     */
    select?: BookOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrder
     */
    omit?: BookOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a BookOrder.
     */
    data: XOR<BookOrderUpdateInput, BookOrderUncheckedUpdateInput>
    /**
     * Choose, which BookOrder to update.
     */
    where: BookOrderWhereUniqueInput
  }

  /**
   * BookOrder updateMany
   */
  export type BookOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookOrders.
     */
    data: XOR<BookOrderUpdateManyMutationInput, BookOrderUncheckedUpdateManyInput>
    /**
     * Filter which BookOrders to update
     */
    where?: BookOrderWhereInput
    /**
     * Limit how many BookOrders to update.
     */
    limit?: number
  }

  /**
   * BookOrder upsert
   */
  export type BookOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrder
     */
    select?: BookOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrder
     */
    omit?: BookOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the BookOrder to update in case it exists.
     */
    where: BookOrderWhereUniqueInput
    /**
     * In case the BookOrder found by the `where` argument doesn't exist, create a new BookOrder with this data.
     */
    create: XOR<BookOrderCreateInput, BookOrderUncheckedCreateInput>
    /**
     * In case the BookOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookOrderUpdateInput, BookOrderUncheckedUpdateInput>
  }

  /**
   * BookOrder delete
   */
  export type BookOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrder
     */
    select?: BookOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrder
     */
    omit?: BookOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderInclude<ExtArgs> | null
    /**
     * Filter which BookOrder to delete.
     */
    where: BookOrderWhereUniqueInput
  }

  /**
   * BookOrder deleteMany
   */
  export type BookOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookOrders to delete
     */
    where?: BookOrderWhereInput
    /**
     * Limit how many BookOrders to delete.
     */
    limit?: number
  }

  /**
   * BookOrder.coupon
   */
  export type BookOrder$couponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCoupon
     */
    select?: BookCouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookCoupon
     */
    omit?: BookCouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookCouponInclude<ExtArgs> | null
    where?: BookCouponWhereInput
  }

  /**
   * BookOrder.items
   */
  export type BookOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrderItem
     */
    select?: BookOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrderItem
     */
    omit?: BookOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderItemInclude<ExtArgs> | null
    where?: BookOrderItemWhereInput
    orderBy?: BookOrderItemOrderByWithRelationInput | BookOrderItemOrderByWithRelationInput[]
    cursor?: BookOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookOrderItemScalarFieldEnum | BookOrderItemScalarFieldEnum[]
  }

  /**
   * BookOrder.purchases
   */
  export type BookOrder$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPurchase
     */
    select?: BookPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPurchase
     */
    omit?: BookPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPurchaseInclude<ExtArgs> | null
    where?: BookPurchaseWhereInput
    orderBy?: BookPurchaseOrderByWithRelationInput | BookPurchaseOrderByWithRelationInput[]
    cursor?: BookPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookPurchaseScalarFieldEnum | BookPurchaseScalarFieldEnum[]
  }

  /**
   * BookOrder without action
   */
  export type BookOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrder
     */
    select?: BookOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrder
     */
    omit?: BookOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderInclude<ExtArgs> | null
  }


  /**
   * Model BookOrderItem
   */

  export type AggregateBookOrderItem = {
    _count: BookOrderItemCountAggregateOutputType | null
    _avg: BookOrderItemAvgAggregateOutputType | null
    _sum: BookOrderItemSumAggregateOutputType | null
    _min: BookOrderItemMinAggregateOutputType | null
    _max: BookOrderItemMaxAggregateOutputType | null
  }

  export type BookOrderItemAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    bookId: number | null
    price: number | null
  }

  export type BookOrderItemSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    bookId: number | null
    price: number | null
  }

  export type BookOrderItemMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    bookId: number | null
    price: number | null
  }

  export type BookOrderItemMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    bookId: number | null
    price: number | null
  }

  export type BookOrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    bookId: number
    price: number
    _all: number
  }


  export type BookOrderItemAvgAggregateInputType = {
    id?: true
    orderId?: true
    bookId?: true
    price?: true
  }

  export type BookOrderItemSumAggregateInputType = {
    id?: true
    orderId?: true
    bookId?: true
    price?: true
  }

  export type BookOrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    bookId?: true
    price?: true
  }

  export type BookOrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    bookId?: true
    price?: true
  }

  export type BookOrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    bookId?: true
    price?: true
    _all?: true
  }

  export type BookOrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookOrderItem to aggregate.
     */
    where?: BookOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookOrderItems to fetch.
     */
    orderBy?: BookOrderItemOrderByWithRelationInput | BookOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookOrderItems
    **/
    _count?: true | BookOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookOrderItemMaxAggregateInputType
  }

  export type GetBookOrderItemAggregateType<T extends BookOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateBookOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookOrderItem[P]>
      : GetScalarType<T[P], AggregateBookOrderItem[P]>
  }




  export type BookOrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookOrderItemWhereInput
    orderBy?: BookOrderItemOrderByWithAggregationInput | BookOrderItemOrderByWithAggregationInput[]
    by: BookOrderItemScalarFieldEnum[] | BookOrderItemScalarFieldEnum
    having?: BookOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookOrderItemCountAggregateInputType | true
    _avg?: BookOrderItemAvgAggregateInputType
    _sum?: BookOrderItemSumAggregateInputType
    _min?: BookOrderItemMinAggregateInputType
    _max?: BookOrderItemMaxAggregateInputType
  }

  export type BookOrderItemGroupByOutputType = {
    id: number
    orderId: number
    bookId: number
    price: number
    _count: BookOrderItemCountAggregateOutputType | null
    _avg: BookOrderItemAvgAggregateOutputType | null
    _sum: BookOrderItemSumAggregateOutputType | null
    _min: BookOrderItemMinAggregateOutputType | null
    _max: BookOrderItemMaxAggregateOutputType | null
  }

  type GetBookOrderItemGroupByPayload<T extends BookOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], BookOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type BookOrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    bookId?: boolean
    price?: boolean
    order?: boolean | BookOrderDefaultArgs<ExtArgs>
    book?: boolean | BookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookOrderItem"]>



  export type BookOrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    bookId?: boolean
    price?: boolean
  }

  export type BookOrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "bookId" | "price", ExtArgs["result"]["bookOrderItem"]>
  export type BookOrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | BookOrderDefaultArgs<ExtArgs>
    book?: boolean | BookDefaultArgs<ExtArgs>
  }

  export type $BookOrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookOrderItem"
    objects: {
      order: Prisma.$BookOrderPayload<ExtArgs>
      book: Prisma.$BookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      bookId: number
      price: number
    }, ExtArgs["result"]["bookOrderItem"]>
    composites: {}
  }

  type BookOrderItemGetPayload<S extends boolean | null | undefined | BookOrderItemDefaultArgs> = $Result.GetResult<Prisma.$BookOrderItemPayload, S>

  type BookOrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookOrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookOrderItemCountAggregateInputType | true
    }

  export interface BookOrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookOrderItem'], meta: { name: 'BookOrderItem' } }
    /**
     * Find zero or one BookOrderItem that matches the filter.
     * @param {BookOrderItemFindUniqueArgs} args - Arguments to find a BookOrderItem
     * @example
     * // Get one BookOrderItem
     * const bookOrderItem = await prisma.bookOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookOrderItemFindUniqueArgs>(args: SelectSubset<T, BookOrderItemFindUniqueArgs<ExtArgs>>): Prisma__BookOrderItemClient<$Result.GetResult<Prisma.$BookOrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookOrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookOrderItemFindUniqueOrThrowArgs} args - Arguments to find a BookOrderItem
     * @example
     * // Get one BookOrderItem
     * const bookOrderItem = await prisma.bookOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookOrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, BookOrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookOrderItemClient<$Result.GetResult<Prisma.$BookOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookOrderItemFindFirstArgs} args - Arguments to find a BookOrderItem
     * @example
     * // Get one BookOrderItem
     * const bookOrderItem = await prisma.bookOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookOrderItemFindFirstArgs>(args?: SelectSubset<T, BookOrderItemFindFirstArgs<ExtArgs>>): Prisma__BookOrderItemClient<$Result.GetResult<Prisma.$BookOrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookOrderItemFindFirstOrThrowArgs} args - Arguments to find a BookOrderItem
     * @example
     * // Get one BookOrderItem
     * const bookOrderItem = await prisma.bookOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookOrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, BookOrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookOrderItemClient<$Result.GetResult<Prisma.$BookOrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookOrderItems
     * const bookOrderItems = await prisma.bookOrderItem.findMany()
     * 
     * // Get first 10 BookOrderItems
     * const bookOrderItems = await prisma.bookOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookOrderItemWithIdOnly = await prisma.bookOrderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookOrderItemFindManyArgs>(args?: SelectSubset<T, BookOrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookOrderItem.
     * @param {BookOrderItemCreateArgs} args - Arguments to create a BookOrderItem.
     * @example
     * // Create one BookOrderItem
     * const BookOrderItem = await prisma.bookOrderItem.create({
     *   data: {
     *     // ... data to create a BookOrderItem
     *   }
     * })
     * 
     */
    create<T extends BookOrderItemCreateArgs>(args: SelectSubset<T, BookOrderItemCreateArgs<ExtArgs>>): Prisma__BookOrderItemClient<$Result.GetResult<Prisma.$BookOrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookOrderItems.
     * @param {BookOrderItemCreateManyArgs} args - Arguments to create many BookOrderItems.
     * @example
     * // Create many BookOrderItems
     * const bookOrderItem = await prisma.bookOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookOrderItemCreateManyArgs>(args?: SelectSubset<T, BookOrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BookOrderItem.
     * @param {BookOrderItemDeleteArgs} args - Arguments to delete one BookOrderItem.
     * @example
     * // Delete one BookOrderItem
     * const BookOrderItem = await prisma.bookOrderItem.delete({
     *   where: {
     *     // ... filter to delete one BookOrderItem
     *   }
     * })
     * 
     */
    delete<T extends BookOrderItemDeleteArgs>(args: SelectSubset<T, BookOrderItemDeleteArgs<ExtArgs>>): Prisma__BookOrderItemClient<$Result.GetResult<Prisma.$BookOrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookOrderItem.
     * @param {BookOrderItemUpdateArgs} args - Arguments to update one BookOrderItem.
     * @example
     * // Update one BookOrderItem
     * const bookOrderItem = await prisma.bookOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookOrderItemUpdateArgs>(args: SelectSubset<T, BookOrderItemUpdateArgs<ExtArgs>>): Prisma__BookOrderItemClient<$Result.GetResult<Prisma.$BookOrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookOrderItems.
     * @param {BookOrderItemDeleteManyArgs} args - Arguments to filter BookOrderItems to delete.
     * @example
     * // Delete a few BookOrderItems
     * const { count } = await prisma.bookOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookOrderItemDeleteManyArgs>(args?: SelectSubset<T, BookOrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookOrderItems
     * const bookOrderItem = await prisma.bookOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookOrderItemUpdateManyArgs>(args: SelectSubset<T, BookOrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookOrderItem.
     * @param {BookOrderItemUpsertArgs} args - Arguments to update or create a BookOrderItem.
     * @example
     * // Update or create a BookOrderItem
     * const bookOrderItem = await prisma.bookOrderItem.upsert({
     *   create: {
     *     // ... data to create a BookOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends BookOrderItemUpsertArgs>(args: SelectSubset<T, BookOrderItemUpsertArgs<ExtArgs>>): Prisma__BookOrderItemClient<$Result.GetResult<Prisma.$BookOrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookOrderItemCountArgs} args - Arguments to filter BookOrderItems to count.
     * @example
     * // Count the number of BookOrderItems
     * const count = await prisma.bookOrderItem.count({
     *   where: {
     *     // ... the filter for the BookOrderItems we want to count
     *   }
     * })
    **/
    count<T extends BookOrderItemCountArgs>(
      args?: Subset<T, BookOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookOrderItemAggregateArgs>(args: Subset<T, BookOrderItemAggregateArgs>): Prisma.PrismaPromise<GetBookOrderItemAggregateType<T>>

    /**
     * Group by BookOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: BookOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookOrderItem model
   */
  readonly fields: BookOrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookOrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends BookOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookOrderDefaultArgs<ExtArgs>>): Prisma__BookOrderClient<$Result.GetResult<Prisma.$BookOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    book<T extends BookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookDefaultArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookOrderItem model
   */
  interface BookOrderItemFieldRefs {
    readonly id: FieldRef<"BookOrderItem", 'Int'>
    readonly orderId: FieldRef<"BookOrderItem", 'Int'>
    readonly bookId: FieldRef<"BookOrderItem", 'Int'>
    readonly price: FieldRef<"BookOrderItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * BookOrderItem findUnique
   */
  export type BookOrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrderItem
     */
    select?: BookOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrderItem
     */
    omit?: BookOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which BookOrderItem to fetch.
     */
    where: BookOrderItemWhereUniqueInput
  }

  /**
   * BookOrderItem findUniqueOrThrow
   */
  export type BookOrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrderItem
     */
    select?: BookOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrderItem
     */
    omit?: BookOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which BookOrderItem to fetch.
     */
    where: BookOrderItemWhereUniqueInput
  }

  /**
   * BookOrderItem findFirst
   */
  export type BookOrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrderItem
     */
    select?: BookOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrderItem
     */
    omit?: BookOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which BookOrderItem to fetch.
     */
    where?: BookOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookOrderItems to fetch.
     */
    orderBy?: BookOrderItemOrderByWithRelationInput | BookOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookOrderItems.
     */
    cursor?: BookOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookOrderItems.
     */
    distinct?: BookOrderItemScalarFieldEnum | BookOrderItemScalarFieldEnum[]
  }

  /**
   * BookOrderItem findFirstOrThrow
   */
  export type BookOrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrderItem
     */
    select?: BookOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrderItem
     */
    omit?: BookOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which BookOrderItem to fetch.
     */
    where?: BookOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookOrderItems to fetch.
     */
    orderBy?: BookOrderItemOrderByWithRelationInput | BookOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookOrderItems.
     */
    cursor?: BookOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookOrderItems.
     */
    distinct?: BookOrderItemScalarFieldEnum | BookOrderItemScalarFieldEnum[]
  }

  /**
   * BookOrderItem findMany
   */
  export type BookOrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrderItem
     */
    select?: BookOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrderItem
     */
    omit?: BookOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which BookOrderItems to fetch.
     */
    where?: BookOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookOrderItems to fetch.
     */
    orderBy?: BookOrderItemOrderByWithRelationInput | BookOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookOrderItems.
     */
    cursor?: BookOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookOrderItems.
     */
    skip?: number
    distinct?: BookOrderItemScalarFieldEnum | BookOrderItemScalarFieldEnum[]
  }

  /**
   * BookOrderItem create
   */
  export type BookOrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrderItem
     */
    select?: BookOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrderItem
     */
    omit?: BookOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a BookOrderItem.
     */
    data: XOR<BookOrderItemCreateInput, BookOrderItemUncheckedCreateInput>
  }

  /**
   * BookOrderItem createMany
   */
  export type BookOrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookOrderItems.
     */
    data: BookOrderItemCreateManyInput | BookOrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookOrderItem update
   */
  export type BookOrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrderItem
     */
    select?: BookOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrderItem
     */
    omit?: BookOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a BookOrderItem.
     */
    data: XOR<BookOrderItemUpdateInput, BookOrderItemUncheckedUpdateInput>
    /**
     * Choose, which BookOrderItem to update.
     */
    where: BookOrderItemWhereUniqueInput
  }

  /**
   * BookOrderItem updateMany
   */
  export type BookOrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookOrderItems.
     */
    data: XOR<BookOrderItemUpdateManyMutationInput, BookOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which BookOrderItems to update
     */
    where?: BookOrderItemWhereInput
    /**
     * Limit how many BookOrderItems to update.
     */
    limit?: number
  }

  /**
   * BookOrderItem upsert
   */
  export type BookOrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrderItem
     */
    select?: BookOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrderItem
     */
    omit?: BookOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the BookOrderItem to update in case it exists.
     */
    where: BookOrderItemWhereUniqueInput
    /**
     * In case the BookOrderItem found by the `where` argument doesn't exist, create a new BookOrderItem with this data.
     */
    create: XOR<BookOrderItemCreateInput, BookOrderItemUncheckedCreateInput>
    /**
     * In case the BookOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookOrderItemUpdateInput, BookOrderItemUncheckedUpdateInput>
  }

  /**
   * BookOrderItem delete
   */
  export type BookOrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrderItem
     */
    select?: BookOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrderItem
     */
    omit?: BookOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderItemInclude<ExtArgs> | null
    /**
     * Filter which BookOrderItem to delete.
     */
    where: BookOrderItemWhereUniqueInput
  }

  /**
   * BookOrderItem deleteMany
   */
  export type BookOrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookOrderItems to delete
     */
    where?: BookOrderItemWhereInput
    /**
     * Limit how many BookOrderItems to delete.
     */
    limit?: number
  }

  /**
   * BookOrderItem without action
   */
  export type BookOrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookOrderItem
     */
    select?: BookOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookOrderItem
     */
    omit?: BookOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookOrderItemInclude<ExtArgs> | null
  }


  /**
   * Model BookPurchase
   */

  export type AggregateBookPurchase = {
    _count: BookPurchaseCountAggregateOutputType | null
    _avg: BookPurchaseAvgAggregateOutputType | null
    _sum: BookPurchaseSumAggregateOutputType | null
    _min: BookPurchaseMinAggregateOutputType | null
    _max: BookPurchaseMaxAggregateOutputType | null
  }

  export type BookPurchaseAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    bookId: number | null
    orderId: number | null
  }

  export type BookPurchaseSumAggregateOutputType = {
    id: number | null
    userId: number | null
    bookId: number | null
    orderId: number | null
  }

  export type BookPurchaseMinAggregateOutputType = {
    id: number | null
    userId: number | null
    bookId: number | null
    orderId: number | null
    purchaseDate: Date | null
    accessGranted: boolean | null
  }

  export type BookPurchaseMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    bookId: number | null
    orderId: number | null
    purchaseDate: Date | null
    accessGranted: boolean | null
  }

  export type BookPurchaseCountAggregateOutputType = {
    id: number
    userId: number
    bookId: number
    orderId: number
    purchaseDate: number
    accessGranted: number
    _all: number
  }


  export type BookPurchaseAvgAggregateInputType = {
    id?: true
    userId?: true
    bookId?: true
    orderId?: true
  }

  export type BookPurchaseSumAggregateInputType = {
    id?: true
    userId?: true
    bookId?: true
    orderId?: true
  }

  export type BookPurchaseMinAggregateInputType = {
    id?: true
    userId?: true
    bookId?: true
    orderId?: true
    purchaseDate?: true
    accessGranted?: true
  }

  export type BookPurchaseMaxAggregateInputType = {
    id?: true
    userId?: true
    bookId?: true
    orderId?: true
    purchaseDate?: true
    accessGranted?: true
  }

  export type BookPurchaseCountAggregateInputType = {
    id?: true
    userId?: true
    bookId?: true
    orderId?: true
    purchaseDate?: true
    accessGranted?: true
    _all?: true
  }

  export type BookPurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookPurchase to aggregate.
     */
    where?: BookPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookPurchases to fetch.
     */
    orderBy?: BookPurchaseOrderByWithRelationInput | BookPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookPurchases
    **/
    _count?: true | BookPurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookPurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookPurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookPurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookPurchaseMaxAggregateInputType
  }

  export type GetBookPurchaseAggregateType<T extends BookPurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregateBookPurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookPurchase[P]>
      : GetScalarType<T[P], AggregateBookPurchase[P]>
  }




  export type BookPurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookPurchaseWhereInput
    orderBy?: BookPurchaseOrderByWithAggregationInput | BookPurchaseOrderByWithAggregationInput[]
    by: BookPurchaseScalarFieldEnum[] | BookPurchaseScalarFieldEnum
    having?: BookPurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookPurchaseCountAggregateInputType | true
    _avg?: BookPurchaseAvgAggregateInputType
    _sum?: BookPurchaseSumAggregateInputType
    _min?: BookPurchaseMinAggregateInputType
    _max?: BookPurchaseMaxAggregateInputType
  }

  export type BookPurchaseGroupByOutputType = {
    id: number
    userId: number
    bookId: number
    orderId: number
    purchaseDate: Date
    accessGranted: boolean
    _count: BookPurchaseCountAggregateOutputType | null
    _avg: BookPurchaseAvgAggregateOutputType | null
    _sum: BookPurchaseSumAggregateOutputType | null
    _min: BookPurchaseMinAggregateOutputType | null
    _max: BookPurchaseMaxAggregateOutputType | null
  }

  type GetBookPurchaseGroupByPayload<T extends BookPurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookPurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookPurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookPurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], BookPurchaseGroupByOutputType[P]>
        }
      >
    >


  export type BookPurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookId?: boolean
    orderId?: boolean
    purchaseDate?: boolean
    accessGranted?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    book?: boolean | BookDefaultArgs<ExtArgs>
    order?: boolean | BookOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookPurchase"]>



  export type BookPurchaseSelectScalar = {
    id?: boolean
    userId?: boolean
    bookId?: boolean
    orderId?: boolean
    purchaseDate?: boolean
    accessGranted?: boolean
  }

  export type BookPurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "bookId" | "orderId" | "purchaseDate" | "accessGranted", ExtArgs["result"]["bookPurchase"]>
  export type BookPurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    book?: boolean | BookDefaultArgs<ExtArgs>
    order?: boolean | BookOrderDefaultArgs<ExtArgs>
  }

  export type $BookPurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookPurchase"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      book: Prisma.$BookPayload<ExtArgs>
      order: Prisma.$BookOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      bookId: number
      orderId: number
      purchaseDate: Date
      accessGranted: boolean
    }, ExtArgs["result"]["bookPurchase"]>
    composites: {}
  }

  type BookPurchaseGetPayload<S extends boolean | null | undefined | BookPurchaseDefaultArgs> = $Result.GetResult<Prisma.$BookPurchasePayload, S>

  type BookPurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookPurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookPurchaseCountAggregateInputType | true
    }

  export interface BookPurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookPurchase'], meta: { name: 'BookPurchase' } }
    /**
     * Find zero or one BookPurchase that matches the filter.
     * @param {BookPurchaseFindUniqueArgs} args - Arguments to find a BookPurchase
     * @example
     * // Get one BookPurchase
     * const bookPurchase = await prisma.bookPurchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookPurchaseFindUniqueArgs>(args: SelectSubset<T, BookPurchaseFindUniqueArgs<ExtArgs>>): Prisma__BookPurchaseClient<$Result.GetResult<Prisma.$BookPurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookPurchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookPurchaseFindUniqueOrThrowArgs} args - Arguments to find a BookPurchase
     * @example
     * // Get one BookPurchase
     * const bookPurchase = await prisma.bookPurchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookPurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, BookPurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookPurchaseClient<$Result.GetResult<Prisma.$BookPurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookPurchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookPurchaseFindFirstArgs} args - Arguments to find a BookPurchase
     * @example
     * // Get one BookPurchase
     * const bookPurchase = await prisma.bookPurchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookPurchaseFindFirstArgs>(args?: SelectSubset<T, BookPurchaseFindFirstArgs<ExtArgs>>): Prisma__BookPurchaseClient<$Result.GetResult<Prisma.$BookPurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookPurchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookPurchaseFindFirstOrThrowArgs} args - Arguments to find a BookPurchase
     * @example
     * // Get one BookPurchase
     * const bookPurchase = await prisma.bookPurchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookPurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, BookPurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookPurchaseClient<$Result.GetResult<Prisma.$BookPurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookPurchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookPurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookPurchases
     * const bookPurchases = await prisma.bookPurchase.findMany()
     * 
     * // Get first 10 BookPurchases
     * const bookPurchases = await prisma.bookPurchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookPurchaseWithIdOnly = await prisma.bookPurchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookPurchaseFindManyArgs>(args?: SelectSubset<T, BookPurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookPurchase.
     * @param {BookPurchaseCreateArgs} args - Arguments to create a BookPurchase.
     * @example
     * // Create one BookPurchase
     * const BookPurchase = await prisma.bookPurchase.create({
     *   data: {
     *     // ... data to create a BookPurchase
     *   }
     * })
     * 
     */
    create<T extends BookPurchaseCreateArgs>(args: SelectSubset<T, BookPurchaseCreateArgs<ExtArgs>>): Prisma__BookPurchaseClient<$Result.GetResult<Prisma.$BookPurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookPurchases.
     * @param {BookPurchaseCreateManyArgs} args - Arguments to create many BookPurchases.
     * @example
     * // Create many BookPurchases
     * const bookPurchase = await prisma.bookPurchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookPurchaseCreateManyArgs>(args?: SelectSubset<T, BookPurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BookPurchase.
     * @param {BookPurchaseDeleteArgs} args - Arguments to delete one BookPurchase.
     * @example
     * // Delete one BookPurchase
     * const BookPurchase = await prisma.bookPurchase.delete({
     *   where: {
     *     // ... filter to delete one BookPurchase
     *   }
     * })
     * 
     */
    delete<T extends BookPurchaseDeleteArgs>(args: SelectSubset<T, BookPurchaseDeleteArgs<ExtArgs>>): Prisma__BookPurchaseClient<$Result.GetResult<Prisma.$BookPurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookPurchase.
     * @param {BookPurchaseUpdateArgs} args - Arguments to update one BookPurchase.
     * @example
     * // Update one BookPurchase
     * const bookPurchase = await prisma.bookPurchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookPurchaseUpdateArgs>(args: SelectSubset<T, BookPurchaseUpdateArgs<ExtArgs>>): Prisma__BookPurchaseClient<$Result.GetResult<Prisma.$BookPurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookPurchases.
     * @param {BookPurchaseDeleteManyArgs} args - Arguments to filter BookPurchases to delete.
     * @example
     * // Delete a few BookPurchases
     * const { count } = await prisma.bookPurchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookPurchaseDeleteManyArgs>(args?: SelectSubset<T, BookPurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookPurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookPurchases
     * const bookPurchase = await prisma.bookPurchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookPurchaseUpdateManyArgs>(args: SelectSubset<T, BookPurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookPurchase.
     * @param {BookPurchaseUpsertArgs} args - Arguments to update or create a BookPurchase.
     * @example
     * // Update or create a BookPurchase
     * const bookPurchase = await prisma.bookPurchase.upsert({
     *   create: {
     *     // ... data to create a BookPurchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookPurchase we want to update
     *   }
     * })
     */
    upsert<T extends BookPurchaseUpsertArgs>(args: SelectSubset<T, BookPurchaseUpsertArgs<ExtArgs>>): Prisma__BookPurchaseClient<$Result.GetResult<Prisma.$BookPurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookPurchaseCountArgs} args - Arguments to filter BookPurchases to count.
     * @example
     * // Count the number of BookPurchases
     * const count = await prisma.bookPurchase.count({
     *   where: {
     *     // ... the filter for the BookPurchases we want to count
     *   }
     * })
    **/
    count<T extends BookPurchaseCountArgs>(
      args?: Subset<T, BookPurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookPurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookPurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookPurchaseAggregateArgs>(args: Subset<T, BookPurchaseAggregateArgs>): Prisma.PrismaPromise<GetBookPurchaseAggregateType<T>>

    /**
     * Group by BookPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookPurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookPurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookPurchaseGroupByArgs['orderBy'] }
        : { orderBy?: BookPurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookPurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookPurchase model
   */
  readonly fields: BookPurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookPurchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookPurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    book<T extends BookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookDefaultArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends BookOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookOrderDefaultArgs<ExtArgs>>): Prisma__BookOrderClient<$Result.GetResult<Prisma.$BookOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookPurchase model
   */
  interface BookPurchaseFieldRefs {
    readonly id: FieldRef<"BookPurchase", 'Int'>
    readonly userId: FieldRef<"BookPurchase", 'Int'>
    readonly bookId: FieldRef<"BookPurchase", 'Int'>
    readonly orderId: FieldRef<"BookPurchase", 'Int'>
    readonly purchaseDate: FieldRef<"BookPurchase", 'DateTime'>
    readonly accessGranted: FieldRef<"BookPurchase", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BookPurchase findUnique
   */
  export type BookPurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPurchase
     */
    select?: BookPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPurchase
     */
    omit?: BookPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which BookPurchase to fetch.
     */
    where: BookPurchaseWhereUniqueInput
  }

  /**
   * BookPurchase findUniqueOrThrow
   */
  export type BookPurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPurchase
     */
    select?: BookPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPurchase
     */
    omit?: BookPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which BookPurchase to fetch.
     */
    where: BookPurchaseWhereUniqueInput
  }

  /**
   * BookPurchase findFirst
   */
  export type BookPurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPurchase
     */
    select?: BookPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPurchase
     */
    omit?: BookPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which BookPurchase to fetch.
     */
    where?: BookPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookPurchases to fetch.
     */
    orderBy?: BookPurchaseOrderByWithRelationInput | BookPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookPurchases.
     */
    cursor?: BookPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookPurchases.
     */
    distinct?: BookPurchaseScalarFieldEnum | BookPurchaseScalarFieldEnum[]
  }

  /**
   * BookPurchase findFirstOrThrow
   */
  export type BookPurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPurchase
     */
    select?: BookPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPurchase
     */
    omit?: BookPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which BookPurchase to fetch.
     */
    where?: BookPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookPurchases to fetch.
     */
    orderBy?: BookPurchaseOrderByWithRelationInput | BookPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookPurchases.
     */
    cursor?: BookPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookPurchases.
     */
    distinct?: BookPurchaseScalarFieldEnum | BookPurchaseScalarFieldEnum[]
  }

  /**
   * BookPurchase findMany
   */
  export type BookPurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPurchase
     */
    select?: BookPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPurchase
     */
    omit?: BookPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which BookPurchases to fetch.
     */
    where?: BookPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookPurchases to fetch.
     */
    orderBy?: BookPurchaseOrderByWithRelationInput | BookPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookPurchases.
     */
    cursor?: BookPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookPurchases.
     */
    skip?: number
    distinct?: BookPurchaseScalarFieldEnum | BookPurchaseScalarFieldEnum[]
  }

  /**
   * BookPurchase create
   */
  export type BookPurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPurchase
     */
    select?: BookPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPurchase
     */
    omit?: BookPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a BookPurchase.
     */
    data: XOR<BookPurchaseCreateInput, BookPurchaseUncheckedCreateInput>
  }

  /**
   * BookPurchase createMany
   */
  export type BookPurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookPurchases.
     */
    data: BookPurchaseCreateManyInput | BookPurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookPurchase update
   */
  export type BookPurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPurchase
     */
    select?: BookPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPurchase
     */
    omit?: BookPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a BookPurchase.
     */
    data: XOR<BookPurchaseUpdateInput, BookPurchaseUncheckedUpdateInput>
    /**
     * Choose, which BookPurchase to update.
     */
    where: BookPurchaseWhereUniqueInput
  }

  /**
   * BookPurchase updateMany
   */
  export type BookPurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookPurchases.
     */
    data: XOR<BookPurchaseUpdateManyMutationInput, BookPurchaseUncheckedUpdateManyInput>
    /**
     * Filter which BookPurchases to update
     */
    where?: BookPurchaseWhereInput
    /**
     * Limit how many BookPurchases to update.
     */
    limit?: number
  }

  /**
   * BookPurchase upsert
   */
  export type BookPurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPurchase
     */
    select?: BookPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPurchase
     */
    omit?: BookPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the BookPurchase to update in case it exists.
     */
    where: BookPurchaseWhereUniqueInput
    /**
     * In case the BookPurchase found by the `where` argument doesn't exist, create a new BookPurchase with this data.
     */
    create: XOR<BookPurchaseCreateInput, BookPurchaseUncheckedCreateInput>
    /**
     * In case the BookPurchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookPurchaseUpdateInput, BookPurchaseUncheckedUpdateInput>
  }

  /**
   * BookPurchase delete
   */
  export type BookPurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPurchase
     */
    select?: BookPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPurchase
     */
    omit?: BookPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPurchaseInclude<ExtArgs> | null
    /**
     * Filter which BookPurchase to delete.
     */
    where: BookPurchaseWhereUniqueInput
  }

  /**
   * BookPurchase deleteMany
   */
  export type BookPurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookPurchases to delete
     */
    where?: BookPurchaseWhereInput
    /**
     * Limit how many BookPurchases to delete.
     */
    limit?: number
  }

  /**
   * BookPurchase without action
   */
  export type BookPurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookPurchase
     */
    select?: BookPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookPurchase
     */
    omit?: BookPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookPurchaseInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    referenceId: string | null
    provider: string | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    referenceId: string | null
    provider: string | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    referenceId: number
    provider: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    referenceId?: true
    provider?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    referenceId?: true
    provider?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    referenceId?: true
    provider?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    userId: number
    referenceId: string
    provider: string
    amount: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    referenceId?: boolean
    provider?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>



  export type PaymentSelectScalar = {
    id?: boolean
    userId?: boolean
    referenceId?: boolean
    provider?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "referenceId" | "provider" | "amount" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      referenceId: string
      provider: string
      amount: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly userId: FieldRef<"Payment", 'Int'>
    readonly referenceId: FieldRef<"Payment", 'String'>
    readonly provider: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model News
   */

  export type AggregateNews = {
    _count: NewsCountAggregateOutputType | null
    _avg: NewsAvgAggregateOutputType | null
    _sum: NewsSumAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  export type NewsAvgAggregateOutputType = {
    id: number | null
    views: number | null
    authorId: number | null
  }

  export type NewsSumAggregateOutputType = {
    id: number | null
    views: number | null
    authorId: number | null
  }

  export type NewsMinAggregateOutputType = {
    id: number | null
    title: string | null
    titleEn: string | null
    slug: string | null
    excerpt: string | null
    image: string | null
    category: string | null
    date: string | null
    readTime: string | null
    views: number | null
    featured: boolean | null
    author: string | null
    authorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    titleEn: string | null
    slug: string | null
    excerpt: string | null
    image: string | null
    category: string | null
    date: string | null
    readTime: string | null
    views: number | null
    featured: boolean | null
    author: string | null
    authorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsCountAggregateOutputType = {
    id: number
    title: number
    titleEn: number
    slug: number
    excerpt: number
    image: number
    category: number
    date: number
    readTime: number
    views: number
    featured: number
    content: number
    tags: number
    author: number
    authorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NewsAvgAggregateInputType = {
    id?: true
    views?: true
    authorId?: true
  }

  export type NewsSumAggregateInputType = {
    id?: true
    views?: true
    authorId?: true
  }

  export type NewsMinAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    slug?: true
    excerpt?: true
    image?: true
    category?: true
    date?: true
    readTime?: true
    views?: true
    featured?: true
    author?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsMaxAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    slug?: true
    excerpt?: true
    image?: true
    category?: true
    date?: true
    readTime?: true
    views?: true
    featured?: true
    author?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsCountAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    slug?: true
    excerpt?: true
    image?: true
    category?: true
    date?: true
    readTime?: true
    views?: true
    featured?: true
    content?: true
    tags?: true
    author?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to aggregate.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned News
    **/
    _count?: true | NewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsMaxAggregateInputType
  }

  export type GetNewsAggregateType<T extends NewsAggregateArgs> = {
        [P in keyof T & keyof AggregateNews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews[P]>
      : GetScalarType<T[P], AggregateNews[P]>
  }




  export type NewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsWhereInput
    orderBy?: NewsOrderByWithAggregationInput | NewsOrderByWithAggregationInput[]
    by: NewsScalarFieldEnum[] | NewsScalarFieldEnum
    having?: NewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsCountAggregateInputType | true
    _avg?: NewsAvgAggregateInputType
    _sum?: NewsSumAggregateInputType
    _min?: NewsMinAggregateInputType
    _max?: NewsMaxAggregateInputType
  }

  export type NewsGroupByOutputType = {
    id: number
    title: string
    titleEn: string
    slug: string
    excerpt: string
    image: string
    category: string
    date: string
    readTime: string
    views: number
    featured: boolean
    content: JsonValue
    tags: JsonValue
    author: string
    authorId: number | null
    createdAt: Date
    updatedAt: Date
    _count: NewsCountAggregateOutputType | null
    _avg: NewsAvgAggregateOutputType | null
    _sum: NewsSumAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  type GetNewsGroupByPayload<T extends NewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsGroupByOutputType[P]>
            : GetScalarType<T[P], NewsGroupByOutputType[P]>
        }
      >
    >


  export type NewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    titleEn?: boolean
    slug?: boolean
    excerpt?: boolean
    image?: boolean
    category?: boolean
    date?: boolean
    readTime?: boolean
    views?: boolean
    featured?: boolean
    content?: boolean
    tags?: boolean
    author?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["news"]>



  export type NewsSelectScalar = {
    id?: boolean
    title?: boolean
    titleEn?: boolean
    slug?: boolean
    excerpt?: boolean
    image?: boolean
    category?: boolean
    date?: boolean
    readTime?: boolean
    views?: boolean
    featured?: boolean
    content?: boolean
    tags?: boolean
    author?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "titleEn" | "slug" | "excerpt" | "image" | "category" | "date" | "readTime" | "views" | "featured" | "content" | "tags" | "author" | "authorId" | "createdAt" | "updatedAt", ExtArgs["result"]["news"]>

  export type $NewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "News"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      titleEn: string
      slug: string
      excerpt: string
      image: string
      category: string
      date: string
      readTime: string
      views: number
      featured: boolean
      content: Prisma.JsonValue
      tags: Prisma.JsonValue
      author: string
      authorId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["news"]>
    composites: {}
  }

  type NewsGetPayload<S extends boolean | null | undefined | NewsDefaultArgs> = $Result.GetResult<Prisma.$NewsPayload, S>

  type NewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsCountAggregateInputType | true
    }

  export interface NewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['News'], meta: { name: 'News' } }
    /**
     * Find zero or one News that matches the filter.
     * @param {NewsFindUniqueArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsFindUniqueArgs>(args: SelectSubset<T, NewsFindUniqueArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one News that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsFindUniqueOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsFindFirstArgs>(args?: SelectSubset<T, NewsFindFirstArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first News that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News
     * const news = await prisma.news.findMany()
     * 
     * // Get first 10 News
     * const news = await prisma.news.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsWithIdOnly = await prisma.news.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsFindManyArgs>(args?: SelectSubset<T, NewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a News.
     * @param {NewsCreateArgs} args - Arguments to create a News.
     * @example
     * // Create one News
     * const News = await prisma.news.create({
     *   data: {
     *     // ... data to create a News
     *   }
     * })
     * 
     */
    create<T extends NewsCreateArgs>(args: SelectSubset<T, NewsCreateArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many News.
     * @param {NewsCreateManyArgs} args - Arguments to create many News.
     * @example
     * // Create many News
     * const news = await prisma.news.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsCreateManyArgs>(args?: SelectSubset<T, NewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a News.
     * @param {NewsDeleteArgs} args - Arguments to delete one News.
     * @example
     * // Delete one News
     * const News = await prisma.news.delete({
     *   where: {
     *     // ... filter to delete one News
     *   }
     * })
     * 
     */
    delete<T extends NewsDeleteArgs>(args: SelectSubset<T, NewsDeleteArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one News.
     * @param {NewsUpdateArgs} args - Arguments to update one News.
     * @example
     * // Update one News
     * const news = await prisma.news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsUpdateArgs>(args: SelectSubset<T, NewsUpdateArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more News.
     * @param {NewsDeleteManyArgs} args - Arguments to filter News to delete.
     * @example
     * // Delete a few News
     * const { count } = await prisma.news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsDeleteManyArgs>(args?: SelectSubset<T, NewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News
     * const news = await prisma.news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsUpdateManyArgs>(args: SelectSubset<T, NewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one News.
     * @param {NewsUpsertArgs} args - Arguments to update or create a News.
     * @example
     * // Update or create a News
     * const news = await prisma.news.upsert({
     *   create: {
     *     // ... data to create a News
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News we want to update
     *   }
     * })
     */
    upsert<T extends NewsUpsertArgs>(args: SelectSubset<T, NewsUpsertArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsCountArgs} args - Arguments to filter News to count.
     * @example
     * // Count the number of News
     * const count = await prisma.news.count({
     *   where: {
     *     // ... the filter for the News we want to count
     *   }
     * })
    **/
    count<T extends NewsCountArgs>(
      args?: Subset<T, NewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsAggregateArgs>(args: Subset<T, NewsAggregateArgs>): Prisma.PrismaPromise<GetNewsAggregateType<T>>

    /**
     * Group by News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsGroupByArgs['orderBy'] }
        : { orderBy?: NewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the News model
   */
  readonly fields: NewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for News.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the News model
   */
  interface NewsFieldRefs {
    readonly id: FieldRef<"News", 'Int'>
    readonly title: FieldRef<"News", 'String'>
    readonly titleEn: FieldRef<"News", 'String'>
    readonly slug: FieldRef<"News", 'String'>
    readonly excerpt: FieldRef<"News", 'String'>
    readonly image: FieldRef<"News", 'String'>
    readonly category: FieldRef<"News", 'String'>
    readonly date: FieldRef<"News", 'String'>
    readonly readTime: FieldRef<"News", 'String'>
    readonly views: FieldRef<"News", 'Int'>
    readonly featured: FieldRef<"News", 'Boolean'>
    readonly content: FieldRef<"News", 'Json'>
    readonly tags: FieldRef<"News", 'Json'>
    readonly author: FieldRef<"News", 'String'>
    readonly authorId: FieldRef<"News", 'Int'>
    readonly createdAt: FieldRef<"News", 'DateTime'>
    readonly updatedAt: FieldRef<"News", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * News findUnique
   */
  export type NewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News findUniqueOrThrow
   */
  export type NewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News findFirst
   */
  export type NewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News findFirstOrThrow
   */
  export type NewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News findMany
   */
  export type NewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News create
   */
  export type NewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The data needed to create a News.
     */
    data: XOR<NewsCreateInput, NewsUncheckedCreateInput>
  }

  /**
   * News createMany
   */
  export type NewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many News.
     */
    data: NewsCreateManyInput | NewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * News update
   */
  export type NewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The data needed to update a News.
     */
    data: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
    /**
     * Choose, which News to update.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News updateMany
   */
  export type NewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update News.
     */
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyInput>
    /**
     * Filter which News to update
     */
    where?: NewsWhereInput
    /**
     * Limit how many News to update.
     */
    limit?: number
  }

  /**
   * News upsert
   */
  export type NewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The filter to search for the News to update in case it exists.
     */
    where: NewsWhereUniqueInput
    /**
     * In case the News found by the `where` argument doesn't exist, create a new News with this data.
     */
    create: XOR<NewsCreateInput, NewsUncheckedCreateInput>
    /**
     * In case the News was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
  }

  /**
   * News delete
   */
  export type NewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter which News to delete.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News deleteMany
   */
  export type NewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to delete
     */
    where?: NewsWhereInput
    /**
     * Limit how many News to delete.
     */
    limit?: number
  }

  /**
   * News without action
   */
  export type NewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
  }


  /**
   * Model GopalPariwar
   */

  export type AggregateGopalPariwar = {
    _count: GopalPariwarCountAggregateOutputType | null
    _avg: GopalPariwarAvgAggregateOutputType | null
    _sum: GopalPariwarSumAggregateOutputType | null
    _min: GopalPariwarMinAggregateOutputType | null
    _max: GopalPariwarMaxAggregateOutputType | null
  }

  export type GopalPariwarAvgAggregateOutputType = {
    id: number | null
  }

  export type GopalPariwarSumAggregateOutputType = {
    id: number | null
  }

  export type GopalPariwarMinAggregateOutputType = {
    id: number | null
    heroImage: string | null
    heroTitle: string | null
    heroSubtitle: string | null
    spiritualEducation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GopalPariwarMaxAggregateOutputType = {
    id: number | null
    heroImage: string | null
    heroTitle: string | null
    heroSubtitle: string | null
    spiritualEducation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GopalPariwarCountAggregateOutputType = {
    id: number
    heroImage: number
    heroTitle: number
    heroSubtitle: number
    personalInfo: number
    spiritualEducation: number
    lifeJourney: number
    responsibilities: number
    pledges: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GopalPariwarAvgAggregateInputType = {
    id?: true
  }

  export type GopalPariwarSumAggregateInputType = {
    id?: true
  }

  export type GopalPariwarMinAggregateInputType = {
    id?: true
    heroImage?: true
    heroTitle?: true
    heroSubtitle?: true
    spiritualEducation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GopalPariwarMaxAggregateInputType = {
    id?: true
    heroImage?: true
    heroTitle?: true
    heroSubtitle?: true
    spiritualEducation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GopalPariwarCountAggregateInputType = {
    id?: true
    heroImage?: true
    heroTitle?: true
    heroSubtitle?: true
    personalInfo?: true
    spiritualEducation?: true
    lifeJourney?: true
    responsibilities?: true
    pledges?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GopalPariwarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GopalPariwar to aggregate.
     */
    where?: GopalPariwarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GopalPariwars to fetch.
     */
    orderBy?: GopalPariwarOrderByWithRelationInput | GopalPariwarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GopalPariwarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GopalPariwars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GopalPariwars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GopalPariwars
    **/
    _count?: true | GopalPariwarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GopalPariwarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GopalPariwarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GopalPariwarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GopalPariwarMaxAggregateInputType
  }

  export type GetGopalPariwarAggregateType<T extends GopalPariwarAggregateArgs> = {
        [P in keyof T & keyof AggregateGopalPariwar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGopalPariwar[P]>
      : GetScalarType<T[P], AggregateGopalPariwar[P]>
  }




  export type GopalPariwarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GopalPariwarWhereInput
    orderBy?: GopalPariwarOrderByWithAggregationInput | GopalPariwarOrderByWithAggregationInput[]
    by: GopalPariwarScalarFieldEnum[] | GopalPariwarScalarFieldEnum
    having?: GopalPariwarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GopalPariwarCountAggregateInputType | true
    _avg?: GopalPariwarAvgAggregateInputType
    _sum?: GopalPariwarSumAggregateInputType
    _min?: GopalPariwarMinAggregateInputType
    _max?: GopalPariwarMaxAggregateInputType
  }

  export type GopalPariwarGroupByOutputType = {
    id: number
    heroImage: string
    heroTitle: string
    heroSubtitle: string
    personalInfo: JsonValue
    spiritualEducation: string | null
    lifeJourney: JsonValue
    responsibilities: JsonValue
    pledges: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: GopalPariwarCountAggregateOutputType | null
    _avg: GopalPariwarAvgAggregateOutputType | null
    _sum: GopalPariwarSumAggregateOutputType | null
    _min: GopalPariwarMinAggregateOutputType | null
    _max: GopalPariwarMaxAggregateOutputType | null
  }

  type GetGopalPariwarGroupByPayload<T extends GopalPariwarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GopalPariwarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GopalPariwarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GopalPariwarGroupByOutputType[P]>
            : GetScalarType<T[P], GopalPariwarGroupByOutputType[P]>
        }
      >
    >


  export type GopalPariwarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heroImage?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    personalInfo?: boolean
    spiritualEducation?: boolean
    lifeJourney?: boolean
    responsibilities?: boolean
    pledges?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gopalPariwar"]>



  export type GopalPariwarSelectScalar = {
    id?: boolean
    heroImage?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    personalInfo?: boolean
    spiritualEducation?: boolean
    lifeJourney?: boolean
    responsibilities?: boolean
    pledges?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GopalPariwarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "heroImage" | "heroTitle" | "heroSubtitle" | "personalInfo" | "spiritualEducation" | "lifeJourney" | "responsibilities" | "pledges" | "createdAt" | "updatedAt", ExtArgs["result"]["gopalPariwar"]>

  export type $GopalPariwarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GopalPariwar"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      heroImage: string
      heroTitle: string
      heroSubtitle: string
      personalInfo: Prisma.JsonValue
      spiritualEducation: string | null
      lifeJourney: Prisma.JsonValue
      responsibilities: Prisma.JsonValue
      pledges: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gopalPariwar"]>
    composites: {}
  }

  type GopalPariwarGetPayload<S extends boolean | null | undefined | GopalPariwarDefaultArgs> = $Result.GetResult<Prisma.$GopalPariwarPayload, S>

  type GopalPariwarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GopalPariwarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GopalPariwarCountAggregateInputType | true
    }

  export interface GopalPariwarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GopalPariwar'], meta: { name: 'GopalPariwar' } }
    /**
     * Find zero or one GopalPariwar that matches the filter.
     * @param {GopalPariwarFindUniqueArgs} args - Arguments to find a GopalPariwar
     * @example
     * // Get one GopalPariwar
     * const gopalPariwar = await prisma.gopalPariwar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GopalPariwarFindUniqueArgs>(args: SelectSubset<T, GopalPariwarFindUniqueArgs<ExtArgs>>): Prisma__GopalPariwarClient<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GopalPariwar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GopalPariwarFindUniqueOrThrowArgs} args - Arguments to find a GopalPariwar
     * @example
     * // Get one GopalPariwar
     * const gopalPariwar = await prisma.gopalPariwar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GopalPariwarFindUniqueOrThrowArgs>(args: SelectSubset<T, GopalPariwarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GopalPariwarClient<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GopalPariwar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GopalPariwarFindFirstArgs} args - Arguments to find a GopalPariwar
     * @example
     * // Get one GopalPariwar
     * const gopalPariwar = await prisma.gopalPariwar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GopalPariwarFindFirstArgs>(args?: SelectSubset<T, GopalPariwarFindFirstArgs<ExtArgs>>): Prisma__GopalPariwarClient<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GopalPariwar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GopalPariwarFindFirstOrThrowArgs} args - Arguments to find a GopalPariwar
     * @example
     * // Get one GopalPariwar
     * const gopalPariwar = await prisma.gopalPariwar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GopalPariwarFindFirstOrThrowArgs>(args?: SelectSubset<T, GopalPariwarFindFirstOrThrowArgs<ExtArgs>>): Prisma__GopalPariwarClient<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GopalPariwars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GopalPariwarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GopalPariwars
     * const gopalPariwars = await prisma.gopalPariwar.findMany()
     * 
     * // Get first 10 GopalPariwars
     * const gopalPariwars = await prisma.gopalPariwar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gopalPariwarWithIdOnly = await prisma.gopalPariwar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GopalPariwarFindManyArgs>(args?: SelectSubset<T, GopalPariwarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GopalPariwar.
     * @param {GopalPariwarCreateArgs} args - Arguments to create a GopalPariwar.
     * @example
     * // Create one GopalPariwar
     * const GopalPariwar = await prisma.gopalPariwar.create({
     *   data: {
     *     // ... data to create a GopalPariwar
     *   }
     * })
     * 
     */
    create<T extends GopalPariwarCreateArgs>(args: SelectSubset<T, GopalPariwarCreateArgs<ExtArgs>>): Prisma__GopalPariwarClient<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GopalPariwars.
     * @param {GopalPariwarCreateManyArgs} args - Arguments to create many GopalPariwars.
     * @example
     * // Create many GopalPariwars
     * const gopalPariwar = await prisma.gopalPariwar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GopalPariwarCreateManyArgs>(args?: SelectSubset<T, GopalPariwarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GopalPariwar.
     * @param {GopalPariwarDeleteArgs} args - Arguments to delete one GopalPariwar.
     * @example
     * // Delete one GopalPariwar
     * const GopalPariwar = await prisma.gopalPariwar.delete({
     *   where: {
     *     // ... filter to delete one GopalPariwar
     *   }
     * })
     * 
     */
    delete<T extends GopalPariwarDeleteArgs>(args: SelectSubset<T, GopalPariwarDeleteArgs<ExtArgs>>): Prisma__GopalPariwarClient<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GopalPariwar.
     * @param {GopalPariwarUpdateArgs} args - Arguments to update one GopalPariwar.
     * @example
     * // Update one GopalPariwar
     * const gopalPariwar = await prisma.gopalPariwar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GopalPariwarUpdateArgs>(args: SelectSubset<T, GopalPariwarUpdateArgs<ExtArgs>>): Prisma__GopalPariwarClient<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GopalPariwars.
     * @param {GopalPariwarDeleteManyArgs} args - Arguments to filter GopalPariwars to delete.
     * @example
     * // Delete a few GopalPariwars
     * const { count } = await prisma.gopalPariwar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GopalPariwarDeleteManyArgs>(args?: SelectSubset<T, GopalPariwarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GopalPariwars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GopalPariwarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GopalPariwars
     * const gopalPariwar = await prisma.gopalPariwar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GopalPariwarUpdateManyArgs>(args: SelectSubset<T, GopalPariwarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GopalPariwar.
     * @param {GopalPariwarUpsertArgs} args - Arguments to update or create a GopalPariwar.
     * @example
     * // Update or create a GopalPariwar
     * const gopalPariwar = await prisma.gopalPariwar.upsert({
     *   create: {
     *     // ... data to create a GopalPariwar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GopalPariwar we want to update
     *   }
     * })
     */
    upsert<T extends GopalPariwarUpsertArgs>(args: SelectSubset<T, GopalPariwarUpsertArgs<ExtArgs>>): Prisma__GopalPariwarClient<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GopalPariwars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GopalPariwarCountArgs} args - Arguments to filter GopalPariwars to count.
     * @example
     * // Count the number of GopalPariwars
     * const count = await prisma.gopalPariwar.count({
     *   where: {
     *     // ... the filter for the GopalPariwars we want to count
     *   }
     * })
    **/
    count<T extends GopalPariwarCountArgs>(
      args?: Subset<T, GopalPariwarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GopalPariwarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GopalPariwar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GopalPariwarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GopalPariwarAggregateArgs>(args: Subset<T, GopalPariwarAggregateArgs>): Prisma.PrismaPromise<GetGopalPariwarAggregateType<T>>

    /**
     * Group by GopalPariwar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GopalPariwarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GopalPariwarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GopalPariwarGroupByArgs['orderBy'] }
        : { orderBy?: GopalPariwarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GopalPariwarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGopalPariwarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GopalPariwar model
   */
  readonly fields: GopalPariwarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GopalPariwar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GopalPariwarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GopalPariwar model
   */
  interface GopalPariwarFieldRefs {
    readonly id: FieldRef<"GopalPariwar", 'Int'>
    readonly heroImage: FieldRef<"GopalPariwar", 'String'>
    readonly heroTitle: FieldRef<"GopalPariwar", 'String'>
    readonly heroSubtitle: FieldRef<"GopalPariwar", 'String'>
    readonly personalInfo: FieldRef<"GopalPariwar", 'Json'>
    readonly spiritualEducation: FieldRef<"GopalPariwar", 'String'>
    readonly lifeJourney: FieldRef<"GopalPariwar", 'Json'>
    readonly responsibilities: FieldRef<"GopalPariwar", 'Json'>
    readonly pledges: FieldRef<"GopalPariwar", 'Json'>
    readonly createdAt: FieldRef<"GopalPariwar", 'DateTime'>
    readonly updatedAt: FieldRef<"GopalPariwar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GopalPariwar findUnique
   */
  export type GopalPariwarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * Filter, which GopalPariwar to fetch.
     */
    where: GopalPariwarWhereUniqueInput
  }

  /**
   * GopalPariwar findUniqueOrThrow
   */
  export type GopalPariwarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * Filter, which GopalPariwar to fetch.
     */
    where: GopalPariwarWhereUniqueInput
  }

  /**
   * GopalPariwar findFirst
   */
  export type GopalPariwarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * Filter, which GopalPariwar to fetch.
     */
    where?: GopalPariwarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GopalPariwars to fetch.
     */
    orderBy?: GopalPariwarOrderByWithRelationInput | GopalPariwarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GopalPariwars.
     */
    cursor?: GopalPariwarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GopalPariwars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GopalPariwars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GopalPariwars.
     */
    distinct?: GopalPariwarScalarFieldEnum | GopalPariwarScalarFieldEnum[]
  }

  /**
   * GopalPariwar findFirstOrThrow
   */
  export type GopalPariwarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * Filter, which GopalPariwar to fetch.
     */
    where?: GopalPariwarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GopalPariwars to fetch.
     */
    orderBy?: GopalPariwarOrderByWithRelationInput | GopalPariwarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GopalPariwars.
     */
    cursor?: GopalPariwarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GopalPariwars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GopalPariwars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GopalPariwars.
     */
    distinct?: GopalPariwarScalarFieldEnum | GopalPariwarScalarFieldEnum[]
  }

  /**
   * GopalPariwar findMany
   */
  export type GopalPariwarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * Filter, which GopalPariwars to fetch.
     */
    where?: GopalPariwarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GopalPariwars to fetch.
     */
    orderBy?: GopalPariwarOrderByWithRelationInput | GopalPariwarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GopalPariwars.
     */
    cursor?: GopalPariwarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GopalPariwars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GopalPariwars.
     */
    skip?: number
    distinct?: GopalPariwarScalarFieldEnum | GopalPariwarScalarFieldEnum[]
  }

  /**
   * GopalPariwar create
   */
  export type GopalPariwarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * The data needed to create a GopalPariwar.
     */
    data: XOR<GopalPariwarCreateInput, GopalPariwarUncheckedCreateInput>
  }

  /**
   * GopalPariwar createMany
   */
  export type GopalPariwarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GopalPariwars.
     */
    data: GopalPariwarCreateManyInput | GopalPariwarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GopalPariwar update
   */
  export type GopalPariwarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * The data needed to update a GopalPariwar.
     */
    data: XOR<GopalPariwarUpdateInput, GopalPariwarUncheckedUpdateInput>
    /**
     * Choose, which GopalPariwar to update.
     */
    where: GopalPariwarWhereUniqueInput
  }

  /**
   * GopalPariwar updateMany
   */
  export type GopalPariwarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GopalPariwars.
     */
    data: XOR<GopalPariwarUpdateManyMutationInput, GopalPariwarUncheckedUpdateManyInput>
    /**
     * Filter which GopalPariwars to update
     */
    where?: GopalPariwarWhereInput
    /**
     * Limit how many GopalPariwars to update.
     */
    limit?: number
  }

  /**
   * GopalPariwar upsert
   */
  export type GopalPariwarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * The filter to search for the GopalPariwar to update in case it exists.
     */
    where: GopalPariwarWhereUniqueInput
    /**
     * In case the GopalPariwar found by the `where` argument doesn't exist, create a new GopalPariwar with this data.
     */
    create: XOR<GopalPariwarCreateInput, GopalPariwarUncheckedCreateInput>
    /**
     * In case the GopalPariwar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GopalPariwarUpdateInput, GopalPariwarUncheckedUpdateInput>
  }

  /**
   * GopalPariwar delete
   */
  export type GopalPariwarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * Filter which GopalPariwar to delete.
     */
    where: GopalPariwarWhereUniqueInput
  }

  /**
   * GopalPariwar deleteMany
   */
  export type GopalPariwarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GopalPariwars to delete
     */
    where?: GopalPariwarWhereInput
    /**
     * Limit how many GopalPariwars to delete.
     */
    limit?: number
  }

  /**
   * GopalPariwar without action
   */
  export type GopalPariwarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
  }


  /**
   * Model Gaushala
   */

  export type AggregateGaushala = {
    _count: GaushalaCountAggregateOutputType | null
    _avg: GaushalaAvgAggregateOutputType | null
    _sum: GaushalaSumAggregateOutputType | null
    _min: GaushalaMinAggregateOutputType | null
    _max: GaushalaMaxAggregateOutputType | null
  }

  export type GaushalaAvgAggregateOutputType = {
    id: number | null
    establishmentYear: number | null
    totalCows: number | null
    capacity: number | null
  }

  export type GaushalaSumAggregateOutputType = {
    id: number | null
    establishmentYear: number | null
    totalCows: number | null
    capacity: number | null
  }

  export type GaushalaMinAggregateOutputType = {
    id: number | null
    name: string | null
    photo: string | null
    address: string | null
    establishmentYear: number | null
    contactDetails: string | null
    totalCows: number | null
    capacity: number | null
    description: string | null
    city: string | null
    state: string | null
    pincode: string | null
    contactPerson: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaushalaMaxAggregateOutputType = {
    id: number | null
    name: string | null
    photo: string | null
    address: string | null
    establishmentYear: number | null
    contactDetails: string | null
    totalCows: number | null
    capacity: number | null
    description: string | null
    city: string | null
    state: string | null
    pincode: string | null
    contactPerson: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaushalaCountAggregateOutputType = {
    id: number
    name: number
    photo: number
    address: number
    establishmentYear: number
    contactDetails: number
    totalCows: number
    capacity: number
    description: number
    city: number
    state: number
    pincode: number
    contactPerson: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GaushalaAvgAggregateInputType = {
    id?: true
    establishmentYear?: true
    totalCows?: true
    capacity?: true
  }

  export type GaushalaSumAggregateInputType = {
    id?: true
    establishmentYear?: true
    totalCows?: true
    capacity?: true
  }

  export type GaushalaMinAggregateInputType = {
    id?: true
    name?: true
    photo?: true
    address?: true
    establishmentYear?: true
    contactDetails?: true
    totalCows?: true
    capacity?: true
    description?: true
    city?: true
    state?: true
    pincode?: true
    contactPerson?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaushalaMaxAggregateInputType = {
    id?: true
    name?: true
    photo?: true
    address?: true
    establishmentYear?: true
    contactDetails?: true
    totalCows?: true
    capacity?: true
    description?: true
    city?: true
    state?: true
    pincode?: true
    contactPerson?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaushalaCountAggregateInputType = {
    id?: true
    name?: true
    photo?: true
    address?: true
    establishmentYear?: true
    contactDetails?: true
    totalCows?: true
    capacity?: true
    description?: true
    city?: true
    state?: true
    pincode?: true
    contactPerson?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GaushalaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gaushala to aggregate.
     */
    where?: GaushalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gaushalas to fetch.
     */
    orderBy?: GaushalaOrderByWithRelationInput | GaushalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GaushalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gaushalas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gaushalas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gaushalas
    **/
    _count?: true | GaushalaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GaushalaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GaushalaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GaushalaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GaushalaMaxAggregateInputType
  }

  export type GetGaushalaAggregateType<T extends GaushalaAggregateArgs> = {
        [P in keyof T & keyof AggregateGaushala]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGaushala[P]>
      : GetScalarType<T[P], AggregateGaushala[P]>
  }




  export type GaushalaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaushalaWhereInput
    orderBy?: GaushalaOrderByWithAggregationInput | GaushalaOrderByWithAggregationInput[]
    by: GaushalaScalarFieldEnum[] | GaushalaScalarFieldEnum
    having?: GaushalaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GaushalaCountAggregateInputType | true
    _avg?: GaushalaAvgAggregateInputType
    _sum?: GaushalaSumAggregateInputType
    _min?: GaushalaMinAggregateInputType
    _max?: GaushalaMaxAggregateInputType
  }

  export type GaushalaGroupByOutputType = {
    id: number
    name: string
    photo: string | null
    address: string
    establishmentYear: number
    contactDetails: string
    totalCows: number
    capacity: number
    description: string | null
    city: string
    state: string
    pincode: string
    contactPerson: string
    createdAt: Date
    updatedAt: Date
    _count: GaushalaCountAggregateOutputType | null
    _avg: GaushalaAvgAggregateOutputType | null
    _sum: GaushalaSumAggregateOutputType | null
    _min: GaushalaMinAggregateOutputType | null
    _max: GaushalaMaxAggregateOutputType | null
  }

  type GetGaushalaGroupByPayload<T extends GaushalaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GaushalaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GaushalaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GaushalaGroupByOutputType[P]>
            : GetScalarType<T[P], GaushalaGroupByOutputType[P]>
        }
      >
    >


  export type GaushalaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    photo?: boolean
    address?: boolean
    establishmentYear?: boolean
    contactDetails?: boolean
    totalCows?: boolean
    capacity?: boolean
    description?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    contactPerson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gaushala"]>



  export type GaushalaSelectScalar = {
    id?: boolean
    name?: boolean
    photo?: boolean
    address?: boolean
    establishmentYear?: boolean
    contactDetails?: boolean
    totalCows?: boolean
    capacity?: boolean
    description?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    contactPerson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GaushalaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "photo" | "address" | "establishmentYear" | "contactDetails" | "totalCows" | "capacity" | "description" | "city" | "state" | "pincode" | "contactPerson" | "createdAt" | "updatedAt", ExtArgs["result"]["gaushala"]>

  export type $GaushalaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gaushala"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      photo: string | null
      address: string
      establishmentYear: number
      contactDetails: string
      totalCows: number
      capacity: number
      description: string | null
      city: string
      state: string
      pincode: string
      contactPerson: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gaushala"]>
    composites: {}
  }

  type GaushalaGetPayload<S extends boolean | null | undefined | GaushalaDefaultArgs> = $Result.GetResult<Prisma.$GaushalaPayload, S>

  type GaushalaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GaushalaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GaushalaCountAggregateInputType | true
    }

  export interface GaushalaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gaushala'], meta: { name: 'Gaushala' } }
    /**
     * Find zero or one Gaushala that matches the filter.
     * @param {GaushalaFindUniqueArgs} args - Arguments to find a Gaushala
     * @example
     * // Get one Gaushala
     * const gaushala = await prisma.gaushala.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GaushalaFindUniqueArgs>(args: SelectSubset<T, GaushalaFindUniqueArgs<ExtArgs>>): Prisma__GaushalaClient<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gaushala that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GaushalaFindUniqueOrThrowArgs} args - Arguments to find a Gaushala
     * @example
     * // Get one Gaushala
     * const gaushala = await prisma.gaushala.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GaushalaFindUniqueOrThrowArgs>(args: SelectSubset<T, GaushalaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GaushalaClient<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gaushala that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaushalaFindFirstArgs} args - Arguments to find a Gaushala
     * @example
     * // Get one Gaushala
     * const gaushala = await prisma.gaushala.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GaushalaFindFirstArgs>(args?: SelectSubset<T, GaushalaFindFirstArgs<ExtArgs>>): Prisma__GaushalaClient<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gaushala that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaushalaFindFirstOrThrowArgs} args - Arguments to find a Gaushala
     * @example
     * // Get one Gaushala
     * const gaushala = await prisma.gaushala.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GaushalaFindFirstOrThrowArgs>(args?: SelectSubset<T, GaushalaFindFirstOrThrowArgs<ExtArgs>>): Prisma__GaushalaClient<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gaushalas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaushalaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gaushalas
     * const gaushalas = await prisma.gaushala.findMany()
     * 
     * // Get first 10 Gaushalas
     * const gaushalas = await prisma.gaushala.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gaushalaWithIdOnly = await prisma.gaushala.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GaushalaFindManyArgs>(args?: SelectSubset<T, GaushalaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gaushala.
     * @param {GaushalaCreateArgs} args - Arguments to create a Gaushala.
     * @example
     * // Create one Gaushala
     * const Gaushala = await prisma.gaushala.create({
     *   data: {
     *     // ... data to create a Gaushala
     *   }
     * })
     * 
     */
    create<T extends GaushalaCreateArgs>(args: SelectSubset<T, GaushalaCreateArgs<ExtArgs>>): Prisma__GaushalaClient<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gaushalas.
     * @param {GaushalaCreateManyArgs} args - Arguments to create many Gaushalas.
     * @example
     * // Create many Gaushalas
     * const gaushala = await prisma.gaushala.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GaushalaCreateManyArgs>(args?: SelectSubset<T, GaushalaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gaushala.
     * @param {GaushalaDeleteArgs} args - Arguments to delete one Gaushala.
     * @example
     * // Delete one Gaushala
     * const Gaushala = await prisma.gaushala.delete({
     *   where: {
     *     // ... filter to delete one Gaushala
     *   }
     * })
     * 
     */
    delete<T extends GaushalaDeleteArgs>(args: SelectSubset<T, GaushalaDeleteArgs<ExtArgs>>): Prisma__GaushalaClient<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gaushala.
     * @param {GaushalaUpdateArgs} args - Arguments to update one Gaushala.
     * @example
     * // Update one Gaushala
     * const gaushala = await prisma.gaushala.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GaushalaUpdateArgs>(args: SelectSubset<T, GaushalaUpdateArgs<ExtArgs>>): Prisma__GaushalaClient<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gaushalas.
     * @param {GaushalaDeleteManyArgs} args - Arguments to filter Gaushalas to delete.
     * @example
     * // Delete a few Gaushalas
     * const { count } = await prisma.gaushala.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GaushalaDeleteManyArgs>(args?: SelectSubset<T, GaushalaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gaushalas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaushalaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gaushalas
     * const gaushala = await prisma.gaushala.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GaushalaUpdateManyArgs>(args: SelectSubset<T, GaushalaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gaushala.
     * @param {GaushalaUpsertArgs} args - Arguments to update or create a Gaushala.
     * @example
     * // Update or create a Gaushala
     * const gaushala = await prisma.gaushala.upsert({
     *   create: {
     *     // ... data to create a Gaushala
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gaushala we want to update
     *   }
     * })
     */
    upsert<T extends GaushalaUpsertArgs>(args: SelectSubset<T, GaushalaUpsertArgs<ExtArgs>>): Prisma__GaushalaClient<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gaushalas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaushalaCountArgs} args - Arguments to filter Gaushalas to count.
     * @example
     * // Count the number of Gaushalas
     * const count = await prisma.gaushala.count({
     *   where: {
     *     // ... the filter for the Gaushalas we want to count
     *   }
     * })
    **/
    count<T extends GaushalaCountArgs>(
      args?: Subset<T, GaushalaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GaushalaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gaushala.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaushalaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GaushalaAggregateArgs>(args: Subset<T, GaushalaAggregateArgs>): Prisma.PrismaPromise<GetGaushalaAggregateType<T>>

    /**
     * Group by Gaushala.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaushalaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GaushalaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GaushalaGroupByArgs['orderBy'] }
        : { orderBy?: GaushalaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GaushalaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGaushalaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gaushala model
   */
  readonly fields: GaushalaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gaushala.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GaushalaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gaushala model
   */
  interface GaushalaFieldRefs {
    readonly id: FieldRef<"Gaushala", 'Int'>
    readonly name: FieldRef<"Gaushala", 'String'>
    readonly photo: FieldRef<"Gaushala", 'String'>
    readonly address: FieldRef<"Gaushala", 'String'>
    readonly establishmentYear: FieldRef<"Gaushala", 'Int'>
    readonly contactDetails: FieldRef<"Gaushala", 'String'>
    readonly totalCows: FieldRef<"Gaushala", 'Int'>
    readonly capacity: FieldRef<"Gaushala", 'Int'>
    readonly description: FieldRef<"Gaushala", 'String'>
    readonly city: FieldRef<"Gaushala", 'String'>
    readonly state: FieldRef<"Gaushala", 'String'>
    readonly pincode: FieldRef<"Gaushala", 'String'>
    readonly contactPerson: FieldRef<"Gaushala", 'String'>
    readonly createdAt: FieldRef<"Gaushala", 'DateTime'>
    readonly updatedAt: FieldRef<"Gaushala", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Gaushala findUnique
   */
  export type GaushalaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * Filter, which Gaushala to fetch.
     */
    where: GaushalaWhereUniqueInput
  }

  /**
   * Gaushala findUniqueOrThrow
   */
  export type GaushalaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * Filter, which Gaushala to fetch.
     */
    where: GaushalaWhereUniqueInput
  }

  /**
   * Gaushala findFirst
   */
  export type GaushalaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * Filter, which Gaushala to fetch.
     */
    where?: GaushalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gaushalas to fetch.
     */
    orderBy?: GaushalaOrderByWithRelationInput | GaushalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gaushalas.
     */
    cursor?: GaushalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gaushalas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gaushalas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gaushalas.
     */
    distinct?: GaushalaScalarFieldEnum | GaushalaScalarFieldEnum[]
  }

  /**
   * Gaushala findFirstOrThrow
   */
  export type GaushalaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * Filter, which Gaushala to fetch.
     */
    where?: GaushalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gaushalas to fetch.
     */
    orderBy?: GaushalaOrderByWithRelationInput | GaushalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gaushalas.
     */
    cursor?: GaushalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gaushalas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gaushalas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gaushalas.
     */
    distinct?: GaushalaScalarFieldEnum | GaushalaScalarFieldEnum[]
  }

  /**
   * Gaushala findMany
   */
  export type GaushalaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * Filter, which Gaushalas to fetch.
     */
    where?: GaushalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gaushalas to fetch.
     */
    orderBy?: GaushalaOrderByWithRelationInput | GaushalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gaushalas.
     */
    cursor?: GaushalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gaushalas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gaushalas.
     */
    skip?: number
    distinct?: GaushalaScalarFieldEnum | GaushalaScalarFieldEnum[]
  }

  /**
   * Gaushala create
   */
  export type GaushalaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * The data needed to create a Gaushala.
     */
    data: XOR<GaushalaCreateInput, GaushalaUncheckedCreateInput>
  }

  /**
   * Gaushala createMany
   */
  export type GaushalaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gaushalas.
     */
    data: GaushalaCreateManyInput | GaushalaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gaushala update
   */
  export type GaushalaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * The data needed to update a Gaushala.
     */
    data: XOR<GaushalaUpdateInput, GaushalaUncheckedUpdateInput>
    /**
     * Choose, which Gaushala to update.
     */
    where: GaushalaWhereUniqueInput
  }

  /**
   * Gaushala updateMany
   */
  export type GaushalaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gaushalas.
     */
    data: XOR<GaushalaUpdateManyMutationInput, GaushalaUncheckedUpdateManyInput>
    /**
     * Filter which Gaushalas to update
     */
    where?: GaushalaWhereInput
    /**
     * Limit how many Gaushalas to update.
     */
    limit?: number
  }

  /**
   * Gaushala upsert
   */
  export type GaushalaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * The filter to search for the Gaushala to update in case it exists.
     */
    where: GaushalaWhereUniqueInput
    /**
     * In case the Gaushala found by the `where` argument doesn't exist, create a new Gaushala with this data.
     */
    create: XOR<GaushalaCreateInput, GaushalaUncheckedCreateInput>
    /**
     * In case the Gaushala was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GaushalaUpdateInput, GaushalaUncheckedUpdateInput>
  }

  /**
   * Gaushala delete
   */
  export type GaushalaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * Filter which Gaushala to delete.
     */
    where: GaushalaWhereUniqueInput
  }

  /**
   * Gaushala deleteMany
   */
  export type GaushalaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gaushalas to delete
     */
    where?: GaushalaWhereInput
    /**
     * Limit how many Gaushalas to delete.
     */
    limit?: number
  }

  /**
   * Gaushala without action
   */
  export type GaushalaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
  }


  /**
   * Model Card
   */

  export type AggregateCard = {
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  export type CardAvgAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type CardSumAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type CardMinAggregateOutputType = {
    id: number | null
    title: string | null
    titleEn: string | null
    link: string | null
    image: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CardMaxAggregateOutputType = {
    id: number | null
    title: string | null
    titleEn: string | null
    link: string | null
    image: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CardCountAggregateOutputType = {
    id: number
    title: number
    titleEn: number
    link: number
    image: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CardAvgAggregateInputType = {
    id?: true
    order?: true
  }

  export type CardSumAggregateInputType = {
    id?: true
    order?: true
  }

  export type CardMinAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    link?: true
    image?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CardMaxAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    link?: true
    image?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CardCountAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    link?: true
    image?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Card to aggregate.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cards
    **/
    _count?: true | CardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardMaxAggregateInputType
  }

  export type GetCardAggregateType<T extends CardAggregateArgs> = {
        [P in keyof T & keyof AggregateCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCard[P]>
      : GetScalarType<T[P], AggregateCard[P]>
  }




  export type CardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardWhereInput
    orderBy?: CardOrderByWithAggregationInput | CardOrderByWithAggregationInput[]
    by: CardScalarFieldEnum[] | CardScalarFieldEnum
    having?: CardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardCountAggregateInputType | true
    _avg?: CardAvgAggregateInputType
    _sum?: CardSumAggregateInputType
    _min?: CardMinAggregateInputType
    _max?: CardMaxAggregateInputType
  }

  export type CardGroupByOutputType = {
    id: number
    title: string
    titleEn: string | null
    link: string
    image: string | null
    order: number | null
    createdAt: Date
    updatedAt: Date
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  type GetCardGroupByPayload<T extends CardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardGroupByOutputType[P]>
            : GetScalarType<T[P], CardGroupByOutputType[P]>
        }
      >
    >


  export type CardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    titleEn?: boolean
    link?: boolean
    image?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["card"]>



  export type CardSelectScalar = {
    id?: boolean
    title?: boolean
    titleEn?: boolean
    link?: boolean
    image?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "titleEn" | "link" | "image" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["card"]>

  export type $CardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Card"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      titleEn: string | null
      link: string
      image: string | null
      order: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["card"]>
    composites: {}
  }

  type CardGetPayload<S extends boolean | null | undefined | CardDefaultArgs> = $Result.GetResult<Prisma.$CardPayload, S>

  type CardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardCountAggregateInputType | true
    }

  export interface CardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Card'], meta: { name: 'Card' } }
    /**
     * Find zero or one Card that matches the filter.
     * @param {CardFindUniqueArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardFindUniqueArgs>(args: SelectSubset<T, CardFindUniqueArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Card that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardFindUniqueOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardFindUniqueOrThrowArgs>(args: SelectSubset<T, CardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Card that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindFirstArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardFindFirstArgs>(args?: SelectSubset<T, CardFindFirstArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Card that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindFirstOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardFindFirstOrThrowArgs>(args?: SelectSubset<T, CardFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cards
     * const cards = await prisma.card.findMany()
     * 
     * // Get first 10 Cards
     * const cards = await prisma.card.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardWithIdOnly = await prisma.card.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardFindManyArgs>(args?: SelectSubset<T, CardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Card.
     * @param {CardCreateArgs} args - Arguments to create a Card.
     * @example
     * // Create one Card
     * const Card = await prisma.card.create({
     *   data: {
     *     // ... data to create a Card
     *   }
     * })
     * 
     */
    create<T extends CardCreateArgs>(args: SelectSubset<T, CardCreateArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cards.
     * @param {CardCreateManyArgs} args - Arguments to create many Cards.
     * @example
     * // Create many Cards
     * const card = await prisma.card.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardCreateManyArgs>(args?: SelectSubset<T, CardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Card.
     * @param {CardDeleteArgs} args - Arguments to delete one Card.
     * @example
     * // Delete one Card
     * const Card = await prisma.card.delete({
     *   where: {
     *     // ... filter to delete one Card
     *   }
     * })
     * 
     */
    delete<T extends CardDeleteArgs>(args: SelectSubset<T, CardDeleteArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Card.
     * @param {CardUpdateArgs} args - Arguments to update one Card.
     * @example
     * // Update one Card
     * const card = await prisma.card.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardUpdateArgs>(args: SelectSubset<T, CardUpdateArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cards.
     * @param {CardDeleteManyArgs} args - Arguments to filter Cards to delete.
     * @example
     * // Delete a few Cards
     * const { count } = await prisma.card.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardDeleteManyArgs>(args?: SelectSubset<T, CardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cards
     * const card = await prisma.card.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardUpdateManyArgs>(args: SelectSubset<T, CardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Card.
     * @param {CardUpsertArgs} args - Arguments to update or create a Card.
     * @example
     * // Update or create a Card
     * const card = await prisma.card.upsert({
     *   create: {
     *     // ... data to create a Card
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Card we want to update
     *   }
     * })
     */
    upsert<T extends CardUpsertArgs>(args: SelectSubset<T, CardUpsertArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardCountArgs} args - Arguments to filter Cards to count.
     * @example
     * // Count the number of Cards
     * const count = await prisma.card.count({
     *   where: {
     *     // ... the filter for the Cards we want to count
     *   }
     * })
    **/
    count<T extends CardCountArgs>(
      args?: Subset<T, CardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardAggregateArgs>(args: Subset<T, CardAggregateArgs>): Prisma.PrismaPromise<GetCardAggregateType<T>>

    /**
     * Group by Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardGroupByArgs['orderBy'] }
        : { orderBy?: CardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Card model
   */
  readonly fields: CardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Card.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Card model
   */
  interface CardFieldRefs {
    readonly id: FieldRef<"Card", 'Int'>
    readonly title: FieldRef<"Card", 'String'>
    readonly titleEn: FieldRef<"Card", 'String'>
    readonly link: FieldRef<"Card", 'String'>
    readonly image: FieldRef<"Card", 'String'>
    readonly order: FieldRef<"Card", 'Int'>
    readonly createdAt: FieldRef<"Card", 'DateTime'>
    readonly updatedAt: FieldRef<"Card", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Card findUnique
   */
  export type CardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card findUniqueOrThrow
   */
  export type CardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card findFirst
   */
  export type CardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cards.
     */
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card findFirstOrThrow
   */
  export type CardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cards.
     */
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card findMany
   */
  export type CardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Filter, which Cards to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card create
   */
  export type CardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * The data needed to create a Card.
     */
    data: XOR<CardCreateInput, CardUncheckedCreateInput>
  }

  /**
   * Card createMany
   */
  export type CardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cards.
     */
    data: CardCreateManyInput | CardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Card update
   */
  export type CardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * The data needed to update a Card.
     */
    data: XOR<CardUpdateInput, CardUncheckedUpdateInput>
    /**
     * Choose, which Card to update.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card updateMany
   */
  export type CardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cards.
     */
    data: XOR<CardUpdateManyMutationInput, CardUncheckedUpdateManyInput>
    /**
     * Filter which Cards to update
     */
    where?: CardWhereInput
    /**
     * Limit how many Cards to update.
     */
    limit?: number
  }

  /**
   * Card upsert
   */
  export type CardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * The filter to search for the Card to update in case it exists.
     */
    where: CardWhereUniqueInput
    /**
     * In case the Card found by the `where` argument doesn't exist, create a new Card with this data.
     */
    create: XOR<CardCreateInput, CardUncheckedCreateInput>
    /**
     * In case the Card was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardUpdateInput, CardUncheckedUpdateInput>
  }

  /**
   * Card delete
   */
  export type CardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Filter which Card to delete.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card deleteMany
   */
  export type CardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cards to delete
     */
    where?: CardWhereInput
    /**
     * Limit how many Cards to delete.
     */
    limit?: number
  }

  /**
   * Card without action
   */
  export type CardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
  }


  /**
   * Model DtaSanssthan
   */

  export type AggregateDtaSanssthan = {
    _count: DtaSanssthanCountAggregateOutputType | null
    _avg: DtaSanssthanAvgAggregateOutputType | null
    _sum: DtaSanssthanSumAggregateOutputType | null
    _min: DtaSanssthanMinAggregateOutputType | null
    _max: DtaSanssthanMaxAggregateOutputType | null
  }

  export type DtaSanssthanAvgAggregateOutputType = {
    id: number | null
  }

  export type DtaSanssthanSumAggregateOutputType = {
    id: number | null
  }

  export type DtaSanssthanMinAggregateOutputType = {
    id: number | null
    name: string | null
    person: string | null
    image: string | null
    description: string | null
    email: string | null
    phone: string | null
    altPhone: string | null
    website: string | null
    timing: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DtaSanssthanMaxAggregateOutputType = {
    id: number | null
    name: string | null
    person: string | null
    image: string | null
    description: string | null
    email: string | null
    phone: string | null
    altPhone: string | null
    website: string | null
    timing: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DtaSanssthanCountAggregateOutputType = {
    id: number
    name: number
    person: number
    image: number
    description: number
    email: number
    phone: number
    altPhone: number
    website: number
    timing: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DtaSanssthanAvgAggregateInputType = {
    id?: true
  }

  export type DtaSanssthanSumAggregateInputType = {
    id?: true
  }

  export type DtaSanssthanMinAggregateInputType = {
    id?: true
    name?: true
    person?: true
    image?: true
    description?: true
    email?: true
    phone?: true
    altPhone?: true
    website?: true
    timing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DtaSanssthanMaxAggregateInputType = {
    id?: true
    name?: true
    person?: true
    image?: true
    description?: true
    email?: true
    phone?: true
    altPhone?: true
    website?: true
    timing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DtaSanssthanCountAggregateInputType = {
    id?: true
    name?: true
    person?: true
    image?: true
    description?: true
    email?: true
    phone?: true
    altPhone?: true
    website?: true
    timing?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DtaSanssthanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DtaSanssthan to aggregate.
     */
    where?: DtaSanssthanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DtaSanssthans to fetch.
     */
    orderBy?: DtaSanssthanOrderByWithRelationInput | DtaSanssthanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DtaSanssthanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DtaSanssthans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DtaSanssthans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DtaSanssthans
    **/
    _count?: true | DtaSanssthanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DtaSanssthanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DtaSanssthanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DtaSanssthanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DtaSanssthanMaxAggregateInputType
  }

  export type GetDtaSanssthanAggregateType<T extends DtaSanssthanAggregateArgs> = {
        [P in keyof T & keyof AggregateDtaSanssthan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDtaSanssthan[P]>
      : GetScalarType<T[P], AggregateDtaSanssthan[P]>
  }




  export type DtaSanssthanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DtaSanssthanWhereInput
    orderBy?: DtaSanssthanOrderByWithAggregationInput | DtaSanssthanOrderByWithAggregationInput[]
    by: DtaSanssthanScalarFieldEnum[] | DtaSanssthanScalarFieldEnum
    having?: DtaSanssthanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DtaSanssthanCountAggregateInputType | true
    _avg?: DtaSanssthanAvgAggregateInputType
    _sum?: DtaSanssthanSumAggregateInputType
    _min?: DtaSanssthanMinAggregateInputType
    _max?: DtaSanssthanMaxAggregateInputType
  }

  export type DtaSanssthanGroupByOutputType = {
    id: number
    name: string
    person: string | null
    image: string | null
    description: string | null
    email: string | null
    phone: string | null
    altPhone: string | null
    website: string | null
    timing: string | null
    createdAt: Date
    updatedAt: Date
    _count: DtaSanssthanCountAggregateOutputType | null
    _avg: DtaSanssthanAvgAggregateOutputType | null
    _sum: DtaSanssthanSumAggregateOutputType | null
    _min: DtaSanssthanMinAggregateOutputType | null
    _max: DtaSanssthanMaxAggregateOutputType | null
  }

  type GetDtaSanssthanGroupByPayload<T extends DtaSanssthanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DtaSanssthanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DtaSanssthanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DtaSanssthanGroupByOutputType[P]>
            : GetScalarType<T[P], DtaSanssthanGroupByOutputType[P]>
        }
      >
    >


  export type DtaSanssthanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    person?: boolean
    image?: boolean
    description?: boolean
    email?: boolean
    phone?: boolean
    altPhone?: boolean
    website?: boolean
    timing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dtaSanssthan"]>



  export type DtaSanssthanSelectScalar = {
    id?: boolean
    name?: boolean
    person?: boolean
    image?: boolean
    description?: boolean
    email?: boolean
    phone?: boolean
    altPhone?: boolean
    website?: boolean
    timing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DtaSanssthanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "person" | "image" | "description" | "email" | "phone" | "altPhone" | "website" | "timing" | "createdAt" | "updatedAt", ExtArgs["result"]["dtaSanssthan"]>

  export type $DtaSanssthanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DtaSanssthan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      person: string | null
      image: string | null
      description: string | null
      email: string | null
      phone: string | null
      altPhone: string | null
      website: string | null
      timing: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dtaSanssthan"]>
    composites: {}
  }

  type DtaSanssthanGetPayload<S extends boolean | null | undefined | DtaSanssthanDefaultArgs> = $Result.GetResult<Prisma.$DtaSanssthanPayload, S>

  type DtaSanssthanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DtaSanssthanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DtaSanssthanCountAggregateInputType | true
    }

  export interface DtaSanssthanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DtaSanssthan'], meta: { name: 'DtaSanssthan' } }
    /**
     * Find zero or one DtaSanssthan that matches the filter.
     * @param {DtaSanssthanFindUniqueArgs} args - Arguments to find a DtaSanssthan
     * @example
     * // Get one DtaSanssthan
     * const dtaSanssthan = await prisma.dtaSanssthan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DtaSanssthanFindUniqueArgs>(args: SelectSubset<T, DtaSanssthanFindUniqueArgs<ExtArgs>>): Prisma__DtaSanssthanClient<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DtaSanssthan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DtaSanssthanFindUniqueOrThrowArgs} args - Arguments to find a DtaSanssthan
     * @example
     * // Get one DtaSanssthan
     * const dtaSanssthan = await prisma.dtaSanssthan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DtaSanssthanFindUniqueOrThrowArgs>(args: SelectSubset<T, DtaSanssthanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DtaSanssthanClient<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DtaSanssthan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DtaSanssthanFindFirstArgs} args - Arguments to find a DtaSanssthan
     * @example
     * // Get one DtaSanssthan
     * const dtaSanssthan = await prisma.dtaSanssthan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DtaSanssthanFindFirstArgs>(args?: SelectSubset<T, DtaSanssthanFindFirstArgs<ExtArgs>>): Prisma__DtaSanssthanClient<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DtaSanssthan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DtaSanssthanFindFirstOrThrowArgs} args - Arguments to find a DtaSanssthan
     * @example
     * // Get one DtaSanssthan
     * const dtaSanssthan = await prisma.dtaSanssthan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DtaSanssthanFindFirstOrThrowArgs>(args?: SelectSubset<T, DtaSanssthanFindFirstOrThrowArgs<ExtArgs>>): Prisma__DtaSanssthanClient<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DtaSanssthans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DtaSanssthanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DtaSanssthans
     * const dtaSanssthans = await prisma.dtaSanssthan.findMany()
     * 
     * // Get first 10 DtaSanssthans
     * const dtaSanssthans = await prisma.dtaSanssthan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dtaSanssthanWithIdOnly = await prisma.dtaSanssthan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DtaSanssthanFindManyArgs>(args?: SelectSubset<T, DtaSanssthanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DtaSanssthan.
     * @param {DtaSanssthanCreateArgs} args - Arguments to create a DtaSanssthan.
     * @example
     * // Create one DtaSanssthan
     * const DtaSanssthan = await prisma.dtaSanssthan.create({
     *   data: {
     *     // ... data to create a DtaSanssthan
     *   }
     * })
     * 
     */
    create<T extends DtaSanssthanCreateArgs>(args: SelectSubset<T, DtaSanssthanCreateArgs<ExtArgs>>): Prisma__DtaSanssthanClient<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DtaSanssthans.
     * @param {DtaSanssthanCreateManyArgs} args - Arguments to create many DtaSanssthans.
     * @example
     * // Create many DtaSanssthans
     * const dtaSanssthan = await prisma.dtaSanssthan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DtaSanssthanCreateManyArgs>(args?: SelectSubset<T, DtaSanssthanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DtaSanssthan.
     * @param {DtaSanssthanDeleteArgs} args - Arguments to delete one DtaSanssthan.
     * @example
     * // Delete one DtaSanssthan
     * const DtaSanssthan = await prisma.dtaSanssthan.delete({
     *   where: {
     *     // ... filter to delete one DtaSanssthan
     *   }
     * })
     * 
     */
    delete<T extends DtaSanssthanDeleteArgs>(args: SelectSubset<T, DtaSanssthanDeleteArgs<ExtArgs>>): Prisma__DtaSanssthanClient<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DtaSanssthan.
     * @param {DtaSanssthanUpdateArgs} args - Arguments to update one DtaSanssthan.
     * @example
     * // Update one DtaSanssthan
     * const dtaSanssthan = await prisma.dtaSanssthan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DtaSanssthanUpdateArgs>(args: SelectSubset<T, DtaSanssthanUpdateArgs<ExtArgs>>): Prisma__DtaSanssthanClient<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DtaSanssthans.
     * @param {DtaSanssthanDeleteManyArgs} args - Arguments to filter DtaSanssthans to delete.
     * @example
     * // Delete a few DtaSanssthans
     * const { count } = await prisma.dtaSanssthan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DtaSanssthanDeleteManyArgs>(args?: SelectSubset<T, DtaSanssthanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DtaSanssthans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DtaSanssthanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DtaSanssthans
     * const dtaSanssthan = await prisma.dtaSanssthan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DtaSanssthanUpdateManyArgs>(args: SelectSubset<T, DtaSanssthanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DtaSanssthan.
     * @param {DtaSanssthanUpsertArgs} args - Arguments to update or create a DtaSanssthan.
     * @example
     * // Update or create a DtaSanssthan
     * const dtaSanssthan = await prisma.dtaSanssthan.upsert({
     *   create: {
     *     // ... data to create a DtaSanssthan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DtaSanssthan we want to update
     *   }
     * })
     */
    upsert<T extends DtaSanssthanUpsertArgs>(args: SelectSubset<T, DtaSanssthanUpsertArgs<ExtArgs>>): Prisma__DtaSanssthanClient<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DtaSanssthans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DtaSanssthanCountArgs} args - Arguments to filter DtaSanssthans to count.
     * @example
     * // Count the number of DtaSanssthans
     * const count = await prisma.dtaSanssthan.count({
     *   where: {
     *     // ... the filter for the DtaSanssthans we want to count
     *   }
     * })
    **/
    count<T extends DtaSanssthanCountArgs>(
      args?: Subset<T, DtaSanssthanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DtaSanssthanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DtaSanssthan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DtaSanssthanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DtaSanssthanAggregateArgs>(args: Subset<T, DtaSanssthanAggregateArgs>): Prisma.PrismaPromise<GetDtaSanssthanAggregateType<T>>

    /**
     * Group by DtaSanssthan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DtaSanssthanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DtaSanssthanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DtaSanssthanGroupByArgs['orderBy'] }
        : { orderBy?: DtaSanssthanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DtaSanssthanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDtaSanssthanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DtaSanssthan model
   */
  readonly fields: DtaSanssthanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DtaSanssthan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DtaSanssthanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DtaSanssthan model
   */
  interface DtaSanssthanFieldRefs {
    readonly id: FieldRef<"DtaSanssthan", 'Int'>
    readonly name: FieldRef<"DtaSanssthan", 'String'>
    readonly person: FieldRef<"DtaSanssthan", 'String'>
    readonly image: FieldRef<"DtaSanssthan", 'String'>
    readonly description: FieldRef<"DtaSanssthan", 'String'>
    readonly email: FieldRef<"DtaSanssthan", 'String'>
    readonly phone: FieldRef<"DtaSanssthan", 'String'>
    readonly altPhone: FieldRef<"DtaSanssthan", 'String'>
    readonly website: FieldRef<"DtaSanssthan", 'String'>
    readonly timing: FieldRef<"DtaSanssthan", 'String'>
    readonly createdAt: FieldRef<"DtaSanssthan", 'DateTime'>
    readonly updatedAt: FieldRef<"DtaSanssthan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DtaSanssthan findUnique
   */
  export type DtaSanssthanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * Filter, which DtaSanssthan to fetch.
     */
    where: DtaSanssthanWhereUniqueInput
  }

  /**
   * DtaSanssthan findUniqueOrThrow
   */
  export type DtaSanssthanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * Filter, which DtaSanssthan to fetch.
     */
    where: DtaSanssthanWhereUniqueInput
  }

  /**
   * DtaSanssthan findFirst
   */
  export type DtaSanssthanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * Filter, which DtaSanssthan to fetch.
     */
    where?: DtaSanssthanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DtaSanssthans to fetch.
     */
    orderBy?: DtaSanssthanOrderByWithRelationInput | DtaSanssthanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DtaSanssthans.
     */
    cursor?: DtaSanssthanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DtaSanssthans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DtaSanssthans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DtaSanssthans.
     */
    distinct?: DtaSanssthanScalarFieldEnum | DtaSanssthanScalarFieldEnum[]
  }

  /**
   * DtaSanssthan findFirstOrThrow
   */
  export type DtaSanssthanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * Filter, which DtaSanssthan to fetch.
     */
    where?: DtaSanssthanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DtaSanssthans to fetch.
     */
    orderBy?: DtaSanssthanOrderByWithRelationInput | DtaSanssthanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DtaSanssthans.
     */
    cursor?: DtaSanssthanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DtaSanssthans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DtaSanssthans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DtaSanssthans.
     */
    distinct?: DtaSanssthanScalarFieldEnum | DtaSanssthanScalarFieldEnum[]
  }

  /**
   * DtaSanssthan findMany
   */
  export type DtaSanssthanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * Filter, which DtaSanssthans to fetch.
     */
    where?: DtaSanssthanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DtaSanssthans to fetch.
     */
    orderBy?: DtaSanssthanOrderByWithRelationInput | DtaSanssthanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DtaSanssthans.
     */
    cursor?: DtaSanssthanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DtaSanssthans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DtaSanssthans.
     */
    skip?: number
    distinct?: DtaSanssthanScalarFieldEnum | DtaSanssthanScalarFieldEnum[]
  }

  /**
   * DtaSanssthan create
   */
  export type DtaSanssthanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * The data needed to create a DtaSanssthan.
     */
    data: XOR<DtaSanssthanCreateInput, DtaSanssthanUncheckedCreateInput>
  }

  /**
   * DtaSanssthan createMany
   */
  export type DtaSanssthanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DtaSanssthans.
     */
    data: DtaSanssthanCreateManyInput | DtaSanssthanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DtaSanssthan update
   */
  export type DtaSanssthanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * The data needed to update a DtaSanssthan.
     */
    data: XOR<DtaSanssthanUpdateInput, DtaSanssthanUncheckedUpdateInput>
    /**
     * Choose, which DtaSanssthan to update.
     */
    where: DtaSanssthanWhereUniqueInput
  }

  /**
   * DtaSanssthan updateMany
   */
  export type DtaSanssthanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DtaSanssthans.
     */
    data: XOR<DtaSanssthanUpdateManyMutationInput, DtaSanssthanUncheckedUpdateManyInput>
    /**
     * Filter which DtaSanssthans to update
     */
    where?: DtaSanssthanWhereInput
    /**
     * Limit how many DtaSanssthans to update.
     */
    limit?: number
  }

  /**
   * DtaSanssthan upsert
   */
  export type DtaSanssthanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * The filter to search for the DtaSanssthan to update in case it exists.
     */
    where: DtaSanssthanWhereUniqueInput
    /**
     * In case the DtaSanssthan found by the `where` argument doesn't exist, create a new DtaSanssthan with this data.
     */
    create: XOR<DtaSanssthanCreateInput, DtaSanssthanUncheckedCreateInput>
    /**
     * In case the DtaSanssthan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DtaSanssthanUpdateInput, DtaSanssthanUncheckedUpdateInput>
  }

  /**
   * DtaSanssthan delete
   */
  export type DtaSanssthanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * Filter which DtaSanssthan to delete.
     */
    where: DtaSanssthanWhereUniqueInput
  }

  /**
   * DtaSanssthan deleteMany
   */
  export type DtaSanssthanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DtaSanssthans to delete
     */
    where?: DtaSanssthanWhereInput
    /**
     * Limit how many DtaSanssthans to delete.
     */
    limit?: number
  }

  /**
   * DtaSanssthan without action
   */
  export type DtaSanssthanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
  }


  /**
   * Model PrivacyPolicy
   */

  export type AggregatePrivacyPolicy = {
    _count: PrivacyPolicyCountAggregateOutputType | null
    _avg: PrivacyPolicyAvgAggregateOutputType | null
    _sum: PrivacyPolicySumAggregateOutputType | null
    _min: PrivacyPolicyMinAggregateOutputType | null
    _max: PrivacyPolicyMaxAggregateOutputType | null
  }

  export type PrivacyPolicyAvgAggregateOutputType = {
    id: number | null
  }

  export type PrivacyPolicySumAggregateOutputType = {
    id: number | null
  }

  export type PrivacyPolicyMinAggregateOutputType = {
    id: number | null
    title: string | null
    subtitle: string | null
    email: string | null
    phone: string | null
    callingHours: string | null
    mailingAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivacyPolicyMaxAggregateOutputType = {
    id: number | null
    title: string | null
    subtitle: string | null
    email: string | null
    phone: string | null
    callingHours: string | null
    mailingAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivacyPolicyCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    sections: number
    email: number
    phone: number
    callingHours: number
    mailingAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PrivacyPolicyAvgAggregateInputType = {
    id?: true
  }

  export type PrivacyPolicySumAggregateInputType = {
    id?: true
  }

  export type PrivacyPolicyMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    email?: true
    phone?: true
    callingHours?: true
    mailingAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivacyPolicyMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    email?: true
    phone?: true
    callingHours?: true
    mailingAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivacyPolicyCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    sections?: true
    email?: true
    phone?: true
    callingHours?: true
    mailingAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PrivacyPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivacyPolicy to aggregate.
     */
    where?: PrivacyPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyPolicies to fetch.
     */
    orderBy?: PrivacyPolicyOrderByWithRelationInput | PrivacyPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrivacyPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrivacyPolicies
    **/
    _count?: true | PrivacyPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrivacyPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrivacyPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivacyPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivacyPolicyMaxAggregateInputType
  }

  export type GetPrivacyPolicyAggregateType<T extends PrivacyPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivacyPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivacyPolicy[P]>
      : GetScalarType<T[P], AggregatePrivacyPolicy[P]>
  }




  export type PrivacyPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivacyPolicyWhereInput
    orderBy?: PrivacyPolicyOrderByWithAggregationInput | PrivacyPolicyOrderByWithAggregationInput[]
    by: PrivacyPolicyScalarFieldEnum[] | PrivacyPolicyScalarFieldEnum
    having?: PrivacyPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivacyPolicyCountAggregateInputType | true
    _avg?: PrivacyPolicyAvgAggregateInputType
    _sum?: PrivacyPolicySumAggregateInputType
    _min?: PrivacyPolicyMinAggregateInputType
    _max?: PrivacyPolicyMaxAggregateInputType
  }

  export type PrivacyPolicyGroupByOutputType = {
    id: number
    title: string
    subtitle: string | null
    sections: JsonValue
    email: string | null
    phone: string | null
    callingHours: string | null
    mailingAddress: string | null
    createdAt: Date
    updatedAt: Date
    _count: PrivacyPolicyCountAggregateOutputType | null
    _avg: PrivacyPolicyAvgAggregateOutputType | null
    _sum: PrivacyPolicySumAggregateOutputType | null
    _min: PrivacyPolicyMinAggregateOutputType | null
    _max: PrivacyPolicyMaxAggregateOutputType | null
  }

  type GetPrivacyPolicyGroupByPayload<T extends PrivacyPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivacyPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivacyPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivacyPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PrivacyPolicyGroupByOutputType[P]>
        }
      >
    >


  export type PrivacyPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    sections?: boolean
    email?: boolean
    phone?: boolean
    callingHours?: boolean
    mailingAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["privacyPolicy"]>



  export type PrivacyPolicySelectScalar = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    sections?: boolean
    email?: boolean
    phone?: boolean
    callingHours?: boolean
    mailingAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PrivacyPolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "subtitle" | "sections" | "email" | "phone" | "callingHours" | "mailingAddress" | "createdAt" | "updatedAt", ExtArgs["result"]["privacyPolicy"]>

  export type $PrivacyPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrivacyPolicy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      subtitle: string | null
      sections: Prisma.JsonValue
      email: string | null
      phone: string | null
      callingHours: string | null
      mailingAddress: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["privacyPolicy"]>
    composites: {}
  }

  type PrivacyPolicyGetPayload<S extends boolean | null | undefined | PrivacyPolicyDefaultArgs> = $Result.GetResult<Prisma.$PrivacyPolicyPayload, S>

  type PrivacyPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrivacyPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrivacyPolicyCountAggregateInputType | true
    }

  export interface PrivacyPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrivacyPolicy'], meta: { name: 'PrivacyPolicy' } }
    /**
     * Find zero or one PrivacyPolicy that matches the filter.
     * @param {PrivacyPolicyFindUniqueArgs} args - Arguments to find a PrivacyPolicy
     * @example
     * // Get one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrivacyPolicyFindUniqueArgs>(args: SelectSubset<T, PrivacyPolicyFindUniqueArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrivacyPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrivacyPolicyFindUniqueOrThrowArgs} args - Arguments to find a PrivacyPolicy
     * @example
     * // Get one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrivacyPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, PrivacyPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivacyPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyFindFirstArgs} args - Arguments to find a PrivacyPolicy
     * @example
     * // Get one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrivacyPolicyFindFirstArgs>(args?: SelectSubset<T, PrivacyPolicyFindFirstArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivacyPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyFindFirstOrThrowArgs} args - Arguments to find a PrivacyPolicy
     * @example
     * // Get one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrivacyPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, PrivacyPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrivacyPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrivacyPolicies
     * const privacyPolicies = await prisma.privacyPolicy.findMany()
     * 
     * // Get first 10 PrivacyPolicies
     * const privacyPolicies = await prisma.privacyPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privacyPolicyWithIdOnly = await prisma.privacyPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrivacyPolicyFindManyArgs>(args?: SelectSubset<T, PrivacyPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrivacyPolicy.
     * @param {PrivacyPolicyCreateArgs} args - Arguments to create a PrivacyPolicy.
     * @example
     * // Create one PrivacyPolicy
     * const PrivacyPolicy = await prisma.privacyPolicy.create({
     *   data: {
     *     // ... data to create a PrivacyPolicy
     *   }
     * })
     * 
     */
    create<T extends PrivacyPolicyCreateArgs>(args: SelectSubset<T, PrivacyPolicyCreateArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrivacyPolicies.
     * @param {PrivacyPolicyCreateManyArgs} args - Arguments to create many PrivacyPolicies.
     * @example
     * // Create many PrivacyPolicies
     * const privacyPolicy = await prisma.privacyPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrivacyPolicyCreateManyArgs>(args?: SelectSubset<T, PrivacyPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PrivacyPolicy.
     * @param {PrivacyPolicyDeleteArgs} args - Arguments to delete one PrivacyPolicy.
     * @example
     * // Delete one PrivacyPolicy
     * const PrivacyPolicy = await prisma.privacyPolicy.delete({
     *   where: {
     *     // ... filter to delete one PrivacyPolicy
     *   }
     * })
     * 
     */
    delete<T extends PrivacyPolicyDeleteArgs>(args: SelectSubset<T, PrivacyPolicyDeleteArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrivacyPolicy.
     * @param {PrivacyPolicyUpdateArgs} args - Arguments to update one PrivacyPolicy.
     * @example
     * // Update one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrivacyPolicyUpdateArgs>(args: SelectSubset<T, PrivacyPolicyUpdateArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrivacyPolicies.
     * @param {PrivacyPolicyDeleteManyArgs} args - Arguments to filter PrivacyPolicies to delete.
     * @example
     * // Delete a few PrivacyPolicies
     * const { count } = await prisma.privacyPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrivacyPolicyDeleteManyArgs>(args?: SelectSubset<T, PrivacyPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivacyPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrivacyPolicies
     * const privacyPolicy = await prisma.privacyPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrivacyPolicyUpdateManyArgs>(args: SelectSubset<T, PrivacyPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrivacyPolicy.
     * @param {PrivacyPolicyUpsertArgs} args - Arguments to update or create a PrivacyPolicy.
     * @example
     * // Update or create a PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.upsert({
     *   create: {
     *     // ... data to create a PrivacyPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrivacyPolicy we want to update
     *   }
     * })
     */
    upsert<T extends PrivacyPolicyUpsertArgs>(args: SelectSubset<T, PrivacyPolicyUpsertArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrivacyPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyCountArgs} args - Arguments to filter PrivacyPolicies to count.
     * @example
     * // Count the number of PrivacyPolicies
     * const count = await prisma.privacyPolicy.count({
     *   where: {
     *     // ... the filter for the PrivacyPolicies we want to count
     *   }
     * })
    **/
    count<T extends PrivacyPolicyCountArgs>(
      args?: Subset<T, PrivacyPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivacyPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrivacyPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivacyPolicyAggregateArgs>(args: Subset<T, PrivacyPolicyAggregateArgs>): Prisma.PrismaPromise<GetPrivacyPolicyAggregateType<T>>

    /**
     * Group by PrivacyPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrivacyPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrivacyPolicyGroupByArgs['orderBy'] }
        : { orderBy?: PrivacyPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrivacyPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivacyPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrivacyPolicy model
   */
  readonly fields: PrivacyPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrivacyPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrivacyPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrivacyPolicy model
   */
  interface PrivacyPolicyFieldRefs {
    readonly id: FieldRef<"PrivacyPolicy", 'Int'>
    readonly title: FieldRef<"PrivacyPolicy", 'String'>
    readonly subtitle: FieldRef<"PrivacyPolicy", 'String'>
    readonly sections: FieldRef<"PrivacyPolicy", 'Json'>
    readonly email: FieldRef<"PrivacyPolicy", 'String'>
    readonly phone: FieldRef<"PrivacyPolicy", 'String'>
    readonly callingHours: FieldRef<"PrivacyPolicy", 'String'>
    readonly mailingAddress: FieldRef<"PrivacyPolicy", 'String'>
    readonly createdAt: FieldRef<"PrivacyPolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"PrivacyPolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrivacyPolicy findUnique
   */
  export type PrivacyPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicy to fetch.
     */
    where: PrivacyPolicyWhereUniqueInput
  }

  /**
   * PrivacyPolicy findUniqueOrThrow
   */
  export type PrivacyPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicy to fetch.
     */
    where: PrivacyPolicyWhereUniqueInput
  }

  /**
   * PrivacyPolicy findFirst
   */
  export type PrivacyPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicy to fetch.
     */
    where?: PrivacyPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyPolicies to fetch.
     */
    orderBy?: PrivacyPolicyOrderByWithRelationInput | PrivacyPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivacyPolicies.
     */
    cursor?: PrivacyPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivacyPolicies.
     */
    distinct?: PrivacyPolicyScalarFieldEnum | PrivacyPolicyScalarFieldEnum[]
  }

  /**
   * PrivacyPolicy findFirstOrThrow
   */
  export type PrivacyPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicy to fetch.
     */
    where?: PrivacyPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyPolicies to fetch.
     */
    orderBy?: PrivacyPolicyOrderByWithRelationInput | PrivacyPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivacyPolicies.
     */
    cursor?: PrivacyPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivacyPolicies.
     */
    distinct?: PrivacyPolicyScalarFieldEnum | PrivacyPolicyScalarFieldEnum[]
  }

  /**
   * PrivacyPolicy findMany
   */
  export type PrivacyPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicies to fetch.
     */
    where?: PrivacyPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyPolicies to fetch.
     */
    orderBy?: PrivacyPolicyOrderByWithRelationInput | PrivacyPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrivacyPolicies.
     */
    cursor?: PrivacyPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyPolicies.
     */
    skip?: number
    distinct?: PrivacyPolicyScalarFieldEnum | PrivacyPolicyScalarFieldEnum[]
  }

  /**
   * PrivacyPolicy create
   */
  export type PrivacyPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * The data needed to create a PrivacyPolicy.
     */
    data: XOR<PrivacyPolicyCreateInput, PrivacyPolicyUncheckedCreateInput>
  }

  /**
   * PrivacyPolicy createMany
   */
  export type PrivacyPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrivacyPolicies.
     */
    data: PrivacyPolicyCreateManyInput | PrivacyPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrivacyPolicy update
   */
  export type PrivacyPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * The data needed to update a PrivacyPolicy.
     */
    data: XOR<PrivacyPolicyUpdateInput, PrivacyPolicyUncheckedUpdateInput>
    /**
     * Choose, which PrivacyPolicy to update.
     */
    where: PrivacyPolicyWhereUniqueInput
  }

  /**
   * PrivacyPolicy updateMany
   */
  export type PrivacyPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrivacyPolicies.
     */
    data: XOR<PrivacyPolicyUpdateManyMutationInput, PrivacyPolicyUncheckedUpdateManyInput>
    /**
     * Filter which PrivacyPolicies to update
     */
    where?: PrivacyPolicyWhereInput
    /**
     * Limit how many PrivacyPolicies to update.
     */
    limit?: number
  }

  /**
   * PrivacyPolicy upsert
   */
  export type PrivacyPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * The filter to search for the PrivacyPolicy to update in case it exists.
     */
    where: PrivacyPolicyWhereUniqueInput
    /**
     * In case the PrivacyPolicy found by the `where` argument doesn't exist, create a new PrivacyPolicy with this data.
     */
    create: XOR<PrivacyPolicyCreateInput, PrivacyPolicyUncheckedCreateInput>
    /**
     * In case the PrivacyPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrivacyPolicyUpdateInput, PrivacyPolicyUncheckedUpdateInput>
  }

  /**
   * PrivacyPolicy delete
   */
  export type PrivacyPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter which PrivacyPolicy to delete.
     */
    where: PrivacyPolicyWhereUniqueInput
  }

  /**
   * PrivacyPolicy deleteMany
   */
  export type PrivacyPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivacyPolicies to delete
     */
    where?: PrivacyPolicyWhereInput
    /**
     * Limit how many PrivacyPolicies to delete.
     */
    limit?: number
  }

  /**
   * PrivacyPolicy without action
   */
  export type PrivacyPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
  }


  /**
   * Model TermsConditions
   */

  export type AggregateTermsConditions = {
    _count: TermsConditionsCountAggregateOutputType | null
    _avg: TermsConditionsAvgAggregateOutputType | null
    _sum: TermsConditionsSumAggregateOutputType | null
    _min: TermsConditionsMinAggregateOutputType | null
    _max: TermsConditionsMaxAggregateOutputType | null
  }

  export type TermsConditionsAvgAggregateOutputType = {
    id: number | null
  }

  export type TermsConditionsSumAggregateOutputType = {
    id: number | null
  }

  export type TermsConditionsMinAggregateOutputType = {
    id: number | null
    title: string | null
    subtitle: string | null
    email: string | null
    phone: string | null
    callingHours: string | null
    mailingAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TermsConditionsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    subtitle: string | null
    email: string | null
    phone: string | null
    callingHours: string | null
    mailingAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TermsConditionsCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    sections: number
    email: number
    phone: number
    callingHours: number
    mailingAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TermsConditionsAvgAggregateInputType = {
    id?: true
  }

  export type TermsConditionsSumAggregateInputType = {
    id?: true
  }

  export type TermsConditionsMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    email?: true
    phone?: true
    callingHours?: true
    mailingAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TermsConditionsMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    email?: true
    phone?: true
    callingHours?: true
    mailingAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TermsConditionsCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    sections?: true
    email?: true
    phone?: true
    callingHours?: true
    mailingAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TermsConditionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TermsConditions to aggregate.
     */
    where?: TermsConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermsConditions to fetch.
     */
    orderBy?: TermsConditionsOrderByWithRelationInput | TermsConditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TermsConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermsConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermsConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TermsConditions
    **/
    _count?: true | TermsConditionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TermsConditionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TermsConditionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TermsConditionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TermsConditionsMaxAggregateInputType
  }

  export type GetTermsConditionsAggregateType<T extends TermsConditionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTermsConditions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTermsConditions[P]>
      : GetScalarType<T[P], AggregateTermsConditions[P]>
  }




  export type TermsConditionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TermsConditionsWhereInput
    orderBy?: TermsConditionsOrderByWithAggregationInput | TermsConditionsOrderByWithAggregationInput[]
    by: TermsConditionsScalarFieldEnum[] | TermsConditionsScalarFieldEnum
    having?: TermsConditionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TermsConditionsCountAggregateInputType | true
    _avg?: TermsConditionsAvgAggregateInputType
    _sum?: TermsConditionsSumAggregateInputType
    _min?: TermsConditionsMinAggregateInputType
    _max?: TermsConditionsMaxAggregateInputType
  }

  export type TermsConditionsGroupByOutputType = {
    id: number
    title: string
    subtitle: string | null
    sections: JsonValue
    email: string | null
    phone: string | null
    callingHours: string | null
    mailingAddress: string | null
    createdAt: Date
    updatedAt: Date
    _count: TermsConditionsCountAggregateOutputType | null
    _avg: TermsConditionsAvgAggregateOutputType | null
    _sum: TermsConditionsSumAggregateOutputType | null
    _min: TermsConditionsMinAggregateOutputType | null
    _max: TermsConditionsMaxAggregateOutputType | null
  }

  type GetTermsConditionsGroupByPayload<T extends TermsConditionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TermsConditionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TermsConditionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TermsConditionsGroupByOutputType[P]>
            : GetScalarType<T[P], TermsConditionsGroupByOutputType[P]>
        }
      >
    >


  export type TermsConditionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    sections?: boolean
    email?: boolean
    phone?: boolean
    callingHours?: boolean
    mailingAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["termsConditions"]>



  export type TermsConditionsSelectScalar = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    sections?: boolean
    email?: boolean
    phone?: boolean
    callingHours?: boolean
    mailingAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TermsConditionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "subtitle" | "sections" | "email" | "phone" | "callingHours" | "mailingAddress" | "createdAt" | "updatedAt", ExtArgs["result"]["termsConditions"]>

  export type $TermsConditionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TermsConditions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      subtitle: string | null
      sections: Prisma.JsonValue
      email: string | null
      phone: string | null
      callingHours: string | null
      mailingAddress: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["termsConditions"]>
    composites: {}
  }

  type TermsConditionsGetPayload<S extends boolean | null | undefined | TermsConditionsDefaultArgs> = $Result.GetResult<Prisma.$TermsConditionsPayload, S>

  type TermsConditionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TermsConditionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TermsConditionsCountAggregateInputType | true
    }

  export interface TermsConditionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TermsConditions'], meta: { name: 'TermsConditions' } }
    /**
     * Find zero or one TermsConditions that matches the filter.
     * @param {TermsConditionsFindUniqueArgs} args - Arguments to find a TermsConditions
     * @example
     * // Get one TermsConditions
     * const termsConditions = await prisma.termsConditions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TermsConditionsFindUniqueArgs>(args: SelectSubset<T, TermsConditionsFindUniqueArgs<ExtArgs>>): Prisma__TermsConditionsClient<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TermsConditions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TermsConditionsFindUniqueOrThrowArgs} args - Arguments to find a TermsConditions
     * @example
     * // Get one TermsConditions
     * const termsConditions = await prisma.termsConditions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TermsConditionsFindUniqueOrThrowArgs>(args: SelectSubset<T, TermsConditionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TermsConditionsClient<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TermsConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionsFindFirstArgs} args - Arguments to find a TermsConditions
     * @example
     * // Get one TermsConditions
     * const termsConditions = await prisma.termsConditions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TermsConditionsFindFirstArgs>(args?: SelectSubset<T, TermsConditionsFindFirstArgs<ExtArgs>>): Prisma__TermsConditionsClient<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TermsConditions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionsFindFirstOrThrowArgs} args - Arguments to find a TermsConditions
     * @example
     * // Get one TermsConditions
     * const termsConditions = await prisma.termsConditions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TermsConditionsFindFirstOrThrowArgs>(args?: SelectSubset<T, TermsConditionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TermsConditionsClient<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TermsConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TermsConditions
     * const termsConditions = await prisma.termsConditions.findMany()
     * 
     * // Get first 10 TermsConditions
     * const termsConditions = await prisma.termsConditions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const termsConditionsWithIdOnly = await prisma.termsConditions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TermsConditionsFindManyArgs>(args?: SelectSubset<T, TermsConditionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TermsConditions.
     * @param {TermsConditionsCreateArgs} args - Arguments to create a TermsConditions.
     * @example
     * // Create one TermsConditions
     * const TermsConditions = await prisma.termsConditions.create({
     *   data: {
     *     // ... data to create a TermsConditions
     *   }
     * })
     * 
     */
    create<T extends TermsConditionsCreateArgs>(args: SelectSubset<T, TermsConditionsCreateArgs<ExtArgs>>): Prisma__TermsConditionsClient<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TermsConditions.
     * @param {TermsConditionsCreateManyArgs} args - Arguments to create many TermsConditions.
     * @example
     * // Create many TermsConditions
     * const termsConditions = await prisma.termsConditions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TermsConditionsCreateManyArgs>(args?: SelectSubset<T, TermsConditionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TermsConditions.
     * @param {TermsConditionsDeleteArgs} args - Arguments to delete one TermsConditions.
     * @example
     * // Delete one TermsConditions
     * const TermsConditions = await prisma.termsConditions.delete({
     *   where: {
     *     // ... filter to delete one TermsConditions
     *   }
     * })
     * 
     */
    delete<T extends TermsConditionsDeleteArgs>(args: SelectSubset<T, TermsConditionsDeleteArgs<ExtArgs>>): Prisma__TermsConditionsClient<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TermsConditions.
     * @param {TermsConditionsUpdateArgs} args - Arguments to update one TermsConditions.
     * @example
     * // Update one TermsConditions
     * const termsConditions = await prisma.termsConditions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TermsConditionsUpdateArgs>(args: SelectSubset<T, TermsConditionsUpdateArgs<ExtArgs>>): Prisma__TermsConditionsClient<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TermsConditions.
     * @param {TermsConditionsDeleteManyArgs} args - Arguments to filter TermsConditions to delete.
     * @example
     * // Delete a few TermsConditions
     * const { count } = await prisma.termsConditions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TermsConditionsDeleteManyArgs>(args?: SelectSubset<T, TermsConditionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TermsConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TermsConditions
     * const termsConditions = await prisma.termsConditions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TermsConditionsUpdateManyArgs>(args: SelectSubset<T, TermsConditionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TermsConditions.
     * @param {TermsConditionsUpsertArgs} args - Arguments to update or create a TermsConditions.
     * @example
     * // Update or create a TermsConditions
     * const termsConditions = await prisma.termsConditions.upsert({
     *   create: {
     *     // ... data to create a TermsConditions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TermsConditions we want to update
     *   }
     * })
     */
    upsert<T extends TermsConditionsUpsertArgs>(args: SelectSubset<T, TermsConditionsUpsertArgs<ExtArgs>>): Prisma__TermsConditionsClient<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TermsConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionsCountArgs} args - Arguments to filter TermsConditions to count.
     * @example
     * // Count the number of TermsConditions
     * const count = await prisma.termsConditions.count({
     *   where: {
     *     // ... the filter for the TermsConditions we want to count
     *   }
     * })
    **/
    count<T extends TermsConditionsCountArgs>(
      args?: Subset<T, TermsConditionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TermsConditionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TermsConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TermsConditionsAggregateArgs>(args: Subset<T, TermsConditionsAggregateArgs>): Prisma.PrismaPromise<GetTermsConditionsAggregateType<T>>

    /**
     * Group by TermsConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TermsConditionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TermsConditionsGroupByArgs['orderBy'] }
        : { orderBy?: TermsConditionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TermsConditionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTermsConditionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TermsConditions model
   */
  readonly fields: TermsConditionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TermsConditions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TermsConditionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TermsConditions model
   */
  interface TermsConditionsFieldRefs {
    readonly id: FieldRef<"TermsConditions", 'Int'>
    readonly title: FieldRef<"TermsConditions", 'String'>
    readonly subtitle: FieldRef<"TermsConditions", 'String'>
    readonly sections: FieldRef<"TermsConditions", 'Json'>
    readonly email: FieldRef<"TermsConditions", 'String'>
    readonly phone: FieldRef<"TermsConditions", 'String'>
    readonly callingHours: FieldRef<"TermsConditions", 'String'>
    readonly mailingAddress: FieldRef<"TermsConditions", 'String'>
    readonly createdAt: FieldRef<"TermsConditions", 'DateTime'>
    readonly updatedAt: FieldRef<"TermsConditions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TermsConditions findUnique
   */
  export type TermsConditionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * Filter, which TermsConditions to fetch.
     */
    where: TermsConditionsWhereUniqueInput
  }

  /**
   * TermsConditions findUniqueOrThrow
   */
  export type TermsConditionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * Filter, which TermsConditions to fetch.
     */
    where: TermsConditionsWhereUniqueInput
  }

  /**
   * TermsConditions findFirst
   */
  export type TermsConditionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * Filter, which TermsConditions to fetch.
     */
    where?: TermsConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermsConditions to fetch.
     */
    orderBy?: TermsConditionsOrderByWithRelationInput | TermsConditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TermsConditions.
     */
    cursor?: TermsConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermsConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermsConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TermsConditions.
     */
    distinct?: TermsConditionsScalarFieldEnum | TermsConditionsScalarFieldEnum[]
  }

  /**
   * TermsConditions findFirstOrThrow
   */
  export type TermsConditionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * Filter, which TermsConditions to fetch.
     */
    where?: TermsConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermsConditions to fetch.
     */
    orderBy?: TermsConditionsOrderByWithRelationInput | TermsConditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TermsConditions.
     */
    cursor?: TermsConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermsConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermsConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TermsConditions.
     */
    distinct?: TermsConditionsScalarFieldEnum | TermsConditionsScalarFieldEnum[]
  }

  /**
   * TermsConditions findMany
   */
  export type TermsConditionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * Filter, which TermsConditions to fetch.
     */
    where?: TermsConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermsConditions to fetch.
     */
    orderBy?: TermsConditionsOrderByWithRelationInput | TermsConditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TermsConditions.
     */
    cursor?: TermsConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermsConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermsConditions.
     */
    skip?: number
    distinct?: TermsConditionsScalarFieldEnum | TermsConditionsScalarFieldEnum[]
  }

  /**
   * TermsConditions create
   */
  export type TermsConditionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * The data needed to create a TermsConditions.
     */
    data: XOR<TermsConditionsCreateInput, TermsConditionsUncheckedCreateInput>
  }

  /**
   * TermsConditions createMany
   */
  export type TermsConditionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TermsConditions.
     */
    data: TermsConditionsCreateManyInput | TermsConditionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TermsConditions update
   */
  export type TermsConditionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * The data needed to update a TermsConditions.
     */
    data: XOR<TermsConditionsUpdateInput, TermsConditionsUncheckedUpdateInput>
    /**
     * Choose, which TermsConditions to update.
     */
    where: TermsConditionsWhereUniqueInput
  }

  /**
   * TermsConditions updateMany
   */
  export type TermsConditionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TermsConditions.
     */
    data: XOR<TermsConditionsUpdateManyMutationInput, TermsConditionsUncheckedUpdateManyInput>
    /**
     * Filter which TermsConditions to update
     */
    where?: TermsConditionsWhereInput
    /**
     * Limit how many TermsConditions to update.
     */
    limit?: number
  }

  /**
   * TermsConditions upsert
   */
  export type TermsConditionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * The filter to search for the TermsConditions to update in case it exists.
     */
    where: TermsConditionsWhereUniqueInput
    /**
     * In case the TermsConditions found by the `where` argument doesn't exist, create a new TermsConditions with this data.
     */
    create: XOR<TermsConditionsCreateInput, TermsConditionsUncheckedCreateInput>
    /**
     * In case the TermsConditions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TermsConditionsUpdateInput, TermsConditionsUncheckedUpdateInput>
  }

  /**
   * TermsConditions delete
   */
  export type TermsConditionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * Filter which TermsConditions to delete.
     */
    where: TermsConditionsWhereUniqueInput
  }

  /**
   * TermsConditions deleteMany
   */
  export type TermsConditionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TermsConditions to delete
     */
    where?: TermsConditionsWhereInput
    /**
     * Limit how many TermsConditions to delete.
     */
    limit?: number
  }

  /**
   * TermsConditions without action
   */
  export type TermsConditionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
  }


  /**
   * Model Banner
   */

  export type AggregateBanner = {
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  export type BannerAvgAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type BannerSumAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type BannerMinAggregateOutputType = {
    id: number | null
    title: string | null
    image: string | null
    active: boolean | null
    order: number | null
    publicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerMaxAggregateOutputType = {
    id: number | null
    title: string | null
    image: string | null
    active: boolean | null
    order: number | null
    publicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerCountAggregateOutputType = {
    id: number
    title: number
    image: number
    active: number
    order: number
    publicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BannerAvgAggregateInputType = {
    id?: true
    order?: true
  }

  export type BannerSumAggregateInputType = {
    id?: true
    order?: true
  }

  export type BannerMinAggregateInputType = {
    id?: true
    title?: true
    image?: true
    active?: true
    order?: true
    publicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerMaxAggregateInputType = {
    id?: true
    title?: true
    image?: true
    active?: true
    order?: true
    publicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerCountAggregateInputType = {
    id?: true
    title?: true
    image?: true
    active?: true
    order?: true
    publicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banner to aggregate.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banners
    **/
    _count?: true | BannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerMaxAggregateInputType
  }

  export type GetBannerAggregateType<T extends BannerAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner[P]>
      : GetScalarType<T[P], AggregateBanner[P]>
  }




  export type BannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithAggregationInput | BannerOrderByWithAggregationInput[]
    by: BannerScalarFieldEnum[] | BannerScalarFieldEnum
    having?: BannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerCountAggregateInputType | true
    _avg?: BannerAvgAggregateInputType
    _sum?: BannerSumAggregateInputType
    _min?: BannerMinAggregateInputType
    _max?: BannerMaxAggregateInputType
  }

  export type BannerGroupByOutputType = {
    id: number
    title: string
    image: string
    active: boolean
    order: number
    publicId: string
    createdAt: Date
    updatedAt: Date
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  type GetBannerGroupByPayload<T extends BannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerGroupByOutputType[P]>
            : GetScalarType<T[P], BannerGroupByOutputType[P]>
        }
      >
    >


  export type BannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    image?: boolean
    active?: boolean
    order?: boolean
    publicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["banner"]>



  export type BannerSelectScalar = {
    id?: boolean
    title?: boolean
    image?: boolean
    active?: boolean
    order?: boolean
    publicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BannerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "image" | "active" | "order" | "publicId" | "createdAt" | "updatedAt", ExtArgs["result"]["banner"]>

  export type $BannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Banner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      image: string
      active: boolean
      order: number
      publicId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["banner"]>
    composites: {}
  }

  type BannerGetPayload<S extends boolean | null | undefined | BannerDefaultArgs> = $Result.GetResult<Prisma.$BannerPayload, S>

  type BannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BannerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerCountAggregateInputType | true
    }

  export interface BannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Banner'], meta: { name: 'Banner' } }
    /**
     * Find zero or one Banner that matches the filter.
     * @param {BannerFindUniqueArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerFindUniqueArgs>(args: SelectSubset<T, BannerFindUniqueArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Banner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerFindUniqueOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerFindFirstArgs>(args?: SelectSubset<T, BannerFindFirstArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banner.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerWithIdOnly = await prisma.banner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerFindManyArgs>(args?: SelectSubset<T, BannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Banner.
     * @param {BannerCreateArgs} args - Arguments to create a Banner.
     * @example
     * // Create one Banner
     * const Banner = await prisma.banner.create({
     *   data: {
     *     // ... data to create a Banner
     *   }
     * })
     * 
     */
    create<T extends BannerCreateArgs>(args: SelectSubset<T, BannerCreateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Banners.
     * @param {BannerCreateManyArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerCreateManyArgs>(args?: SelectSubset<T, BannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Banner.
     * @param {BannerDeleteArgs} args - Arguments to delete one Banner.
     * @example
     * // Delete one Banner
     * const Banner = await prisma.banner.delete({
     *   where: {
     *     // ... filter to delete one Banner
     *   }
     * })
     * 
     */
    delete<T extends BannerDeleteArgs>(args: SelectSubset<T, BannerDeleteArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Banner.
     * @param {BannerUpdateArgs} args - Arguments to update one Banner.
     * @example
     * // Update one Banner
     * const banner = await prisma.banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerUpdateArgs>(args: SelectSubset<T, BannerUpdateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Banners.
     * @param {BannerDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerDeleteManyArgs>(args?: SelectSubset<T, BannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerUpdateManyArgs>(args: SelectSubset<T, BannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banner.
     * @param {BannerUpsertArgs} args - Arguments to update or create a Banner.
     * @example
     * // Update or create a Banner
     * const banner = await prisma.banner.upsert({
     *   create: {
     *     // ... data to create a Banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner we want to update
     *   }
     * })
     */
    upsert<T extends BannerUpsertArgs>(args: SelectSubset<T, BannerUpsertArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banner.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends BannerCountArgs>(
      args?: Subset<T, BannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerAggregateArgs>(args: Subset<T, BannerAggregateArgs>): Prisma.PrismaPromise<GetBannerAggregateType<T>>

    /**
     * Group by Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerGroupByArgs['orderBy'] }
        : { orderBy?: BannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Banner model
   */
  readonly fields: BannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Banner model
   */
  interface BannerFieldRefs {
    readonly id: FieldRef<"Banner", 'Int'>
    readonly title: FieldRef<"Banner", 'String'>
    readonly image: FieldRef<"Banner", 'String'>
    readonly active: FieldRef<"Banner", 'Boolean'>
    readonly order: FieldRef<"Banner", 'Int'>
    readonly publicId: FieldRef<"Banner", 'String'>
    readonly createdAt: FieldRef<"Banner", 'DateTime'>
    readonly updatedAt: FieldRef<"Banner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Banner findUnique
   */
  export type BannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findUniqueOrThrow
   */
  export type BannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findFirst
   */
  export type BannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findFirstOrThrow
   */
  export type BannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findMany
   */
  export type BannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banners to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner create
   */
  export type BannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data needed to create a Banner.
     */
    data: XOR<BannerCreateInput, BannerUncheckedCreateInput>
  }

  /**
   * Banner createMany
   */
  export type BannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banner update
   */
  export type BannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data needed to update a Banner.
     */
    data: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
    /**
     * Choose, which Banner to update.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner updateMany
   */
  export type BannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to update.
     */
    limit?: number
  }

  /**
   * Banner upsert
   */
  export type BannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The filter to search for the Banner to update in case it exists.
     */
    where: BannerWhereUniqueInput
    /**
     * In case the Banner found by the `where` argument doesn't exist, create a new Banner with this data.
     */
    create: XOR<BannerCreateInput, BannerUncheckedCreateInput>
    /**
     * In case the Banner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
  }

  /**
   * Banner delete
   */
  export type BannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter which Banner to delete.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner deleteMany
   */
  export type BannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banners to delete
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to delete.
     */
    limit?: number
  }

  /**
   * Banner without action
   */
  export type BannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    info: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    info: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    info: number
    createdAt: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    info?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    info?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    info?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: number
    info: string
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    info?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["message"]>



  export type MessageSelectScalar = {
    id?: boolean
    info?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "info" | "createdAt", ExtArgs["result"]["message"]>

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      info: string
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'Int'>
    readonly info: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
  }


  /**
   * Model Foundation
   */

  export type AggregateFoundation = {
    _count: FoundationCountAggregateOutputType | null
    _avg: FoundationAvgAggregateOutputType | null
    _sum: FoundationSumAggregateOutputType | null
    _min: FoundationMinAggregateOutputType | null
    _max: FoundationMaxAggregateOutputType | null
  }

  export type FoundationAvgAggregateOutputType = {
    id: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type FoundationSumAggregateOutputType = {
    id: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type FoundationMinAggregateOutputType = {
    id: number | null
    name: string | null
    tagline: string | null
    logoUrl: string | null
    description: string | null
    establishedYear: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
    updatedById: number | null
  }

  export type FoundationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    tagline: string | null
    logoUrl: string | null
    description: string | null
    establishedYear: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
    updatedById: number | null
  }

  export type FoundationCountAggregateOutputType = {
    id: number
    name: number
    tagline: number
    logoUrl: number
    description: number
    establishedYear: number
    isActive: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    _all: number
  }


  export type FoundationAvgAggregateInputType = {
    id?: true
    createdById?: true
    updatedById?: true
  }

  export type FoundationSumAggregateInputType = {
    id?: true
    createdById?: true
    updatedById?: true
  }

  export type FoundationMinAggregateInputType = {
    id?: true
    name?: true
    tagline?: true
    logoUrl?: true
    description?: true
    establishedYear?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type FoundationMaxAggregateInputType = {
    id?: true
    name?: true
    tagline?: true
    logoUrl?: true
    description?: true
    establishedYear?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type FoundationCountAggregateInputType = {
    id?: true
    name?: true
    tagline?: true
    logoUrl?: true
    description?: true
    establishedYear?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    _all?: true
  }

  export type FoundationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Foundation to aggregate.
     */
    where?: FoundationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foundations to fetch.
     */
    orderBy?: FoundationOrderByWithRelationInput | FoundationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoundationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foundations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foundations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Foundations
    **/
    _count?: true | FoundationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoundationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoundationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoundationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoundationMaxAggregateInputType
  }

  export type GetFoundationAggregateType<T extends FoundationAggregateArgs> = {
        [P in keyof T & keyof AggregateFoundation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoundation[P]>
      : GetScalarType<T[P], AggregateFoundation[P]>
  }




  export type FoundationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationWhereInput
    orderBy?: FoundationOrderByWithAggregationInput | FoundationOrderByWithAggregationInput[]
    by: FoundationScalarFieldEnum[] | FoundationScalarFieldEnum
    having?: FoundationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoundationCountAggregateInputType | true
    _avg?: FoundationAvgAggregateInputType
    _sum?: FoundationSumAggregateInputType
    _min?: FoundationMinAggregateInputType
    _max?: FoundationMaxAggregateInputType
  }

  export type FoundationGroupByOutputType = {
    id: number
    name: string
    tagline: string | null
    logoUrl: string | null
    description: string | null
    establishedYear: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    createdById: number | null
    updatedById: number | null
    _count: FoundationCountAggregateOutputType | null
    _avg: FoundationAvgAggregateOutputType | null
    _sum: FoundationSumAggregateOutputType | null
    _min: FoundationMinAggregateOutputType | null
    _max: FoundationMaxAggregateOutputType | null
  }

  type GetFoundationGroupByPayload<T extends FoundationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoundationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoundationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoundationGroupByOutputType[P]>
            : GetScalarType<T[P], FoundationGroupByOutputType[P]>
        }
      >
    >


  export type FoundationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tagline?: boolean
    logoUrl?: boolean
    description?: boolean
    establishedYear?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    stats?: boolean | Foundation$statsArgs<ExtArgs>
    activities?: boolean | Foundation$activitiesArgs<ExtArgs>
    objectives?: boolean | Foundation$objectivesArgs<ExtArgs>
    contact?: boolean | Foundation$contactArgs<ExtArgs>
    media?: boolean | Foundation$mediaArgs<ExtArgs>
    _count?: boolean | FoundationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foundation"]>



  export type FoundationSelectScalar = {
    id?: boolean
    name?: boolean
    tagline?: boolean
    logoUrl?: boolean
    description?: boolean
    establishedYear?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
  }

  export type FoundationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "tagline" | "logoUrl" | "description" | "establishedYear" | "isActive" | "createdAt" | "updatedAt" | "createdById" | "updatedById", ExtArgs["result"]["foundation"]>
  export type FoundationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stats?: boolean | Foundation$statsArgs<ExtArgs>
    activities?: boolean | Foundation$activitiesArgs<ExtArgs>
    objectives?: boolean | Foundation$objectivesArgs<ExtArgs>
    contact?: boolean | Foundation$contactArgs<ExtArgs>
    media?: boolean | Foundation$mediaArgs<ExtArgs>
    _count?: boolean | FoundationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FoundationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Foundation"
    objects: {
      stats: Prisma.$FoundationStatPayload<ExtArgs>[]
      activities: Prisma.$FoundationActivityPayload<ExtArgs>[]
      objectives: Prisma.$FoundationObjectivePayload<ExtArgs>[]
      contact: Prisma.$FoundationContactPayload<ExtArgs> | null
      media: Prisma.$FoundationMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      tagline: string | null
      logoUrl: string | null
      description: string | null
      establishedYear: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      createdById: number | null
      updatedById: number | null
    }, ExtArgs["result"]["foundation"]>
    composites: {}
  }

  type FoundationGetPayload<S extends boolean | null | undefined | FoundationDefaultArgs> = $Result.GetResult<Prisma.$FoundationPayload, S>

  type FoundationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoundationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoundationCountAggregateInputType | true
    }

  export interface FoundationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Foundation'], meta: { name: 'Foundation' } }
    /**
     * Find zero or one Foundation that matches the filter.
     * @param {FoundationFindUniqueArgs} args - Arguments to find a Foundation
     * @example
     * // Get one Foundation
     * const foundation = await prisma.foundation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoundationFindUniqueArgs>(args: SelectSubset<T, FoundationFindUniqueArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Foundation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoundationFindUniqueOrThrowArgs} args - Arguments to find a Foundation
     * @example
     * // Get one Foundation
     * const foundation = await prisma.foundation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoundationFindUniqueOrThrowArgs>(args: SelectSubset<T, FoundationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Foundation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationFindFirstArgs} args - Arguments to find a Foundation
     * @example
     * // Get one Foundation
     * const foundation = await prisma.foundation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoundationFindFirstArgs>(args?: SelectSubset<T, FoundationFindFirstArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Foundation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationFindFirstOrThrowArgs} args - Arguments to find a Foundation
     * @example
     * // Get one Foundation
     * const foundation = await prisma.foundation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoundationFindFirstOrThrowArgs>(args?: SelectSubset<T, FoundationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Foundations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Foundations
     * const foundations = await prisma.foundation.findMany()
     * 
     * // Get first 10 Foundations
     * const foundations = await prisma.foundation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foundationWithIdOnly = await prisma.foundation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoundationFindManyArgs>(args?: SelectSubset<T, FoundationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Foundation.
     * @param {FoundationCreateArgs} args - Arguments to create a Foundation.
     * @example
     * // Create one Foundation
     * const Foundation = await prisma.foundation.create({
     *   data: {
     *     // ... data to create a Foundation
     *   }
     * })
     * 
     */
    create<T extends FoundationCreateArgs>(args: SelectSubset<T, FoundationCreateArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Foundations.
     * @param {FoundationCreateManyArgs} args - Arguments to create many Foundations.
     * @example
     * // Create many Foundations
     * const foundation = await prisma.foundation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoundationCreateManyArgs>(args?: SelectSubset<T, FoundationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Foundation.
     * @param {FoundationDeleteArgs} args - Arguments to delete one Foundation.
     * @example
     * // Delete one Foundation
     * const Foundation = await prisma.foundation.delete({
     *   where: {
     *     // ... filter to delete one Foundation
     *   }
     * })
     * 
     */
    delete<T extends FoundationDeleteArgs>(args: SelectSubset<T, FoundationDeleteArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Foundation.
     * @param {FoundationUpdateArgs} args - Arguments to update one Foundation.
     * @example
     * // Update one Foundation
     * const foundation = await prisma.foundation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoundationUpdateArgs>(args: SelectSubset<T, FoundationUpdateArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Foundations.
     * @param {FoundationDeleteManyArgs} args - Arguments to filter Foundations to delete.
     * @example
     * // Delete a few Foundations
     * const { count } = await prisma.foundation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoundationDeleteManyArgs>(args?: SelectSubset<T, FoundationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Foundations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Foundations
     * const foundation = await prisma.foundation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoundationUpdateManyArgs>(args: SelectSubset<T, FoundationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Foundation.
     * @param {FoundationUpsertArgs} args - Arguments to update or create a Foundation.
     * @example
     * // Update or create a Foundation
     * const foundation = await prisma.foundation.upsert({
     *   create: {
     *     // ... data to create a Foundation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Foundation we want to update
     *   }
     * })
     */
    upsert<T extends FoundationUpsertArgs>(args: SelectSubset<T, FoundationUpsertArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Foundations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationCountArgs} args - Arguments to filter Foundations to count.
     * @example
     * // Count the number of Foundations
     * const count = await prisma.foundation.count({
     *   where: {
     *     // ... the filter for the Foundations we want to count
     *   }
     * })
    **/
    count<T extends FoundationCountArgs>(
      args?: Subset<T, FoundationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoundationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Foundation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoundationAggregateArgs>(args: Subset<T, FoundationAggregateArgs>): Prisma.PrismaPromise<GetFoundationAggregateType<T>>

    /**
     * Group by Foundation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoundationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoundationGroupByArgs['orderBy'] }
        : { orderBy?: FoundationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoundationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoundationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Foundation model
   */
  readonly fields: FoundationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Foundation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoundationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stats<T extends Foundation$statsArgs<ExtArgs> = {}>(args?: Subset<T, Foundation$statsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends Foundation$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Foundation$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    objectives<T extends Foundation$objectivesArgs<ExtArgs> = {}>(args?: Subset<T, Foundation$objectivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contact<T extends Foundation$contactArgs<ExtArgs> = {}>(args?: Subset<T, Foundation$contactArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    media<T extends Foundation$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Foundation$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Foundation model
   */
  interface FoundationFieldRefs {
    readonly id: FieldRef<"Foundation", 'Int'>
    readonly name: FieldRef<"Foundation", 'String'>
    readonly tagline: FieldRef<"Foundation", 'String'>
    readonly logoUrl: FieldRef<"Foundation", 'String'>
    readonly description: FieldRef<"Foundation", 'String'>
    readonly establishedYear: FieldRef<"Foundation", 'String'>
    readonly isActive: FieldRef<"Foundation", 'Boolean'>
    readonly createdAt: FieldRef<"Foundation", 'DateTime'>
    readonly updatedAt: FieldRef<"Foundation", 'DateTime'>
    readonly createdById: FieldRef<"Foundation", 'Int'>
    readonly updatedById: FieldRef<"Foundation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Foundation findUnique
   */
  export type FoundationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * Filter, which Foundation to fetch.
     */
    where: FoundationWhereUniqueInput
  }

  /**
   * Foundation findUniqueOrThrow
   */
  export type FoundationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * Filter, which Foundation to fetch.
     */
    where: FoundationWhereUniqueInput
  }

  /**
   * Foundation findFirst
   */
  export type FoundationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * Filter, which Foundation to fetch.
     */
    where?: FoundationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foundations to fetch.
     */
    orderBy?: FoundationOrderByWithRelationInput | FoundationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foundations.
     */
    cursor?: FoundationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foundations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foundations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Foundations.
     */
    distinct?: FoundationScalarFieldEnum | FoundationScalarFieldEnum[]
  }

  /**
   * Foundation findFirstOrThrow
   */
  export type FoundationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * Filter, which Foundation to fetch.
     */
    where?: FoundationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foundations to fetch.
     */
    orderBy?: FoundationOrderByWithRelationInput | FoundationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foundations.
     */
    cursor?: FoundationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foundations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foundations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Foundations.
     */
    distinct?: FoundationScalarFieldEnum | FoundationScalarFieldEnum[]
  }

  /**
   * Foundation findMany
   */
  export type FoundationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * Filter, which Foundations to fetch.
     */
    where?: FoundationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foundations to fetch.
     */
    orderBy?: FoundationOrderByWithRelationInput | FoundationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Foundations.
     */
    cursor?: FoundationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foundations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foundations.
     */
    skip?: number
    distinct?: FoundationScalarFieldEnum | FoundationScalarFieldEnum[]
  }

  /**
   * Foundation create
   */
  export type FoundationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * The data needed to create a Foundation.
     */
    data: XOR<FoundationCreateInput, FoundationUncheckedCreateInput>
  }

  /**
   * Foundation createMany
   */
  export type FoundationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Foundations.
     */
    data: FoundationCreateManyInput | FoundationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Foundation update
   */
  export type FoundationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * The data needed to update a Foundation.
     */
    data: XOR<FoundationUpdateInput, FoundationUncheckedUpdateInput>
    /**
     * Choose, which Foundation to update.
     */
    where: FoundationWhereUniqueInput
  }

  /**
   * Foundation updateMany
   */
  export type FoundationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Foundations.
     */
    data: XOR<FoundationUpdateManyMutationInput, FoundationUncheckedUpdateManyInput>
    /**
     * Filter which Foundations to update
     */
    where?: FoundationWhereInput
    /**
     * Limit how many Foundations to update.
     */
    limit?: number
  }

  /**
   * Foundation upsert
   */
  export type FoundationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * The filter to search for the Foundation to update in case it exists.
     */
    where: FoundationWhereUniqueInput
    /**
     * In case the Foundation found by the `where` argument doesn't exist, create a new Foundation with this data.
     */
    create: XOR<FoundationCreateInput, FoundationUncheckedCreateInput>
    /**
     * In case the Foundation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoundationUpdateInput, FoundationUncheckedUpdateInput>
  }

  /**
   * Foundation delete
   */
  export type FoundationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * Filter which Foundation to delete.
     */
    where: FoundationWhereUniqueInput
  }

  /**
   * Foundation deleteMany
   */
  export type FoundationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Foundations to delete
     */
    where?: FoundationWhereInput
    /**
     * Limit how many Foundations to delete.
     */
    limit?: number
  }

  /**
   * Foundation.stats
   */
  export type Foundation$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    where?: FoundationStatWhereInput
    orderBy?: FoundationStatOrderByWithRelationInput | FoundationStatOrderByWithRelationInput[]
    cursor?: FoundationStatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoundationStatScalarFieldEnum | FoundationStatScalarFieldEnum[]
  }

  /**
   * Foundation.activities
   */
  export type Foundation$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    where?: FoundationActivityWhereInput
    orderBy?: FoundationActivityOrderByWithRelationInput | FoundationActivityOrderByWithRelationInput[]
    cursor?: FoundationActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoundationActivityScalarFieldEnum | FoundationActivityScalarFieldEnum[]
  }

  /**
   * Foundation.objectives
   */
  export type Foundation$objectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    where?: FoundationObjectiveWhereInput
    orderBy?: FoundationObjectiveOrderByWithRelationInput | FoundationObjectiveOrderByWithRelationInput[]
    cursor?: FoundationObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoundationObjectiveScalarFieldEnum | FoundationObjectiveScalarFieldEnum[]
  }

  /**
   * Foundation.contact
   */
  export type Foundation$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    where?: FoundationContactWhereInput
  }

  /**
   * Foundation.media
   */
  export type Foundation$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    where?: FoundationMediaWhereInput
    orderBy?: FoundationMediaOrderByWithRelationInput | FoundationMediaOrderByWithRelationInput[]
    cursor?: FoundationMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoundationMediaScalarFieldEnum | FoundationMediaScalarFieldEnum[]
  }

  /**
   * Foundation without action
   */
  export type FoundationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
  }


  /**
   * Model FoundationStat
   */

  export type AggregateFoundationStat = {
    _count: FoundationStatCountAggregateOutputType | null
    _avg: FoundationStatAvgAggregateOutputType | null
    _sum: FoundationStatSumAggregateOutputType | null
    _min: FoundationStatMinAggregateOutputType | null
    _max: FoundationStatMaxAggregateOutputType | null
  }

  export type FoundationStatAvgAggregateOutputType = {
    id: number | null
    foundationId: number | null
    displayOrder: number | null
  }

  export type FoundationStatSumAggregateOutputType = {
    id: number | null
    foundationId: number | null
    displayOrder: number | null
  }

  export type FoundationStatMinAggregateOutputType = {
    id: number | null
    foundationId: number | null
    label: string | null
    value: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoundationStatMaxAggregateOutputType = {
    id: number | null
    foundationId: number | null
    label: string | null
    value: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoundationStatCountAggregateOutputType = {
    id: number
    foundationId: number
    label: number
    value: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoundationStatAvgAggregateInputType = {
    id?: true
    foundationId?: true
    displayOrder?: true
  }

  export type FoundationStatSumAggregateInputType = {
    id?: true
    foundationId?: true
    displayOrder?: true
  }

  export type FoundationStatMinAggregateInputType = {
    id?: true
    foundationId?: true
    label?: true
    value?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoundationStatMaxAggregateInputType = {
    id?: true
    foundationId?: true
    label?: true
    value?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoundationStatCountAggregateInputType = {
    id?: true
    foundationId?: true
    label?: true
    value?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoundationStatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationStat to aggregate.
     */
    where?: FoundationStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationStats to fetch.
     */
    orderBy?: FoundationStatOrderByWithRelationInput | FoundationStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoundationStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoundationStats
    **/
    _count?: true | FoundationStatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoundationStatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoundationStatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoundationStatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoundationStatMaxAggregateInputType
  }

  export type GetFoundationStatAggregateType<T extends FoundationStatAggregateArgs> = {
        [P in keyof T & keyof AggregateFoundationStat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoundationStat[P]>
      : GetScalarType<T[P], AggregateFoundationStat[P]>
  }




  export type FoundationStatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationStatWhereInput
    orderBy?: FoundationStatOrderByWithAggregationInput | FoundationStatOrderByWithAggregationInput[]
    by: FoundationStatScalarFieldEnum[] | FoundationStatScalarFieldEnum
    having?: FoundationStatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoundationStatCountAggregateInputType | true
    _avg?: FoundationStatAvgAggregateInputType
    _sum?: FoundationStatSumAggregateInputType
    _min?: FoundationStatMinAggregateInputType
    _max?: FoundationStatMaxAggregateInputType
  }

  export type FoundationStatGroupByOutputType = {
    id: number
    foundationId: number
    label: string
    value: string
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: FoundationStatCountAggregateOutputType | null
    _avg: FoundationStatAvgAggregateOutputType | null
    _sum: FoundationStatSumAggregateOutputType | null
    _min: FoundationStatMinAggregateOutputType | null
    _max: FoundationStatMaxAggregateOutputType | null
  }

  type GetFoundationStatGroupByPayload<T extends FoundationStatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoundationStatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoundationStatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoundationStatGroupByOutputType[P]>
            : GetScalarType<T[P], FoundationStatGroupByOutputType[P]>
        }
      >
    >


  export type FoundationStatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foundationId?: boolean
    label?: boolean
    value?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    foundation?: boolean | FoundationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foundationStat"]>



  export type FoundationStatSelectScalar = {
    id?: boolean
    foundationId?: boolean
    label?: boolean
    value?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoundationStatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "foundationId" | "label" | "value" | "displayOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["foundationStat"]>
  export type FoundationStatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foundation?: boolean | FoundationDefaultArgs<ExtArgs>
  }

  export type $FoundationStatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoundationStat"
    objects: {
      foundation: Prisma.$FoundationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      foundationId: number
      label: string
      value: string
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foundationStat"]>
    composites: {}
  }

  type FoundationStatGetPayload<S extends boolean | null | undefined | FoundationStatDefaultArgs> = $Result.GetResult<Prisma.$FoundationStatPayload, S>

  type FoundationStatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoundationStatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoundationStatCountAggregateInputType | true
    }

  export interface FoundationStatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoundationStat'], meta: { name: 'FoundationStat' } }
    /**
     * Find zero or one FoundationStat that matches the filter.
     * @param {FoundationStatFindUniqueArgs} args - Arguments to find a FoundationStat
     * @example
     * // Get one FoundationStat
     * const foundationStat = await prisma.foundationStat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoundationStatFindUniqueArgs>(args: SelectSubset<T, FoundationStatFindUniqueArgs<ExtArgs>>): Prisma__FoundationStatClient<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoundationStat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoundationStatFindUniqueOrThrowArgs} args - Arguments to find a FoundationStat
     * @example
     * // Get one FoundationStat
     * const foundationStat = await prisma.foundationStat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoundationStatFindUniqueOrThrowArgs>(args: SelectSubset<T, FoundationStatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoundationStatClient<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationStat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationStatFindFirstArgs} args - Arguments to find a FoundationStat
     * @example
     * // Get one FoundationStat
     * const foundationStat = await prisma.foundationStat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoundationStatFindFirstArgs>(args?: SelectSubset<T, FoundationStatFindFirstArgs<ExtArgs>>): Prisma__FoundationStatClient<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationStat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationStatFindFirstOrThrowArgs} args - Arguments to find a FoundationStat
     * @example
     * // Get one FoundationStat
     * const foundationStat = await prisma.foundationStat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoundationStatFindFirstOrThrowArgs>(args?: SelectSubset<T, FoundationStatFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoundationStatClient<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoundationStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationStatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoundationStats
     * const foundationStats = await prisma.foundationStat.findMany()
     * 
     * // Get first 10 FoundationStats
     * const foundationStats = await prisma.foundationStat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foundationStatWithIdOnly = await prisma.foundationStat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoundationStatFindManyArgs>(args?: SelectSubset<T, FoundationStatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoundationStat.
     * @param {FoundationStatCreateArgs} args - Arguments to create a FoundationStat.
     * @example
     * // Create one FoundationStat
     * const FoundationStat = await prisma.foundationStat.create({
     *   data: {
     *     // ... data to create a FoundationStat
     *   }
     * })
     * 
     */
    create<T extends FoundationStatCreateArgs>(args: SelectSubset<T, FoundationStatCreateArgs<ExtArgs>>): Prisma__FoundationStatClient<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoundationStats.
     * @param {FoundationStatCreateManyArgs} args - Arguments to create many FoundationStats.
     * @example
     * // Create many FoundationStats
     * const foundationStat = await prisma.foundationStat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoundationStatCreateManyArgs>(args?: SelectSubset<T, FoundationStatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FoundationStat.
     * @param {FoundationStatDeleteArgs} args - Arguments to delete one FoundationStat.
     * @example
     * // Delete one FoundationStat
     * const FoundationStat = await prisma.foundationStat.delete({
     *   where: {
     *     // ... filter to delete one FoundationStat
     *   }
     * })
     * 
     */
    delete<T extends FoundationStatDeleteArgs>(args: SelectSubset<T, FoundationStatDeleteArgs<ExtArgs>>): Prisma__FoundationStatClient<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoundationStat.
     * @param {FoundationStatUpdateArgs} args - Arguments to update one FoundationStat.
     * @example
     * // Update one FoundationStat
     * const foundationStat = await prisma.foundationStat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoundationStatUpdateArgs>(args: SelectSubset<T, FoundationStatUpdateArgs<ExtArgs>>): Prisma__FoundationStatClient<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoundationStats.
     * @param {FoundationStatDeleteManyArgs} args - Arguments to filter FoundationStats to delete.
     * @example
     * // Delete a few FoundationStats
     * const { count } = await prisma.foundationStat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoundationStatDeleteManyArgs>(args?: SelectSubset<T, FoundationStatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoundationStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationStatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoundationStats
     * const foundationStat = await prisma.foundationStat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoundationStatUpdateManyArgs>(args: SelectSubset<T, FoundationStatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoundationStat.
     * @param {FoundationStatUpsertArgs} args - Arguments to update or create a FoundationStat.
     * @example
     * // Update or create a FoundationStat
     * const foundationStat = await prisma.foundationStat.upsert({
     *   create: {
     *     // ... data to create a FoundationStat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoundationStat we want to update
     *   }
     * })
     */
    upsert<T extends FoundationStatUpsertArgs>(args: SelectSubset<T, FoundationStatUpsertArgs<ExtArgs>>): Prisma__FoundationStatClient<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoundationStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationStatCountArgs} args - Arguments to filter FoundationStats to count.
     * @example
     * // Count the number of FoundationStats
     * const count = await prisma.foundationStat.count({
     *   where: {
     *     // ... the filter for the FoundationStats we want to count
     *   }
     * })
    **/
    count<T extends FoundationStatCountArgs>(
      args?: Subset<T, FoundationStatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoundationStatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoundationStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationStatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoundationStatAggregateArgs>(args: Subset<T, FoundationStatAggregateArgs>): Prisma.PrismaPromise<GetFoundationStatAggregateType<T>>

    /**
     * Group by FoundationStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationStatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoundationStatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoundationStatGroupByArgs['orderBy'] }
        : { orderBy?: FoundationStatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoundationStatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoundationStatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoundationStat model
   */
  readonly fields: FoundationStatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoundationStat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoundationStatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    foundation<T extends FoundationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoundationDefaultArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoundationStat model
   */
  interface FoundationStatFieldRefs {
    readonly id: FieldRef<"FoundationStat", 'Int'>
    readonly foundationId: FieldRef<"FoundationStat", 'Int'>
    readonly label: FieldRef<"FoundationStat", 'String'>
    readonly value: FieldRef<"FoundationStat", 'String'>
    readonly displayOrder: FieldRef<"FoundationStat", 'Int'>
    readonly createdAt: FieldRef<"FoundationStat", 'DateTime'>
    readonly updatedAt: FieldRef<"FoundationStat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoundationStat findUnique
   */
  export type FoundationStatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * Filter, which FoundationStat to fetch.
     */
    where: FoundationStatWhereUniqueInput
  }

  /**
   * FoundationStat findUniqueOrThrow
   */
  export type FoundationStatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * Filter, which FoundationStat to fetch.
     */
    where: FoundationStatWhereUniqueInput
  }

  /**
   * FoundationStat findFirst
   */
  export type FoundationStatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * Filter, which FoundationStat to fetch.
     */
    where?: FoundationStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationStats to fetch.
     */
    orderBy?: FoundationStatOrderByWithRelationInput | FoundationStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationStats.
     */
    cursor?: FoundationStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationStats.
     */
    distinct?: FoundationStatScalarFieldEnum | FoundationStatScalarFieldEnum[]
  }

  /**
   * FoundationStat findFirstOrThrow
   */
  export type FoundationStatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * Filter, which FoundationStat to fetch.
     */
    where?: FoundationStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationStats to fetch.
     */
    orderBy?: FoundationStatOrderByWithRelationInput | FoundationStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationStats.
     */
    cursor?: FoundationStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationStats.
     */
    distinct?: FoundationStatScalarFieldEnum | FoundationStatScalarFieldEnum[]
  }

  /**
   * FoundationStat findMany
   */
  export type FoundationStatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * Filter, which FoundationStats to fetch.
     */
    where?: FoundationStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationStats to fetch.
     */
    orderBy?: FoundationStatOrderByWithRelationInput | FoundationStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoundationStats.
     */
    cursor?: FoundationStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationStats.
     */
    skip?: number
    distinct?: FoundationStatScalarFieldEnum | FoundationStatScalarFieldEnum[]
  }

  /**
   * FoundationStat create
   */
  export type FoundationStatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * The data needed to create a FoundationStat.
     */
    data: XOR<FoundationStatCreateInput, FoundationStatUncheckedCreateInput>
  }

  /**
   * FoundationStat createMany
   */
  export type FoundationStatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoundationStats.
     */
    data: FoundationStatCreateManyInput | FoundationStatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoundationStat update
   */
  export type FoundationStatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * The data needed to update a FoundationStat.
     */
    data: XOR<FoundationStatUpdateInput, FoundationStatUncheckedUpdateInput>
    /**
     * Choose, which FoundationStat to update.
     */
    where: FoundationStatWhereUniqueInput
  }

  /**
   * FoundationStat updateMany
   */
  export type FoundationStatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoundationStats.
     */
    data: XOR<FoundationStatUpdateManyMutationInput, FoundationStatUncheckedUpdateManyInput>
    /**
     * Filter which FoundationStats to update
     */
    where?: FoundationStatWhereInput
    /**
     * Limit how many FoundationStats to update.
     */
    limit?: number
  }

  /**
   * FoundationStat upsert
   */
  export type FoundationStatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * The filter to search for the FoundationStat to update in case it exists.
     */
    where: FoundationStatWhereUniqueInput
    /**
     * In case the FoundationStat found by the `where` argument doesn't exist, create a new FoundationStat with this data.
     */
    create: XOR<FoundationStatCreateInput, FoundationStatUncheckedCreateInput>
    /**
     * In case the FoundationStat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoundationStatUpdateInput, FoundationStatUncheckedUpdateInput>
  }

  /**
   * FoundationStat delete
   */
  export type FoundationStatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * Filter which FoundationStat to delete.
     */
    where: FoundationStatWhereUniqueInput
  }

  /**
   * FoundationStat deleteMany
   */
  export type FoundationStatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationStats to delete
     */
    where?: FoundationStatWhereInput
    /**
     * Limit how many FoundationStats to delete.
     */
    limit?: number
  }

  /**
   * FoundationStat without action
   */
  export type FoundationStatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
  }


  /**
   * Model FoundationActivity
   */

  export type AggregateFoundationActivity = {
    _count: FoundationActivityCountAggregateOutputType | null
    _avg: FoundationActivityAvgAggregateOutputType | null
    _sum: FoundationActivitySumAggregateOutputType | null
    _min: FoundationActivityMinAggregateOutputType | null
    _max: FoundationActivityMaxAggregateOutputType | null
  }

  export type FoundationActivityAvgAggregateOutputType = {
    id: number | null
    foundationId: number | null
    displayOrder: number | null
  }

  export type FoundationActivitySumAggregateOutputType = {
    id: number | null
    foundationId: number | null
    displayOrder: number | null
  }

  export type FoundationActivityMinAggregateOutputType = {
    id: number | null
    foundationId: number | null
    activityText: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoundationActivityMaxAggregateOutputType = {
    id: number | null
    foundationId: number | null
    activityText: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoundationActivityCountAggregateOutputType = {
    id: number
    foundationId: number
    activityText: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoundationActivityAvgAggregateInputType = {
    id?: true
    foundationId?: true
    displayOrder?: true
  }

  export type FoundationActivitySumAggregateInputType = {
    id?: true
    foundationId?: true
    displayOrder?: true
  }

  export type FoundationActivityMinAggregateInputType = {
    id?: true
    foundationId?: true
    activityText?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoundationActivityMaxAggregateInputType = {
    id?: true
    foundationId?: true
    activityText?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoundationActivityCountAggregateInputType = {
    id?: true
    foundationId?: true
    activityText?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoundationActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationActivity to aggregate.
     */
    where?: FoundationActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationActivities to fetch.
     */
    orderBy?: FoundationActivityOrderByWithRelationInput | FoundationActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoundationActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoundationActivities
    **/
    _count?: true | FoundationActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoundationActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoundationActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoundationActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoundationActivityMaxAggregateInputType
  }

  export type GetFoundationActivityAggregateType<T extends FoundationActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateFoundationActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoundationActivity[P]>
      : GetScalarType<T[P], AggregateFoundationActivity[P]>
  }




  export type FoundationActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationActivityWhereInput
    orderBy?: FoundationActivityOrderByWithAggregationInput | FoundationActivityOrderByWithAggregationInput[]
    by: FoundationActivityScalarFieldEnum[] | FoundationActivityScalarFieldEnum
    having?: FoundationActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoundationActivityCountAggregateInputType | true
    _avg?: FoundationActivityAvgAggregateInputType
    _sum?: FoundationActivitySumAggregateInputType
    _min?: FoundationActivityMinAggregateInputType
    _max?: FoundationActivityMaxAggregateInputType
  }

  export type FoundationActivityGroupByOutputType = {
    id: number
    foundationId: number
    activityText: string
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: FoundationActivityCountAggregateOutputType | null
    _avg: FoundationActivityAvgAggregateOutputType | null
    _sum: FoundationActivitySumAggregateOutputType | null
    _min: FoundationActivityMinAggregateOutputType | null
    _max: FoundationActivityMaxAggregateOutputType | null
  }

  type GetFoundationActivityGroupByPayload<T extends FoundationActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoundationActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoundationActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoundationActivityGroupByOutputType[P]>
            : GetScalarType<T[P], FoundationActivityGroupByOutputType[P]>
        }
      >
    >


  export type FoundationActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foundationId?: boolean
    activityText?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    foundation?: boolean | FoundationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foundationActivity"]>



  export type FoundationActivitySelectScalar = {
    id?: boolean
    foundationId?: boolean
    activityText?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoundationActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "foundationId" | "activityText" | "displayOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["foundationActivity"]>
  export type FoundationActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foundation?: boolean | FoundationDefaultArgs<ExtArgs>
  }

  export type $FoundationActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoundationActivity"
    objects: {
      foundation: Prisma.$FoundationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      foundationId: number
      activityText: string
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foundationActivity"]>
    composites: {}
  }

  type FoundationActivityGetPayload<S extends boolean | null | undefined | FoundationActivityDefaultArgs> = $Result.GetResult<Prisma.$FoundationActivityPayload, S>

  type FoundationActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoundationActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoundationActivityCountAggregateInputType | true
    }

  export interface FoundationActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoundationActivity'], meta: { name: 'FoundationActivity' } }
    /**
     * Find zero or one FoundationActivity that matches the filter.
     * @param {FoundationActivityFindUniqueArgs} args - Arguments to find a FoundationActivity
     * @example
     * // Get one FoundationActivity
     * const foundationActivity = await prisma.foundationActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoundationActivityFindUniqueArgs>(args: SelectSubset<T, FoundationActivityFindUniqueArgs<ExtArgs>>): Prisma__FoundationActivityClient<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoundationActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoundationActivityFindUniqueOrThrowArgs} args - Arguments to find a FoundationActivity
     * @example
     * // Get one FoundationActivity
     * const foundationActivity = await prisma.foundationActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoundationActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, FoundationActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoundationActivityClient<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationActivityFindFirstArgs} args - Arguments to find a FoundationActivity
     * @example
     * // Get one FoundationActivity
     * const foundationActivity = await prisma.foundationActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoundationActivityFindFirstArgs>(args?: SelectSubset<T, FoundationActivityFindFirstArgs<ExtArgs>>): Prisma__FoundationActivityClient<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationActivityFindFirstOrThrowArgs} args - Arguments to find a FoundationActivity
     * @example
     * // Get one FoundationActivity
     * const foundationActivity = await prisma.foundationActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoundationActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, FoundationActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoundationActivityClient<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoundationActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoundationActivities
     * const foundationActivities = await prisma.foundationActivity.findMany()
     * 
     * // Get first 10 FoundationActivities
     * const foundationActivities = await prisma.foundationActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foundationActivityWithIdOnly = await prisma.foundationActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoundationActivityFindManyArgs>(args?: SelectSubset<T, FoundationActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoundationActivity.
     * @param {FoundationActivityCreateArgs} args - Arguments to create a FoundationActivity.
     * @example
     * // Create one FoundationActivity
     * const FoundationActivity = await prisma.foundationActivity.create({
     *   data: {
     *     // ... data to create a FoundationActivity
     *   }
     * })
     * 
     */
    create<T extends FoundationActivityCreateArgs>(args: SelectSubset<T, FoundationActivityCreateArgs<ExtArgs>>): Prisma__FoundationActivityClient<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoundationActivities.
     * @param {FoundationActivityCreateManyArgs} args - Arguments to create many FoundationActivities.
     * @example
     * // Create many FoundationActivities
     * const foundationActivity = await prisma.foundationActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoundationActivityCreateManyArgs>(args?: SelectSubset<T, FoundationActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FoundationActivity.
     * @param {FoundationActivityDeleteArgs} args - Arguments to delete one FoundationActivity.
     * @example
     * // Delete one FoundationActivity
     * const FoundationActivity = await prisma.foundationActivity.delete({
     *   where: {
     *     // ... filter to delete one FoundationActivity
     *   }
     * })
     * 
     */
    delete<T extends FoundationActivityDeleteArgs>(args: SelectSubset<T, FoundationActivityDeleteArgs<ExtArgs>>): Prisma__FoundationActivityClient<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoundationActivity.
     * @param {FoundationActivityUpdateArgs} args - Arguments to update one FoundationActivity.
     * @example
     * // Update one FoundationActivity
     * const foundationActivity = await prisma.foundationActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoundationActivityUpdateArgs>(args: SelectSubset<T, FoundationActivityUpdateArgs<ExtArgs>>): Prisma__FoundationActivityClient<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoundationActivities.
     * @param {FoundationActivityDeleteManyArgs} args - Arguments to filter FoundationActivities to delete.
     * @example
     * // Delete a few FoundationActivities
     * const { count } = await prisma.foundationActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoundationActivityDeleteManyArgs>(args?: SelectSubset<T, FoundationActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoundationActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoundationActivities
     * const foundationActivity = await prisma.foundationActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoundationActivityUpdateManyArgs>(args: SelectSubset<T, FoundationActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoundationActivity.
     * @param {FoundationActivityUpsertArgs} args - Arguments to update or create a FoundationActivity.
     * @example
     * // Update or create a FoundationActivity
     * const foundationActivity = await prisma.foundationActivity.upsert({
     *   create: {
     *     // ... data to create a FoundationActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoundationActivity we want to update
     *   }
     * })
     */
    upsert<T extends FoundationActivityUpsertArgs>(args: SelectSubset<T, FoundationActivityUpsertArgs<ExtArgs>>): Prisma__FoundationActivityClient<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoundationActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationActivityCountArgs} args - Arguments to filter FoundationActivities to count.
     * @example
     * // Count the number of FoundationActivities
     * const count = await prisma.foundationActivity.count({
     *   where: {
     *     // ... the filter for the FoundationActivities we want to count
     *   }
     * })
    **/
    count<T extends FoundationActivityCountArgs>(
      args?: Subset<T, FoundationActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoundationActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoundationActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoundationActivityAggregateArgs>(args: Subset<T, FoundationActivityAggregateArgs>): Prisma.PrismaPromise<GetFoundationActivityAggregateType<T>>

    /**
     * Group by FoundationActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoundationActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoundationActivityGroupByArgs['orderBy'] }
        : { orderBy?: FoundationActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoundationActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoundationActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoundationActivity model
   */
  readonly fields: FoundationActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoundationActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoundationActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    foundation<T extends FoundationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoundationDefaultArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoundationActivity model
   */
  interface FoundationActivityFieldRefs {
    readonly id: FieldRef<"FoundationActivity", 'Int'>
    readonly foundationId: FieldRef<"FoundationActivity", 'Int'>
    readonly activityText: FieldRef<"FoundationActivity", 'String'>
    readonly displayOrder: FieldRef<"FoundationActivity", 'Int'>
    readonly createdAt: FieldRef<"FoundationActivity", 'DateTime'>
    readonly updatedAt: FieldRef<"FoundationActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoundationActivity findUnique
   */
  export type FoundationActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * Filter, which FoundationActivity to fetch.
     */
    where: FoundationActivityWhereUniqueInput
  }

  /**
   * FoundationActivity findUniqueOrThrow
   */
  export type FoundationActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * Filter, which FoundationActivity to fetch.
     */
    where: FoundationActivityWhereUniqueInput
  }

  /**
   * FoundationActivity findFirst
   */
  export type FoundationActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * Filter, which FoundationActivity to fetch.
     */
    where?: FoundationActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationActivities to fetch.
     */
    orderBy?: FoundationActivityOrderByWithRelationInput | FoundationActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationActivities.
     */
    cursor?: FoundationActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationActivities.
     */
    distinct?: FoundationActivityScalarFieldEnum | FoundationActivityScalarFieldEnum[]
  }

  /**
   * FoundationActivity findFirstOrThrow
   */
  export type FoundationActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * Filter, which FoundationActivity to fetch.
     */
    where?: FoundationActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationActivities to fetch.
     */
    orderBy?: FoundationActivityOrderByWithRelationInput | FoundationActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationActivities.
     */
    cursor?: FoundationActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationActivities.
     */
    distinct?: FoundationActivityScalarFieldEnum | FoundationActivityScalarFieldEnum[]
  }

  /**
   * FoundationActivity findMany
   */
  export type FoundationActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * Filter, which FoundationActivities to fetch.
     */
    where?: FoundationActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationActivities to fetch.
     */
    orderBy?: FoundationActivityOrderByWithRelationInput | FoundationActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoundationActivities.
     */
    cursor?: FoundationActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationActivities.
     */
    skip?: number
    distinct?: FoundationActivityScalarFieldEnum | FoundationActivityScalarFieldEnum[]
  }

  /**
   * FoundationActivity create
   */
  export type FoundationActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a FoundationActivity.
     */
    data: XOR<FoundationActivityCreateInput, FoundationActivityUncheckedCreateInput>
  }

  /**
   * FoundationActivity createMany
   */
  export type FoundationActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoundationActivities.
     */
    data: FoundationActivityCreateManyInput | FoundationActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoundationActivity update
   */
  export type FoundationActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a FoundationActivity.
     */
    data: XOR<FoundationActivityUpdateInput, FoundationActivityUncheckedUpdateInput>
    /**
     * Choose, which FoundationActivity to update.
     */
    where: FoundationActivityWhereUniqueInput
  }

  /**
   * FoundationActivity updateMany
   */
  export type FoundationActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoundationActivities.
     */
    data: XOR<FoundationActivityUpdateManyMutationInput, FoundationActivityUncheckedUpdateManyInput>
    /**
     * Filter which FoundationActivities to update
     */
    where?: FoundationActivityWhereInput
    /**
     * Limit how many FoundationActivities to update.
     */
    limit?: number
  }

  /**
   * FoundationActivity upsert
   */
  export type FoundationActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the FoundationActivity to update in case it exists.
     */
    where: FoundationActivityWhereUniqueInput
    /**
     * In case the FoundationActivity found by the `where` argument doesn't exist, create a new FoundationActivity with this data.
     */
    create: XOR<FoundationActivityCreateInput, FoundationActivityUncheckedCreateInput>
    /**
     * In case the FoundationActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoundationActivityUpdateInput, FoundationActivityUncheckedUpdateInput>
  }

  /**
   * FoundationActivity delete
   */
  export type FoundationActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * Filter which FoundationActivity to delete.
     */
    where: FoundationActivityWhereUniqueInput
  }

  /**
   * FoundationActivity deleteMany
   */
  export type FoundationActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationActivities to delete
     */
    where?: FoundationActivityWhereInput
    /**
     * Limit how many FoundationActivities to delete.
     */
    limit?: number
  }

  /**
   * FoundationActivity without action
   */
  export type FoundationActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
  }


  /**
   * Model FoundationObjective
   */

  export type AggregateFoundationObjective = {
    _count: FoundationObjectiveCountAggregateOutputType | null
    _avg: FoundationObjectiveAvgAggregateOutputType | null
    _sum: FoundationObjectiveSumAggregateOutputType | null
    _min: FoundationObjectiveMinAggregateOutputType | null
    _max: FoundationObjectiveMaxAggregateOutputType | null
  }

  export type FoundationObjectiveAvgAggregateOutputType = {
    id: number | null
    foundationId: number | null
    displayOrder: number | null
  }

  export type FoundationObjectiveSumAggregateOutputType = {
    id: number | null
    foundationId: number | null
    displayOrder: number | null
  }

  export type FoundationObjectiveMinAggregateOutputType = {
    id: number | null
    foundationId: number | null
    title: string | null
    description: string | null
    objectiveType: $Enums.ObjectiveType | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoundationObjectiveMaxAggregateOutputType = {
    id: number | null
    foundationId: number | null
    title: string | null
    description: string | null
    objectiveType: $Enums.ObjectiveType | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoundationObjectiveCountAggregateOutputType = {
    id: number
    foundationId: number
    title: number
    description: number
    objectiveType: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoundationObjectiveAvgAggregateInputType = {
    id?: true
    foundationId?: true
    displayOrder?: true
  }

  export type FoundationObjectiveSumAggregateInputType = {
    id?: true
    foundationId?: true
    displayOrder?: true
  }

  export type FoundationObjectiveMinAggregateInputType = {
    id?: true
    foundationId?: true
    title?: true
    description?: true
    objectiveType?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoundationObjectiveMaxAggregateInputType = {
    id?: true
    foundationId?: true
    title?: true
    description?: true
    objectiveType?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoundationObjectiveCountAggregateInputType = {
    id?: true
    foundationId?: true
    title?: true
    description?: true
    objectiveType?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoundationObjectiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationObjective to aggregate.
     */
    where?: FoundationObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationObjectives to fetch.
     */
    orderBy?: FoundationObjectiveOrderByWithRelationInput | FoundationObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoundationObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoundationObjectives
    **/
    _count?: true | FoundationObjectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoundationObjectiveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoundationObjectiveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoundationObjectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoundationObjectiveMaxAggregateInputType
  }

  export type GetFoundationObjectiveAggregateType<T extends FoundationObjectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateFoundationObjective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoundationObjective[P]>
      : GetScalarType<T[P], AggregateFoundationObjective[P]>
  }




  export type FoundationObjectiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationObjectiveWhereInput
    orderBy?: FoundationObjectiveOrderByWithAggregationInput | FoundationObjectiveOrderByWithAggregationInput[]
    by: FoundationObjectiveScalarFieldEnum[] | FoundationObjectiveScalarFieldEnum
    having?: FoundationObjectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoundationObjectiveCountAggregateInputType | true
    _avg?: FoundationObjectiveAvgAggregateInputType
    _sum?: FoundationObjectiveSumAggregateInputType
    _min?: FoundationObjectiveMinAggregateInputType
    _max?: FoundationObjectiveMaxAggregateInputType
  }

  export type FoundationObjectiveGroupByOutputType = {
    id: number
    foundationId: number
    title: string
    description: string | null
    objectiveType: $Enums.ObjectiveType
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: FoundationObjectiveCountAggregateOutputType | null
    _avg: FoundationObjectiveAvgAggregateOutputType | null
    _sum: FoundationObjectiveSumAggregateOutputType | null
    _min: FoundationObjectiveMinAggregateOutputType | null
    _max: FoundationObjectiveMaxAggregateOutputType | null
  }

  type GetFoundationObjectiveGroupByPayload<T extends FoundationObjectiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoundationObjectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoundationObjectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoundationObjectiveGroupByOutputType[P]>
            : GetScalarType<T[P], FoundationObjectiveGroupByOutputType[P]>
        }
      >
    >


  export type FoundationObjectiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foundationId?: boolean
    title?: boolean
    description?: boolean
    objectiveType?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    foundation?: boolean | FoundationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foundationObjective"]>



  export type FoundationObjectiveSelectScalar = {
    id?: boolean
    foundationId?: boolean
    title?: boolean
    description?: boolean
    objectiveType?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoundationObjectiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "foundationId" | "title" | "description" | "objectiveType" | "displayOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["foundationObjective"]>
  export type FoundationObjectiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foundation?: boolean | FoundationDefaultArgs<ExtArgs>
  }

  export type $FoundationObjectivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoundationObjective"
    objects: {
      foundation: Prisma.$FoundationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      foundationId: number
      title: string
      description: string | null
      objectiveType: $Enums.ObjectiveType
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foundationObjective"]>
    composites: {}
  }

  type FoundationObjectiveGetPayload<S extends boolean | null | undefined | FoundationObjectiveDefaultArgs> = $Result.GetResult<Prisma.$FoundationObjectivePayload, S>

  type FoundationObjectiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoundationObjectiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoundationObjectiveCountAggregateInputType | true
    }

  export interface FoundationObjectiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoundationObjective'], meta: { name: 'FoundationObjective' } }
    /**
     * Find zero or one FoundationObjective that matches the filter.
     * @param {FoundationObjectiveFindUniqueArgs} args - Arguments to find a FoundationObjective
     * @example
     * // Get one FoundationObjective
     * const foundationObjective = await prisma.foundationObjective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoundationObjectiveFindUniqueArgs>(args: SelectSubset<T, FoundationObjectiveFindUniqueArgs<ExtArgs>>): Prisma__FoundationObjectiveClient<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoundationObjective that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoundationObjectiveFindUniqueOrThrowArgs} args - Arguments to find a FoundationObjective
     * @example
     * // Get one FoundationObjective
     * const foundationObjective = await prisma.foundationObjective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoundationObjectiveFindUniqueOrThrowArgs>(args: SelectSubset<T, FoundationObjectiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoundationObjectiveClient<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationObjective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationObjectiveFindFirstArgs} args - Arguments to find a FoundationObjective
     * @example
     * // Get one FoundationObjective
     * const foundationObjective = await prisma.foundationObjective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoundationObjectiveFindFirstArgs>(args?: SelectSubset<T, FoundationObjectiveFindFirstArgs<ExtArgs>>): Prisma__FoundationObjectiveClient<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationObjective that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationObjectiveFindFirstOrThrowArgs} args - Arguments to find a FoundationObjective
     * @example
     * // Get one FoundationObjective
     * const foundationObjective = await prisma.foundationObjective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoundationObjectiveFindFirstOrThrowArgs>(args?: SelectSubset<T, FoundationObjectiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoundationObjectiveClient<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoundationObjectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationObjectiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoundationObjectives
     * const foundationObjectives = await prisma.foundationObjective.findMany()
     * 
     * // Get first 10 FoundationObjectives
     * const foundationObjectives = await prisma.foundationObjective.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foundationObjectiveWithIdOnly = await prisma.foundationObjective.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoundationObjectiveFindManyArgs>(args?: SelectSubset<T, FoundationObjectiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoundationObjective.
     * @param {FoundationObjectiveCreateArgs} args - Arguments to create a FoundationObjective.
     * @example
     * // Create one FoundationObjective
     * const FoundationObjective = await prisma.foundationObjective.create({
     *   data: {
     *     // ... data to create a FoundationObjective
     *   }
     * })
     * 
     */
    create<T extends FoundationObjectiveCreateArgs>(args: SelectSubset<T, FoundationObjectiveCreateArgs<ExtArgs>>): Prisma__FoundationObjectiveClient<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoundationObjectives.
     * @param {FoundationObjectiveCreateManyArgs} args - Arguments to create many FoundationObjectives.
     * @example
     * // Create many FoundationObjectives
     * const foundationObjective = await prisma.foundationObjective.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoundationObjectiveCreateManyArgs>(args?: SelectSubset<T, FoundationObjectiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FoundationObjective.
     * @param {FoundationObjectiveDeleteArgs} args - Arguments to delete one FoundationObjective.
     * @example
     * // Delete one FoundationObjective
     * const FoundationObjective = await prisma.foundationObjective.delete({
     *   where: {
     *     // ... filter to delete one FoundationObjective
     *   }
     * })
     * 
     */
    delete<T extends FoundationObjectiveDeleteArgs>(args: SelectSubset<T, FoundationObjectiveDeleteArgs<ExtArgs>>): Prisma__FoundationObjectiveClient<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoundationObjective.
     * @param {FoundationObjectiveUpdateArgs} args - Arguments to update one FoundationObjective.
     * @example
     * // Update one FoundationObjective
     * const foundationObjective = await prisma.foundationObjective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoundationObjectiveUpdateArgs>(args: SelectSubset<T, FoundationObjectiveUpdateArgs<ExtArgs>>): Prisma__FoundationObjectiveClient<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoundationObjectives.
     * @param {FoundationObjectiveDeleteManyArgs} args - Arguments to filter FoundationObjectives to delete.
     * @example
     * // Delete a few FoundationObjectives
     * const { count } = await prisma.foundationObjective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoundationObjectiveDeleteManyArgs>(args?: SelectSubset<T, FoundationObjectiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoundationObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationObjectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoundationObjectives
     * const foundationObjective = await prisma.foundationObjective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoundationObjectiveUpdateManyArgs>(args: SelectSubset<T, FoundationObjectiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoundationObjective.
     * @param {FoundationObjectiveUpsertArgs} args - Arguments to update or create a FoundationObjective.
     * @example
     * // Update or create a FoundationObjective
     * const foundationObjective = await prisma.foundationObjective.upsert({
     *   create: {
     *     // ... data to create a FoundationObjective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoundationObjective we want to update
     *   }
     * })
     */
    upsert<T extends FoundationObjectiveUpsertArgs>(args: SelectSubset<T, FoundationObjectiveUpsertArgs<ExtArgs>>): Prisma__FoundationObjectiveClient<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoundationObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationObjectiveCountArgs} args - Arguments to filter FoundationObjectives to count.
     * @example
     * // Count the number of FoundationObjectives
     * const count = await prisma.foundationObjective.count({
     *   where: {
     *     // ... the filter for the FoundationObjectives we want to count
     *   }
     * })
    **/
    count<T extends FoundationObjectiveCountArgs>(
      args?: Subset<T, FoundationObjectiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoundationObjectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoundationObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationObjectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoundationObjectiveAggregateArgs>(args: Subset<T, FoundationObjectiveAggregateArgs>): Prisma.PrismaPromise<GetFoundationObjectiveAggregateType<T>>

    /**
     * Group by FoundationObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationObjectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoundationObjectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoundationObjectiveGroupByArgs['orderBy'] }
        : { orderBy?: FoundationObjectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoundationObjectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoundationObjectiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoundationObjective model
   */
  readonly fields: FoundationObjectiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoundationObjective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoundationObjectiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    foundation<T extends FoundationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoundationDefaultArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoundationObjective model
   */
  interface FoundationObjectiveFieldRefs {
    readonly id: FieldRef<"FoundationObjective", 'Int'>
    readonly foundationId: FieldRef<"FoundationObjective", 'Int'>
    readonly title: FieldRef<"FoundationObjective", 'String'>
    readonly description: FieldRef<"FoundationObjective", 'String'>
    readonly objectiveType: FieldRef<"FoundationObjective", 'ObjectiveType'>
    readonly displayOrder: FieldRef<"FoundationObjective", 'Int'>
    readonly createdAt: FieldRef<"FoundationObjective", 'DateTime'>
    readonly updatedAt: FieldRef<"FoundationObjective", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoundationObjective findUnique
   */
  export type FoundationObjectiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which FoundationObjective to fetch.
     */
    where: FoundationObjectiveWhereUniqueInput
  }

  /**
   * FoundationObjective findUniqueOrThrow
   */
  export type FoundationObjectiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which FoundationObjective to fetch.
     */
    where: FoundationObjectiveWhereUniqueInput
  }

  /**
   * FoundationObjective findFirst
   */
  export type FoundationObjectiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which FoundationObjective to fetch.
     */
    where?: FoundationObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationObjectives to fetch.
     */
    orderBy?: FoundationObjectiveOrderByWithRelationInput | FoundationObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationObjectives.
     */
    cursor?: FoundationObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationObjectives.
     */
    distinct?: FoundationObjectiveScalarFieldEnum | FoundationObjectiveScalarFieldEnum[]
  }

  /**
   * FoundationObjective findFirstOrThrow
   */
  export type FoundationObjectiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which FoundationObjective to fetch.
     */
    where?: FoundationObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationObjectives to fetch.
     */
    orderBy?: FoundationObjectiveOrderByWithRelationInput | FoundationObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationObjectives.
     */
    cursor?: FoundationObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationObjectives.
     */
    distinct?: FoundationObjectiveScalarFieldEnum | FoundationObjectiveScalarFieldEnum[]
  }

  /**
   * FoundationObjective findMany
   */
  export type FoundationObjectiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which FoundationObjectives to fetch.
     */
    where?: FoundationObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationObjectives to fetch.
     */
    orderBy?: FoundationObjectiveOrderByWithRelationInput | FoundationObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoundationObjectives.
     */
    cursor?: FoundationObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationObjectives.
     */
    skip?: number
    distinct?: FoundationObjectiveScalarFieldEnum | FoundationObjectiveScalarFieldEnum[]
  }

  /**
   * FoundationObjective create
   */
  export type FoundationObjectiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to create a FoundationObjective.
     */
    data: XOR<FoundationObjectiveCreateInput, FoundationObjectiveUncheckedCreateInput>
  }

  /**
   * FoundationObjective createMany
   */
  export type FoundationObjectiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoundationObjectives.
     */
    data: FoundationObjectiveCreateManyInput | FoundationObjectiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoundationObjective update
   */
  export type FoundationObjectiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to update a FoundationObjective.
     */
    data: XOR<FoundationObjectiveUpdateInput, FoundationObjectiveUncheckedUpdateInput>
    /**
     * Choose, which FoundationObjective to update.
     */
    where: FoundationObjectiveWhereUniqueInput
  }

  /**
   * FoundationObjective updateMany
   */
  export type FoundationObjectiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoundationObjectives.
     */
    data: XOR<FoundationObjectiveUpdateManyMutationInput, FoundationObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which FoundationObjectives to update
     */
    where?: FoundationObjectiveWhereInput
    /**
     * Limit how many FoundationObjectives to update.
     */
    limit?: number
  }

  /**
   * FoundationObjective upsert
   */
  export type FoundationObjectiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * The filter to search for the FoundationObjective to update in case it exists.
     */
    where: FoundationObjectiveWhereUniqueInput
    /**
     * In case the FoundationObjective found by the `where` argument doesn't exist, create a new FoundationObjective with this data.
     */
    create: XOR<FoundationObjectiveCreateInput, FoundationObjectiveUncheckedCreateInput>
    /**
     * In case the FoundationObjective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoundationObjectiveUpdateInput, FoundationObjectiveUncheckedUpdateInput>
  }

  /**
   * FoundationObjective delete
   */
  export type FoundationObjectiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * Filter which FoundationObjective to delete.
     */
    where: FoundationObjectiveWhereUniqueInput
  }

  /**
   * FoundationObjective deleteMany
   */
  export type FoundationObjectiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationObjectives to delete
     */
    where?: FoundationObjectiveWhereInput
    /**
     * Limit how many FoundationObjectives to delete.
     */
    limit?: number
  }

  /**
   * FoundationObjective without action
   */
  export type FoundationObjectiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
  }


  /**
   * Model FoundationContact
   */

  export type AggregateFoundationContact = {
    _count: FoundationContactCountAggregateOutputType | null
    _avg: FoundationContactAvgAggregateOutputType | null
    _sum: FoundationContactSumAggregateOutputType | null
    _min: FoundationContactMinAggregateOutputType | null
    _max: FoundationContactMaxAggregateOutputType | null
  }

  export type FoundationContactAvgAggregateOutputType = {
    id: number | null
    foundationId: number | null
  }

  export type FoundationContactSumAggregateOutputType = {
    id: number | null
    foundationId: number | null
  }

  export type FoundationContactMinAggregateOutputType = {
    id: number | null
    foundationId: number | null
    email: string | null
    phone: string | null
    address: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoundationContactMaxAggregateOutputType = {
    id: number | null
    foundationId: number | null
    email: string | null
    phone: string | null
    address: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoundationContactCountAggregateOutputType = {
    id: number
    foundationId: number
    email: number
    phone: number
    address: number
    website: number
    socialMediaLinks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoundationContactAvgAggregateInputType = {
    id?: true
    foundationId?: true
  }

  export type FoundationContactSumAggregateInputType = {
    id?: true
    foundationId?: true
  }

  export type FoundationContactMinAggregateInputType = {
    id?: true
    foundationId?: true
    email?: true
    phone?: true
    address?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoundationContactMaxAggregateInputType = {
    id?: true
    foundationId?: true
    email?: true
    phone?: true
    address?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoundationContactCountAggregateInputType = {
    id?: true
    foundationId?: true
    email?: true
    phone?: true
    address?: true
    website?: true
    socialMediaLinks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoundationContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationContact to aggregate.
     */
    where?: FoundationContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationContacts to fetch.
     */
    orderBy?: FoundationContactOrderByWithRelationInput | FoundationContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoundationContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoundationContacts
    **/
    _count?: true | FoundationContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoundationContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoundationContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoundationContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoundationContactMaxAggregateInputType
  }

  export type GetFoundationContactAggregateType<T extends FoundationContactAggregateArgs> = {
        [P in keyof T & keyof AggregateFoundationContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoundationContact[P]>
      : GetScalarType<T[P], AggregateFoundationContact[P]>
  }




  export type FoundationContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationContactWhereInput
    orderBy?: FoundationContactOrderByWithAggregationInput | FoundationContactOrderByWithAggregationInput[]
    by: FoundationContactScalarFieldEnum[] | FoundationContactScalarFieldEnum
    having?: FoundationContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoundationContactCountAggregateInputType | true
    _avg?: FoundationContactAvgAggregateInputType
    _sum?: FoundationContactSumAggregateInputType
    _min?: FoundationContactMinAggregateInputType
    _max?: FoundationContactMaxAggregateInputType
  }

  export type FoundationContactGroupByOutputType = {
    id: number
    foundationId: number
    email: string | null
    phone: string | null
    address: string | null
    website: string | null
    socialMediaLinks: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: FoundationContactCountAggregateOutputType | null
    _avg: FoundationContactAvgAggregateOutputType | null
    _sum: FoundationContactSumAggregateOutputType | null
    _min: FoundationContactMinAggregateOutputType | null
    _max: FoundationContactMaxAggregateOutputType | null
  }

  type GetFoundationContactGroupByPayload<T extends FoundationContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoundationContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoundationContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoundationContactGroupByOutputType[P]>
            : GetScalarType<T[P], FoundationContactGroupByOutputType[P]>
        }
      >
    >


  export type FoundationContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foundationId?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    website?: boolean
    socialMediaLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    foundation?: boolean | FoundationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foundationContact"]>



  export type FoundationContactSelectScalar = {
    id?: boolean
    foundationId?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    website?: boolean
    socialMediaLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoundationContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "foundationId" | "email" | "phone" | "address" | "website" | "socialMediaLinks" | "createdAt" | "updatedAt", ExtArgs["result"]["foundationContact"]>
  export type FoundationContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foundation?: boolean | FoundationDefaultArgs<ExtArgs>
  }

  export type $FoundationContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoundationContact"
    objects: {
      foundation: Prisma.$FoundationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      foundationId: number
      email: string | null
      phone: string | null
      address: string | null
      website: string | null
      socialMediaLinks: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foundationContact"]>
    composites: {}
  }

  type FoundationContactGetPayload<S extends boolean | null | undefined | FoundationContactDefaultArgs> = $Result.GetResult<Prisma.$FoundationContactPayload, S>

  type FoundationContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoundationContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoundationContactCountAggregateInputType | true
    }

  export interface FoundationContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoundationContact'], meta: { name: 'FoundationContact' } }
    /**
     * Find zero or one FoundationContact that matches the filter.
     * @param {FoundationContactFindUniqueArgs} args - Arguments to find a FoundationContact
     * @example
     * // Get one FoundationContact
     * const foundationContact = await prisma.foundationContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoundationContactFindUniqueArgs>(args: SelectSubset<T, FoundationContactFindUniqueArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoundationContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoundationContactFindUniqueOrThrowArgs} args - Arguments to find a FoundationContact
     * @example
     * // Get one FoundationContact
     * const foundationContact = await prisma.foundationContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoundationContactFindUniqueOrThrowArgs>(args: SelectSubset<T, FoundationContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationContactFindFirstArgs} args - Arguments to find a FoundationContact
     * @example
     * // Get one FoundationContact
     * const foundationContact = await prisma.foundationContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoundationContactFindFirstArgs>(args?: SelectSubset<T, FoundationContactFindFirstArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationContactFindFirstOrThrowArgs} args - Arguments to find a FoundationContact
     * @example
     * // Get one FoundationContact
     * const foundationContact = await prisma.foundationContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoundationContactFindFirstOrThrowArgs>(args?: SelectSubset<T, FoundationContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoundationContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoundationContacts
     * const foundationContacts = await prisma.foundationContact.findMany()
     * 
     * // Get first 10 FoundationContacts
     * const foundationContacts = await prisma.foundationContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foundationContactWithIdOnly = await prisma.foundationContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoundationContactFindManyArgs>(args?: SelectSubset<T, FoundationContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoundationContact.
     * @param {FoundationContactCreateArgs} args - Arguments to create a FoundationContact.
     * @example
     * // Create one FoundationContact
     * const FoundationContact = await prisma.foundationContact.create({
     *   data: {
     *     // ... data to create a FoundationContact
     *   }
     * })
     * 
     */
    create<T extends FoundationContactCreateArgs>(args: SelectSubset<T, FoundationContactCreateArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoundationContacts.
     * @param {FoundationContactCreateManyArgs} args - Arguments to create many FoundationContacts.
     * @example
     * // Create many FoundationContacts
     * const foundationContact = await prisma.foundationContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoundationContactCreateManyArgs>(args?: SelectSubset<T, FoundationContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FoundationContact.
     * @param {FoundationContactDeleteArgs} args - Arguments to delete one FoundationContact.
     * @example
     * // Delete one FoundationContact
     * const FoundationContact = await prisma.foundationContact.delete({
     *   where: {
     *     // ... filter to delete one FoundationContact
     *   }
     * })
     * 
     */
    delete<T extends FoundationContactDeleteArgs>(args: SelectSubset<T, FoundationContactDeleteArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoundationContact.
     * @param {FoundationContactUpdateArgs} args - Arguments to update one FoundationContact.
     * @example
     * // Update one FoundationContact
     * const foundationContact = await prisma.foundationContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoundationContactUpdateArgs>(args: SelectSubset<T, FoundationContactUpdateArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoundationContacts.
     * @param {FoundationContactDeleteManyArgs} args - Arguments to filter FoundationContacts to delete.
     * @example
     * // Delete a few FoundationContacts
     * const { count } = await prisma.foundationContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoundationContactDeleteManyArgs>(args?: SelectSubset<T, FoundationContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoundationContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoundationContacts
     * const foundationContact = await prisma.foundationContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoundationContactUpdateManyArgs>(args: SelectSubset<T, FoundationContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoundationContact.
     * @param {FoundationContactUpsertArgs} args - Arguments to update or create a FoundationContact.
     * @example
     * // Update or create a FoundationContact
     * const foundationContact = await prisma.foundationContact.upsert({
     *   create: {
     *     // ... data to create a FoundationContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoundationContact we want to update
     *   }
     * })
     */
    upsert<T extends FoundationContactUpsertArgs>(args: SelectSubset<T, FoundationContactUpsertArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoundationContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationContactCountArgs} args - Arguments to filter FoundationContacts to count.
     * @example
     * // Count the number of FoundationContacts
     * const count = await prisma.foundationContact.count({
     *   where: {
     *     // ... the filter for the FoundationContacts we want to count
     *   }
     * })
    **/
    count<T extends FoundationContactCountArgs>(
      args?: Subset<T, FoundationContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoundationContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoundationContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoundationContactAggregateArgs>(args: Subset<T, FoundationContactAggregateArgs>): Prisma.PrismaPromise<GetFoundationContactAggregateType<T>>

    /**
     * Group by FoundationContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoundationContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoundationContactGroupByArgs['orderBy'] }
        : { orderBy?: FoundationContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoundationContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoundationContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoundationContact model
   */
  readonly fields: FoundationContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoundationContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoundationContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    foundation<T extends FoundationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoundationDefaultArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoundationContact model
   */
  interface FoundationContactFieldRefs {
    readonly id: FieldRef<"FoundationContact", 'Int'>
    readonly foundationId: FieldRef<"FoundationContact", 'Int'>
    readonly email: FieldRef<"FoundationContact", 'String'>
    readonly phone: FieldRef<"FoundationContact", 'String'>
    readonly address: FieldRef<"FoundationContact", 'String'>
    readonly website: FieldRef<"FoundationContact", 'String'>
    readonly socialMediaLinks: FieldRef<"FoundationContact", 'Json'>
    readonly createdAt: FieldRef<"FoundationContact", 'DateTime'>
    readonly updatedAt: FieldRef<"FoundationContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoundationContact findUnique
   */
  export type FoundationContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * Filter, which FoundationContact to fetch.
     */
    where: FoundationContactWhereUniqueInput
  }

  /**
   * FoundationContact findUniqueOrThrow
   */
  export type FoundationContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * Filter, which FoundationContact to fetch.
     */
    where: FoundationContactWhereUniqueInput
  }

  /**
   * FoundationContact findFirst
   */
  export type FoundationContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * Filter, which FoundationContact to fetch.
     */
    where?: FoundationContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationContacts to fetch.
     */
    orderBy?: FoundationContactOrderByWithRelationInput | FoundationContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationContacts.
     */
    cursor?: FoundationContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationContacts.
     */
    distinct?: FoundationContactScalarFieldEnum | FoundationContactScalarFieldEnum[]
  }

  /**
   * FoundationContact findFirstOrThrow
   */
  export type FoundationContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * Filter, which FoundationContact to fetch.
     */
    where?: FoundationContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationContacts to fetch.
     */
    orderBy?: FoundationContactOrderByWithRelationInput | FoundationContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationContacts.
     */
    cursor?: FoundationContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationContacts.
     */
    distinct?: FoundationContactScalarFieldEnum | FoundationContactScalarFieldEnum[]
  }

  /**
   * FoundationContact findMany
   */
  export type FoundationContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * Filter, which FoundationContacts to fetch.
     */
    where?: FoundationContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationContacts to fetch.
     */
    orderBy?: FoundationContactOrderByWithRelationInput | FoundationContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoundationContacts.
     */
    cursor?: FoundationContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationContacts.
     */
    skip?: number
    distinct?: FoundationContactScalarFieldEnum | FoundationContactScalarFieldEnum[]
  }

  /**
   * FoundationContact create
   */
  export type FoundationContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * The data needed to create a FoundationContact.
     */
    data: XOR<FoundationContactCreateInput, FoundationContactUncheckedCreateInput>
  }

  /**
   * FoundationContact createMany
   */
  export type FoundationContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoundationContacts.
     */
    data: FoundationContactCreateManyInput | FoundationContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoundationContact update
   */
  export type FoundationContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * The data needed to update a FoundationContact.
     */
    data: XOR<FoundationContactUpdateInput, FoundationContactUncheckedUpdateInput>
    /**
     * Choose, which FoundationContact to update.
     */
    where: FoundationContactWhereUniqueInput
  }

  /**
   * FoundationContact updateMany
   */
  export type FoundationContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoundationContacts.
     */
    data: XOR<FoundationContactUpdateManyMutationInput, FoundationContactUncheckedUpdateManyInput>
    /**
     * Filter which FoundationContacts to update
     */
    where?: FoundationContactWhereInput
    /**
     * Limit how many FoundationContacts to update.
     */
    limit?: number
  }

  /**
   * FoundationContact upsert
   */
  export type FoundationContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * The filter to search for the FoundationContact to update in case it exists.
     */
    where: FoundationContactWhereUniqueInput
    /**
     * In case the FoundationContact found by the `where` argument doesn't exist, create a new FoundationContact with this data.
     */
    create: XOR<FoundationContactCreateInput, FoundationContactUncheckedCreateInput>
    /**
     * In case the FoundationContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoundationContactUpdateInput, FoundationContactUncheckedUpdateInput>
  }

  /**
   * FoundationContact delete
   */
  export type FoundationContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * Filter which FoundationContact to delete.
     */
    where: FoundationContactWhereUniqueInput
  }

  /**
   * FoundationContact deleteMany
   */
  export type FoundationContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationContacts to delete
     */
    where?: FoundationContactWhereInput
    /**
     * Limit how many FoundationContacts to delete.
     */
    limit?: number
  }

  /**
   * FoundationContact without action
   */
  export type FoundationContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
  }


  /**
   * Model FoundationMedia
   */

  export type AggregateFoundationMedia = {
    _count: FoundationMediaCountAggregateOutputType | null
    _avg: FoundationMediaAvgAggregateOutputType | null
    _sum: FoundationMediaSumAggregateOutputType | null
    _min: FoundationMediaMinAggregateOutputType | null
    _max: FoundationMediaMaxAggregateOutputType | null
  }

  export type FoundationMediaAvgAggregateOutputType = {
    id: number | null
    foundationId: number | null
    fileSize: number | null
  }

  export type FoundationMediaSumAggregateOutputType = {
    id: number | null
    foundationId: number | null
    fileSize: number | null
  }

  export type FoundationMediaMinAggregateOutputType = {
    id: number | null
    foundationId: number | null
    fileName: string | null
    filePath: string | null
    fileType: string | null
    fileSize: number | null
    mediaType: $Enums.MediaType | null
    altText: string | null
    createdAt: Date | null
  }

  export type FoundationMediaMaxAggregateOutputType = {
    id: number | null
    foundationId: number | null
    fileName: string | null
    filePath: string | null
    fileType: string | null
    fileSize: number | null
    mediaType: $Enums.MediaType | null
    altText: string | null
    createdAt: Date | null
  }

  export type FoundationMediaCountAggregateOutputType = {
    id: number
    foundationId: number
    fileName: number
    filePath: number
    fileType: number
    fileSize: number
    mediaType: number
    altText: number
    createdAt: number
    _all: number
  }


  export type FoundationMediaAvgAggregateInputType = {
    id?: true
    foundationId?: true
    fileSize?: true
  }

  export type FoundationMediaSumAggregateInputType = {
    id?: true
    foundationId?: true
    fileSize?: true
  }

  export type FoundationMediaMinAggregateInputType = {
    id?: true
    foundationId?: true
    fileName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    mediaType?: true
    altText?: true
    createdAt?: true
  }

  export type FoundationMediaMaxAggregateInputType = {
    id?: true
    foundationId?: true
    fileName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    mediaType?: true
    altText?: true
    createdAt?: true
  }

  export type FoundationMediaCountAggregateInputType = {
    id?: true
    foundationId?: true
    fileName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    mediaType?: true
    altText?: true
    createdAt?: true
    _all?: true
  }

  export type FoundationMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationMedia to aggregate.
     */
    where?: FoundationMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationMedias to fetch.
     */
    orderBy?: FoundationMediaOrderByWithRelationInput | FoundationMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoundationMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoundationMedias
    **/
    _count?: true | FoundationMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoundationMediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoundationMediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoundationMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoundationMediaMaxAggregateInputType
  }

  export type GetFoundationMediaAggregateType<T extends FoundationMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateFoundationMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoundationMedia[P]>
      : GetScalarType<T[P], AggregateFoundationMedia[P]>
  }




  export type FoundationMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationMediaWhereInput
    orderBy?: FoundationMediaOrderByWithAggregationInput | FoundationMediaOrderByWithAggregationInput[]
    by: FoundationMediaScalarFieldEnum[] | FoundationMediaScalarFieldEnum
    having?: FoundationMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoundationMediaCountAggregateInputType | true
    _avg?: FoundationMediaAvgAggregateInputType
    _sum?: FoundationMediaSumAggregateInputType
    _min?: FoundationMediaMinAggregateInputType
    _max?: FoundationMediaMaxAggregateInputType
  }

  export type FoundationMediaGroupByOutputType = {
    id: number
    foundationId: number | null
    fileName: string
    filePath: string
    fileType: string | null
    fileSize: number | null
    mediaType: $Enums.MediaType
    altText: string | null
    createdAt: Date
    _count: FoundationMediaCountAggregateOutputType | null
    _avg: FoundationMediaAvgAggregateOutputType | null
    _sum: FoundationMediaSumAggregateOutputType | null
    _min: FoundationMediaMinAggregateOutputType | null
    _max: FoundationMediaMaxAggregateOutputType | null
  }

  type GetFoundationMediaGroupByPayload<T extends FoundationMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoundationMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoundationMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoundationMediaGroupByOutputType[P]>
            : GetScalarType<T[P], FoundationMediaGroupByOutputType[P]>
        }
      >
    >


  export type FoundationMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foundationId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileType?: boolean
    fileSize?: boolean
    mediaType?: boolean
    altText?: boolean
    createdAt?: boolean
    foundation?: boolean | FoundationMedia$foundationArgs<ExtArgs>
  }, ExtArgs["result"]["foundationMedia"]>



  export type FoundationMediaSelectScalar = {
    id?: boolean
    foundationId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileType?: boolean
    fileSize?: boolean
    mediaType?: boolean
    altText?: boolean
    createdAt?: boolean
  }

  export type FoundationMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "foundationId" | "fileName" | "filePath" | "fileType" | "fileSize" | "mediaType" | "altText" | "createdAt", ExtArgs["result"]["foundationMedia"]>
  export type FoundationMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foundation?: boolean | FoundationMedia$foundationArgs<ExtArgs>
  }

  export type $FoundationMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoundationMedia"
    objects: {
      foundation: Prisma.$FoundationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      foundationId: number | null
      fileName: string
      filePath: string
      fileType: string | null
      fileSize: number | null
      mediaType: $Enums.MediaType
      altText: string | null
      createdAt: Date
    }, ExtArgs["result"]["foundationMedia"]>
    composites: {}
  }

  type FoundationMediaGetPayload<S extends boolean | null | undefined | FoundationMediaDefaultArgs> = $Result.GetResult<Prisma.$FoundationMediaPayload, S>

  type FoundationMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoundationMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoundationMediaCountAggregateInputType | true
    }

  export interface FoundationMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoundationMedia'], meta: { name: 'FoundationMedia' } }
    /**
     * Find zero or one FoundationMedia that matches the filter.
     * @param {FoundationMediaFindUniqueArgs} args - Arguments to find a FoundationMedia
     * @example
     * // Get one FoundationMedia
     * const foundationMedia = await prisma.foundationMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoundationMediaFindUniqueArgs>(args: SelectSubset<T, FoundationMediaFindUniqueArgs<ExtArgs>>): Prisma__FoundationMediaClient<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoundationMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoundationMediaFindUniqueOrThrowArgs} args - Arguments to find a FoundationMedia
     * @example
     * // Get one FoundationMedia
     * const foundationMedia = await prisma.foundationMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoundationMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, FoundationMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoundationMediaClient<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationMediaFindFirstArgs} args - Arguments to find a FoundationMedia
     * @example
     * // Get one FoundationMedia
     * const foundationMedia = await prisma.foundationMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoundationMediaFindFirstArgs>(args?: SelectSubset<T, FoundationMediaFindFirstArgs<ExtArgs>>): Prisma__FoundationMediaClient<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationMediaFindFirstOrThrowArgs} args - Arguments to find a FoundationMedia
     * @example
     * // Get one FoundationMedia
     * const foundationMedia = await prisma.foundationMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoundationMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, FoundationMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoundationMediaClient<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoundationMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoundationMedias
     * const foundationMedias = await prisma.foundationMedia.findMany()
     * 
     * // Get first 10 FoundationMedias
     * const foundationMedias = await prisma.foundationMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foundationMediaWithIdOnly = await prisma.foundationMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoundationMediaFindManyArgs>(args?: SelectSubset<T, FoundationMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoundationMedia.
     * @param {FoundationMediaCreateArgs} args - Arguments to create a FoundationMedia.
     * @example
     * // Create one FoundationMedia
     * const FoundationMedia = await prisma.foundationMedia.create({
     *   data: {
     *     // ... data to create a FoundationMedia
     *   }
     * })
     * 
     */
    create<T extends FoundationMediaCreateArgs>(args: SelectSubset<T, FoundationMediaCreateArgs<ExtArgs>>): Prisma__FoundationMediaClient<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoundationMedias.
     * @param {FoundationMediaCreateManyArgs} args - Arguments to create many FoundationMedias.
     * @example
     * // Create many FoundationMedias
     * const foundationMedia = await prisma.foundationMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoundationMediaCreateManyArgs>(args?: SelectSubset<T, FoundationMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FoundationMedia.
     * @param {FoundationMediaDeleteArgs} args - Arguments to delete one FoundationMedia.
     * @example
     * // Delete one FoundationMedia
     * const FoundationMedia = await prisma.foundationMedia.delete({
     *   where: {
     *     // ... filter to delete one FoundationMedia
     *   }
     * })
     * 
     */
    delete<T extends FoundationMediaDeleteArgs>(args: SelectSubset<T, FoundationMediaDeleteArgs<ExtArgs>>): Prisma__FoundationMediaClient<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoundationMedia.
     * @param {FoundationMediaUpdateArgs} args - Arguments to update one FoundationMedia.
     * @example
     * // Update one FoundationMedia
     * const foundationMedia = await prisma.foundationMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoundationMediaUpdateArgs>(args: SelectSubset<T, FoundationMediaUpdateArgs<ExtArgs>>): Prisma__FoundationMediaClient<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoundationMedias.
     * @param {FoundationMediaDeleteManyArgs} args - Arguments to filter FoundationMedias to delete.
     * @example
     * // Delete a few FoundationMedias
     * const { count } = await prisma.foundationMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoundationMediaDeleteManyArgs>(args?: SelectSubset<T, FoundationMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoundationMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoundationMedias
     * const foundationMedia = await prisma.foundationMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoundationMediaUpdateManyArgs>(args: SelectSubset<T, FoundationMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoundationMedia.
     * @param {FoundationMediaUpsertArgs} args - Arguments to update or create a FoundationMedia.
     * @example
     * // Update or create a FoundationMedia
     * const foundationMedia = await prisma.foundationMedia.upsert({
     *   create: {
     *     // ... data to create a FoundationMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoundationMedia we want to update
     *   }
     * })
     */
    upsert<T extends FoundationMediaUpsertArgs>(args: SelectSubset<T, FoundationMediaUpsertArgs<ExtArgs>>): Prisma__FoundationMediaClient<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoundationMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationMediaCountArgs} args - Arguments to filter FoundationMedias to count.
     * @example
     * // Count the number of FoundationMedias
     * const count = await prisma.foundationMedia.count({
     *   where: {
     *     // ... the filter for the FoundationMedias we want to count
     *   }
     * })
    **/
    count<T extends FoundationMediaCountArgs>(
      args?: Subset<T, FoundationMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoundationMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoundationMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoundationMediaAggregateArgs>(args: Subset<T, FoundationMediaAggregateArgs>): Prisma.PrismaPromise<GetFoundationMediaAggregateType<T>>

    /**
     * Group by FoundationMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoundationMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoundationMediaGroupByArgs['orderBy'] }
        : { orderBy?: FoundationMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoundationMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoundationMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoundationMedia model
   */
  readonly fields: FoundationMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoundationMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoundationMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    foundation<T extends FoundationMedia$foundationArgs<ExtArgs> = {}>(args?: Subset<T, FoundationMedia$foundationArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoundationMedia model
   */
  interface FoundationMediaFieldRefs {
    readonly id: FieldRef<"FoundationMedia", 'Int'>
    readonly foundationId: FieldRef<"FoundationMedia", 'Int'>
    readonly fileName: FieldRef<"FoundationMedia", 'String'>
    readonly filePath: FieldRef<"FoundationMedia", 'String'>
    readonly fileType: FieldRef<"FoundationMedia", 'String'>
    readonly fileSize: FieldRef<"FoundationMedia", 'Int'>
    readonly mediaType: FieldRef<"FoundationMedia", 'MediaType'>
    readonly altText: FieldRef<"FoundationMedia", 'String'>
    readonly createdAt: FieldRef<"FoundationMedia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoundationMedia findUnique
   */
  export type FoundationMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * Filter, which FoundationMedia to fetch.
     */
    where: FoundationMediaWhereUniqueInput
  }

  /**
   * FoundationMedia findUniqueOrThrow
   */
  export type FoundationMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * Filter, which FoundationMedia to fetch.
     */
    where: FoundationMediaWhereUniqueInput
  }

  /**
   * FoundationMedia findFirst
   */
  export type FoundationMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * Filter, which FoundationMedia to fetch.
     */
    where?: FoundationMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationMedias to fetch.
     */
    orderBy?: FoundationMediaOrderByWithRelationInput | FoundationMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationMedias.
     */
    cursor?: FoundationMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationMedias.
     */
    distinct?: FoundationMediaScalarFieldEnum | FoundationMediaScalarFieldEnum[]
  }

  /**
   * FoundationMedia findFirstOrThrow
   */
  export type FoundationMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * Filter, which FoundationMedia to fetch.
     */
    where?: FoundationMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationMedias to fetch.
     */
    orderBy?: FoundationMediaOrderByWithRelationInput | FoundationMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationMedias.
     */
    cursor?: FoundationMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationMedias.
     */
    distinct?: FoundationMediaScalarFieldEnum | FoundationMediaScalarFieldEnum[]
  }

  /**
   * FoundationMedia findMany
   */
  export type FoundationMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * Filter, which FoundationMedias to fetch.
     */
    where?: FoundationMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationMedias to fetch.
     */
    orderBy?: FoundationMediaOrderByWithRelationInput | FoundationMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoundationMedias.
     */
    cursor?: FoundationMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationMedias.
     */
    skip?: number
    distinct?: FoundationMediaScalarFieldEnum | FoundationMediaScalarFieldEnum[]
  }

  /**
   * FoundationMedia create
   */
  export type FoundationMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a FoundationMedia.
     */
    data: XOR<FoundationMediaCreateInput, FoundationMediaUncheckedCreateInput>
  }

  /**
   * FoundationMedia createMany
   */
  export type FoundationMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoundationMedias.
     */
    data: FoundationMediaCreateManyInput | FoundationMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoundationMedia update
   */
  export type FoundationMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a FoundationMedia.
     */
    data: XOR<FoundationMediaUpdateInput, FoundationMediaUncheckedUpdateInput>
    /**
     * Choose, which FoundationMedia to update.
     */
    where: FoundationMediaWhereUniqueInput
  }

  /**
   * FoundationMedia updateMany
   */
  export type FoundationMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoundationMedias.
     */
    data: XOR<FoundationMediaUpdateManyMutationInput, FoundationMediaUncheckedUpdateManyInput>
    /**
     * Filter which FoundationMedias to update
     */
    where?: FoundationMediaWhereInput
    /**
     * Limit how many FoundationMedias to update.
     */
    limit?: number
  }

  /**
   * FoundationMedia upsert
   */
  export type FoundationMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the FoundationMedia to update in case it exists.
     */
    where: FoundationMediaWhereUniqueInput
    /**
     * In case the FoundationMedia found by the `where` argument doesn't exist, create a new FoundationMedia with this data.
     */
    create: XOR<FoundationMediaCreateInput, FoundationMediaUncheckedCreateInput>
    /**
     * In case the FoundationMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoundationMediaUpdateInput, FoundationMediaUncheckedUpdateInput>
  }

  /**
   * FoundationMedia delete
   */
  export type FoundationMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * Filter which FoundationMedia to delete.
     */
    where: FoundationMediaWhereUniqueInput
  }

  /**
   * FoundationMedia deleteMany
   */
  export type FoundationMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationMedias to delete
     */
    where?: FoundationMediaWhereInput
    /**
     * Limit how many FoundationMedias to delete.
     */
    limit?: number
  }

  /**
   * FoundationMedia.foundation
   */
  export type FoundationMedia$foundationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    where?: FoundationWhereInput
  }

  /**
   * FoundationMedia without action
   */
  export type FoundationMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    id: number | null
  }

  export type EventSumAggregateOutputType = {
    id: number | null
  }

  export type EventMinAggregateOutputType = {
    id: number | null
    title: string | null
    startDate: Date | null
    endDate: Date | null
    time: string | null
    location: string | null
    duration: string | null
    color: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: number | null
    title: string | null
    startDate: Date | null
    endDate: Date | null
    time: string | null
    location: string | null
    duration: string | null
    color: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    startDate: number
    endDate: number
    time: number
    location: number
    duration: number
    color: number
    liveLinks: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    id?: true
  }

  export type EventSumAggregateInputType = {
    id?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    startDate?: true
    endDate?: true
    time?: true
    location?: true
    duration?: true
    color?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    startDate?: true
    endDate?: true
    time?: true
    location?: true
    duration?: true
    color?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    startDate?: true
    endDate?: true
    time?: true
    location?: true
    duration?: true
    color?: true
    liveLinks?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: number
    title: string
    startDate: Date
    endDate: Date
    time: string | null
    location: string
    duration: string
    color: string
    liveLinks: JsonValue | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    startDate?: boolean
    endDate?: boolean
    time?: boolean
    location?: boolean
    duration?: boolean
    color?: boolean
    liveLinks?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["event"]>



  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    startDate?: boolean
    endDate?: boolean
    time?: boolean
    location?: boolean
    duration?: boolean
    color?: boolean
    liveLinks?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "startDate" | "endDate" | "time" | "location" | "duration" | "color" | "liveLinks" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["event"]>

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      startDate: Date
      endDate: Date
      time: string | null
      location: string
      duration: string
      color: string
      liveLinks: Prisma.JsonValue | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'Int'>
    readonly title: FieldRef<"Event", 'String'>
    readonly startDate: FieldRef<"Event", 'DateTime'>
    readonly endDate: FieldRef<"Event", 'DateTime'>
    readonly time: FieldRef<"Event", 'String'>
    readonly location: FieldRef<"Event", 'String'>
    readonly duration: FieldRef<"Event", 'String'>
    readonly color: FieldRef<"Event", 'String'>
    readonly liveLinks: FieldRef<"Event", 'Json'>
    readonly description: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
  }


  /**
   * Model Bhajan
   */

  export type AggregateBhajan = {
    _count: BhajanCountAggregateOutputType | null
    _min: BhajanMinAggregateOutputType | null
    _max: BhajanMaxAggregateOutputType | null
  }

  export type BhajanMinAggregateOutputType = {
    id: string | null
    name: string | null
    artist: string | null
    album: string | null
    duration: string | null
    imageUrl: string | null
    audioUrl: string | null
    audioPath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BhajanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    artist: string | null
    album: string | null
    duration: string | null
    imageUrl: string | null
    audioUrl: string | null
    audioPath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BhajanCountAggregateOutputType = {
    id: number
    name: number
    artist: number
    album: number
    duration: number
    imageUrl: number
    audioUrl: number
    audioPath: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BhajanMinAggregateInputType = {
    id?: true
    name?: true
    artist?: true
    album?: true
    duration?: true
    imageUrl?: true
    audioUrl?: true
    audioPath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BhajanMaxAggregateInputType = {
    id?: true
    name?: true
    artist?: true
    album?: true
    duration?: true
    imageUrl?: true
    audioUrl?: true
    audioPath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BhajanCountAggregateInputType = {
    id?: true
    name?: true
    artist?: true
    album?: true
    duration?: true
    imageUrl?: true
    audioUrl?: true
    audioPath?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BhajanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bhajan to aggregate.
     */
    where?: BhajanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bhajans to fetch.
     */
    orderBy?: BhajanOrderByWithRelationInput | BhajanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BhajanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bhajans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bhajans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bhajans
    **/
    _count?: true | BhajanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BhajanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BhajanMaxAggregateInputType
  }

  export type GetBhajanAggregateType<T extends BhajanAggregateArgs> = {
        [P in keyof T & keyof AggregateBhajan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBhajan[P]>
      : GetScalarType<T[P], AggregateBhajan[P]>
  }




  export type BhajanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BhajanWhereInput
    orderBy?: BhajanOrderByWithAggregationInput | BhajanOrderByWithAggregationInput[]
    by: BhajanScalarFieldEnum[] | BhajanScalarFieldEnum
    having?: BhajanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BhajanCountAggregateInputType | true
    _min?: BhajanMinAggregateInputType
    _max?: BhajanMaxAggregateInputType
  }

  export type BhajanGroupByOutputType = {
    id: string
    name: string
    artist: string
    album: string | null
    duration: string
    imageUrl: string | null
    audioUrl: string
    audioPath: string
    createdAt: Date
    updatedAt: Date
    _count: BhajanCountAggregateOutputType | null
    _min: BhajanMinAggregateOutputType | null
    _max: BhajanMaxAggregateOutputType | null
  }

  type GetBhajanGroupByPayload<T extends BhajanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BhajanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BhajanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BhajanGroupByOutputType[P]>
            : GetScalarType<T[P], BhajanGroupByOutputType[P]>
        }
      >
    >


  export type BhajanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    artist?: boolean
    album?: boolean
    duration?: boolean
    imageUrl?: boolean
    audioUrl?: boolean
    audioPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bhajan"]>



  export type BhajanSelectScalar = {
    id?: boolean
    name?: boolean
    artist?: boolean
    album?: boolean
    duration?: boolean
    imageUrl?: boolean
    audioUrl?: boolean
    audioPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BhajanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "artist" | "album" | "duration" | "imageUrl" | "audioUrl" | "audioPath" | "createdAt" | "updatedAt", ExtArgs["result"]["bhajan"]>

  export type $BhajanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bhajan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      artist: string
      album: string | null
      duration: string
      imageUrl: string | null
      audioUrl: string
      audioPath: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bhajan"]>
    composites: {}
  }

  type BhajanGetPayload<S extends boolean | null | undefined | BhajanDefaultArgs> = $Result.GetResult<Prisma.$BhajanPayload, S>

  type BhajanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BhajanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BhajanCountAggregateInputType | true
    }

  export interface BhajanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bhajan'], meta: { name: 'Bhajan' } }
    /**
     * Find zero or one Bhajan that matches the filter.
     * @param {BhajanFindUniqueArgs} args - Arguments to find a Bhajan
     * @example
     * // Get one Bhajan
     * const bhajan = await prisma.bhajan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BhajanFindUniqueArgs>(args: SelectSubset<T, BhajanFindUniqueArgs<ExtArgs>>): Prisma__BhajanClient<$Result.GetResult<Prisma.$BhajanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bhajan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BhajanFindUniqueOrThrowArgs} args - Arguments to find a Bhajan
     * @example
     * // Get one Bhajan
     * const bhajan = await prisma.bhajan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BhajanFindUniqueOrThrowArgs>(args: SelectSubset<T, BhajanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BhajanClient<$Result.GetResult<Prisma.$BhajanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bhajan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BhajanFindFirstArgs} args - Arguments to find a Bhajan
     * @example
     * // Get one Bhajan
     * const bhajan = await prisma.bhajan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BhajanFindFirstArgs>(args?: SelectSubset<T, BhajanFindFirstArgs<ExtArgs>>): Prisma__BhajanClient<$Result.GetResult<Prisma.$BhajanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bhajan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BhajanFindFirstOrThrowArgs} args - Arguments to find a Bhajan
     * @example
     * // Get one Bhajan
     * const bhajan = await prisma.bhajan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BhajanFindFirstOrThrowArgs>(args?: SelectSubset<T, BhajanFindFirstOrThrowArgs<ExtArgs>>): Prisma__BhajanClient<$Result.GetResult<Prisma.$BhajanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bhajans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BhajanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bhajans
     * const bhajans = await prisma.bhajan.findMany()
     * 
     * // Get first 10 Bhajans
     * const bhajans = await prisma.bhajan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bhajanWithIdOnly = await prisma.bhajan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BhajanFindManyArgs>(args?: SelectSubset<T, BhajanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BhajanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bhajan.
     * @param {BhajanCreateArgs} args - Arguments to create a Bhajan.
     * @example
     * // Create one Bhajan
     * const Bhajan = await prisma.bhajan.create({
     *   data: {
     *     // ... data to create a Bhajan
     *   }
     * })
     * 
     */
    create<T extends BhajanCreateArgs>(args: SelectSubset<T, BhajanCreateArgs<ExtArgs>>): Prisma__BhajanClient<$Result.GetResult<Prisma.$BhajanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bhajans.
     * @param {BhajanCreateManyArgs} args - Arguments to create many Bhajans.
     * @example
     * // Create many Bhajans
     * const bhajan = await prisma.bhajan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BhajanCreateManyArgs>(args?: SelectSubset<T, BhajanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bhajan.
     * @param {BhajanDeleteArgs} args - Arguments to delete one Bhajan.
     * @example
     * // Delete one Bhajan
     * const Bhajan = await prisma.bhajan.delete({
     *   where: {
     *     // ... filter to delete one Bhajan
     *   }
     * })
     * 
     */
    delete<T extends BhajanDeleteArgs>(args: SelectSubset<T, BhajanDeleteArgs<ExtArgs>>): Prisma__BhajanClient<$Result.GetResult<Prisma.$BhajanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bhajan.
     * @param {BhajanUpdateArgs} args - Arguments to update one Bhajan.
     * @example
     * // Update one Bhajan
     * const bhajan = await prisma.bhajan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BhajanUpdateArgs>(args: SelectSubset<T, BhajanUpdateArgs<ExtArgs>>): Prisma__BhajanClient<$Result.GetResult<Prisma.$BhajanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bhajans.
     * @param {BhajanDeleteManyArgs} args - Arguments to filter Bhajans to delete.
     * @example
     * // Delete a few Bhajans
     * const { count } = await prisma.bhajan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BhajanDeleteManyArgs>(args?: SelectSubset<T, BhajanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bhajans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BhajanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bhajans
     * const bhajan = await prisma.bhajan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BhajanUpdateManyArgs>(args: SelectSubset<T, BhajanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bhajan.
     * @param {BhajanUpsertArgs} args - Arguments to update or create a Bhajan.
     * @example
     * // Update or create a Bhajan
     * const bhajan = await prisma.bhajan.upsert({
     *   create: {
     *     // ... data to create a Bhajan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bhajan we want to update
     *   }
     * })
     */
    upsert<T extends BhajanUpsertArgs>(args: SelectSubset<T, BhajanUpsertArgs<ExtArgs>>): Prisma__BhajanClient<$Result.GetResult<Prisma.$BhajanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bhajans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BhajanCountArgs} args - Arguments to filter Bhajans to count.
     * @example
     * // Count the number of Bhajans
     * const count = await prisma.bhajan.count({
     *   where: {
     *     // ... the filter for the Bhajans we want to count
     *   }
     * })
    **/
    count<T extends BhajanCountArgs>(
      args?: Subset<T, BhajanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BhajanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bhajan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BhajanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BhajanAggregateArgs>(args: Subset<T, BhajanAggregateArgs>): Prisma.PrismaPromise<GetBhajanAggregateType<T>>

    /**
     * Group by Bhajan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BhajanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BhajanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BhajanGroupByArgs['orderBy'] }
        : { orderBy?: BhajanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BhajanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBhajanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bhajan model
   */
  readonly fields: BhajanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bhajan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BhajanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bhajan model
   */
  interface BhajanFieldRefs {
    readonly id: FieldRef<"Bhajan", 'String'>
    readonly name: FieldRef<"Bhajan", 'String'>
    readonly artist: FieldRef<"Bhajan", 'String'>
    readonly album: FieldRef<"Bhajan", 'String'>
    readonly duration: FieldRef<"Bhajan", 'String'>
    readonly imageUrl: FieldRef<"Bhajan", 'String'>
    readonly audioUrl: FieldRef<"Bhajan", 'String'>
    readonly audioPath: FieldRef<"Bhajan", 'String'>
    readonly createdAt: FieldRef<"Bhajan", 'DateTime'>
    readonly updatedAt: FieldRef<"Bhajan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bhajan findUnique
   */
  export type BhajanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bhajan
     */
    select?: BhajanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bhajan
     */
    omit?: BhajanOmit<ExtArgs> | null
    /**
     * Filter, which Bhajan to fetch.
     */
    where: BhajanWhereUniqueInput
  }

  /**
   * Bhajan findUniqueOrThrow
   */
  export type BhajanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bhajan
     */
    select?: BhajanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bhajan
     */
    omit?: BhajanOmit<ExtArgs> | null
    /**
     * Filter, which Bhajan to fetch.
     */
    where: BhajanWhereUniqueInput
  }

  /**
   * Bhajan findFirst
   */
  export type BhajanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bhajan
     */
    select?: BhajanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bhajan
     */
    omit?: BhajanOmit<ExtArgs> | null
    /**
     * Filter, which Bhajan to fetch.
     */
    where?: BhajanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bhajans to fetch.
     */
    orderBy?: BhajanOrderByWithRelationInput | BhajanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bhajans.
     */
    cursor?: BhajanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bhajans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bhajans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bhajans.
     */
    distinct?: BhajanScalarFieldEnum | BhajanScalarFieldEnum[]
  }

  /**
   * Bhajan findFirstOrThrow
   */
  export type BhajanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bhajan
     */
    select?: BhajanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bhajan
     */
    omit?: BhajanOmit<ExtArgs> | null
    /**
     * Filter, which Bhajan to fetch.
     */
    where?: BhajanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bhajans to fetch.
     */
    orderBy?: BhajanOrderByWithRelationInput | BhajanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bhajans.
     */
    cursor?: BhajanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bhajans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bhajans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bhajans.
     */
    distinct?: BhajanScalarFieldEnum | BhajanScalarFieldEnum[]
  }

  /**
   * Bhajan findMany
   */
  export type BhajanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bhajan
     */
    select?: BhajanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bhajan
     */
    omit?: BhajanOmit<ExtArgs> | null
    /**
     * Filter, which Bhajans to fetch.
     */
    where?: BhajanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bhajans to fetch.
     */
    orderBy?: BhajanOrderByWithRelationInput | BhajanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bhajans.
     */
    cursor?: BhajanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bhajans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bhajans.
     */
    skip?: number
    distinct?: BhajanScalarFieldEnum | BhajanScalarFieldEnum[]
  }

  /**
   * Bhajan create
   */
  export type BhajanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bhajan
     */
    select?: BhajanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bhajan
     */
    omit?: BhajanOmit<ExtArgs> | null
    /**
     * The data needed to create a Bhajan.
     */
    data: XOR<BhajanCreateInput, BhajanUncheckedCreateInput>
  }

  /**
   * Bhajan createMany
   */
  export type BhajanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bhajans.
     */
    data: BhajanCreateManyInput | BhajanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bhajan update
   */
  export type BhajanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bhajan
     */
    select?: BhajanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bhajan
     */
    omit?: BhajanOmit<ExtArgs> | null
    /**
     * The data needed to update a Bhajan.
     */
    data: XOR<BhajanUpdateInput, BhajanUncheckedUpdateInput>
    /**
     * Choose, which Bhajan to update.
     */
    where: BhajanWhereUniqueInput
  }

  /**
   * Bhajan updateMany
   */
  export type BhajanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bhajans.
     */
    data: XOR<BhajanUpdateManyMutationInput, BhajanUncheckedUpdateManyInput>
    /**
     * Filter which Bhajans to update
     */
    where?: BhajanWhereInput
    /**
     * Limit how many Bhajans to update.
     */
    limit?: number
  }

  /**
   * Bhajan upsert
   */
  export type BhajanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bhajan
     */
    select?: BhajanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bhajan
     */
    omit?: BhajanOmit<ExtArgs> | null
    /**
     * The filter to search for the Bhajan to update in case it exists.
     */
    where: BhajanWhereUniqueInput
    /**
     * In case the Bhajan found by the `where` argument doesn't exist, create a new Bhajan with this data.
     */
    create: XOR<BhajanCreateInput, BhajanUncheckedCreateInput>
    /**
     * In case the Bhajan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BhajanUpdateInput, BhajanUncheckedUpdateInput>
  }

  /**
   * Bhajan delete
   */
  export type BhajanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bhajan
     */
    select?: BhajanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bhajan
     */
    omit?: BhajanOmit<ExtArgs> | null
    /**
     * Filter which Bhajan to delete.
     */
    where: BhajanWhereUniqueInput
  }

  /**
   * Bhajan deleteMany
   */
  export type BhajanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bhajans to delete
     */
    where?: BhajanWhereInput
    /**
     * Limit how many Bhajans to delete.
     */
    limit?: number
  }

  /**
   * Bhajan without action
   */
  export type BhajanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bhajan
     */
    select?: BhajanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bhajan
     */
    omit?: BhajanOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    image: 'image',
    address: 'address',
    phone: 'phone',
    otpCode: 'otpCode',
    otpExpires: 'otpExpires',
    resetToken: 'resetToken',
    resetTokenExpires: 'resetTokenExpires',
    isVerified: 'isVerified',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DonationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    status: 'status',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DonationScalarFieldEnum = (typeof DonationScalarFieldEnum)[keyof typeof DonationScalarFieldEnum]


  export const BookScalarFieldEnum: {
    id: 'id',
    name: 'name',
    author: 'author',
    fileName: 'fileName',
    filePath: 'filePath',
    fileSize: 'fileSize',
    price: 'price',
    description: 'description',
    coverImage: 'coverImage',
    uploadDate: 'uploadDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookScalarFieldEnum = (typeof BookScalarFieldEnum)[keyof typeof BookScalarFieldEnum]


  export const BookCouponScalarFieldEnum: {
    id: 'id',
    code: 'code',
    discount: 'discount',
    type: 'type',
    description: 'description',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookCouponScalarFieldEnum = (typeof BookCouponScalarFieldEnum)[keyof typeof BookCouponScalarFieldEnum]


  export const BookOrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalAmount: 'totalAmount',
    discountAmount: 'discountAmount',
    finalAmount: 'finalAmount',
    couponId: 'couponId',
    paymentId: 'paymentId',
    orderId: 'orderId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookOrderScalarFieldEnum = (typeof BookOrderScalarFieldEnum)[keyof typeof BookOrderScalarFieldEnum]


  export const BookOrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    bookId: 'bookId',
    price: 'price'
  };

  export type BookOrderItemScalarFieldEnum = (typeof BookOrderItemScalarFieldEnum)[keyof typeof BookOrderItemScalarFieldEnum]


  export const BookPurchaseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bookId: 'bookId',
    orderId: 'orderId',
    purchaseDate: 'purchaseDate',
    accessGranted: 'accessGranted'
  };

  export type BookPurchaseScalarFieldEnum = (typeof BookPurchaseScalarFieldEnum)[keyof typeof BookPurchaseScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    referenceId: 'referenceId',
    provider: 'provider',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const NewsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    titleEn: 'titleEn',
    slug: 'slug',
    excerpt: 'excerpt',
    image: 'image',
    category: 'category',
    date: 'date',
    readTime: 'readTime',
    views: 'views',
    featured: 'featured',
    content: 'content',
    tags: 'tags',
    author: 'author',
    authorId: 'authorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NewsScalarFieldEnum = (typeof NewsScalarFieldEnum)[keyof typeof NewsScalarFieldEnum]


  export const GopalPariwarScalarFieldEnum: {
    id: 'id',
    heroImage: 'heroImage',
    heroTitle: 'heroTitle',
    heroSubtitle: 'heroSubtitle',
    personalInfo: 'personalInfo',
    spiritualEducation: 'spiritualEducation',
    lifeJourney: 'lifeJourney',
    responsibilities: 'responsibilities',
    pledges: 'pledges',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GopalPariwarScalarFieldEnum = (typeof GopalPariwarScalarFieldEnum)[keyof typeof GopalPariwarScalarFieldEnum]


  export const GaushalaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    photo: 'photo',
    address: 'address',
    establishmentYear: 'establishmentYear',
    contactDetails: 'contactDetails',
    totalCows: 'totalCows',
    capacity: 'capacity',
    description: 'description',
    city: 'city',
    state: 'state',
    pincode: 'pincode',
    contactPerson: 'contactPerson',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GaushalaScalarFieldEnum = (typeof GaushalaScalarFieldEnum)[keyof typeof GaushalaScalarFieldEnum]


  export const CardScalarFieldEnum: {
    id: 'id',
    title: 'title',
    titleEn: 'titleEn',
    link: 'link',
    image: 'image',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CardScalarFieldEnum = (typeof CardScalarFieldEnum)[keyof typeof CardScalarFieldEnum]


  export const DtaSanssthanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    person: 'person',
    image: 'image',
    description: 'description',
    email: 'email',
    phone: 'phone',
    altPhone: 'altPhone',
    website: 'website',
    timing: 'timing',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DtaSanssthanScalarFieldEnum = (typeof DtaSanssthanScalarFieldEnum)[keyof typeof DtaSanssthanScalarFieldEnum]


  export const PrivacyPolicyScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    sections: 'sections',
    email: 'email',
    phone: 'phone',
    callingHours: 'callingHours',
    mailingAddress: 'mailingAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PrivacyPolicyScalarFieldEnum = (typeof PrivacyPolicyScalarFieldEnum)[keyof typeof PrivacyPolicyScalarFieldEnum]


  export const TermsConditionsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    sections: 'sections',
    email: 'email',
    phone: 'phone',
    callingHours: 'callingHours',
    mailingAddress: 'mailingAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TermsConditionsScalarFieldEnum = (typeof TermsConditionsScalarFieldEnum)[keyof typeof TermsConditionsScalarFieldEnum]


  export const BannerScalarFieldEnum: {
    id: 'id',
    title: 'title',
    image: 'image',
    active: 'active',
    order: 'order',
    publicId: 'publicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BannerScalarFieldEnum = (typeof BannerScalarFieldEnum)[keyof typeof BannerScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    info: 'info',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const FoundationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tagline: 'tagline',
    logoUrl: 'logoUrl',
    description: 'description',
    establishedYear: 'establishedYear',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type FoundationScalarFieldEnum = (typeof FoundationScalarFieldEnum)[keyof typeof FoundationScalarFieldEnum]


  export const FoundationStatScalarFieldEnum: {
    id: 'id',
    foundationId: 'foundationId',
    label: 'label',
    value: 'value',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoundationStatScalarFieldEnum = (typeof FoundationStatScalarFieldEnum)[keyof typeof FoundationStatScalarFieldEnum]


  export const FoundationActivityScalarFieldEnum: {
    id: 'id',
    foundationId: 'foundationId',
    activityText: 'activityText',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoundationActivityScalarFieldEnum = (typeof FoundationActivityScalarFieldEnum)[keyof typeof FoundationActivityScalarFieldEnum]


  export const FoundationObjectiveScalarFieldEnum: {
    id: 'id',
    foundationId: 'foundationId',
    title: 'title',
    description: 'description',
    objectiveType: 'objectiveType',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoundationObjectiveScalarFieldEnum = (typeof FoundationObjectiveScalarFieldEnum)[keyof typeof FoundationObjectiveScalarFieldEnum]


  export const FoundationContactScalarFieldEnum: {
    id: 'id',
    foundationId: 'foundationId',
    email: 'email',
    phone: 'phone',
    address: 'address',
    website: 'website',
    socialMediaLinks: 'socialMediaLinks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoundationContactScalarFieldEnum = (typeof FoundationContactScalarFieldEnum)[keyof typeof FoundationContactScalarFieldEnum]


  export const FoundationMediaScalarFieldEnum: {
    id: 'id',
    foundationId: 'foundationId',
    fileName: 'fileName',
    filePath: 'filePath',
    fileType: 'fileType',
    fileSize: 'fileSize',
    mediaType: 'mediaType',
    altText: 'altText',
    createdAt: 'createdAt'
  };

  export type FoundationMediaScalarFieldEnum = (typeof FoundationMediaScalarFieldEnum)[keyof typeof FoundationMediaScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    startDate: 'startDate',
    endDate: 'endDate',
    time: 'time',
    location: 'location',
    duration: 'duration',
    color: 'color',
    liveLinks: 'liveLinks',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const BhajanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    artist: 'artist',
    album: 'album',
    duration: 'duration',
    imageUrl: 'imageUrl',
    audioUrl: 'audioUrl',
    audioPath: 'audioPath',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BhajanScalarFieldEnum = (typeof BhajanScalarFieldEnum)[keyof typeof BhajanScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    password: 'password',
    image: 'image',
    address: 'address',
    phone: 'phone',
    otpCode: 'otpCode',
    resetToken: 'resetToken',
    role: 'role'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const DonationOrderByRelevanceFieldEnum: {
    status: 'status',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId'
  };

  export type DonationOrderByRelevanceFieldEnum = (typeof DonationOrderByRelevanceFieldEnum)[keyof typeof DonationOrderByRelevanceFieldEnum]


  export const BookOrderByRelevanceFieldEnum: {
    name: 'name',
    author: 'author',
    fileName: 'fileName',
    filePath: 'filePath',
    fileSize: 'fileSize',
    description: 'description',
    coverImage: 'coverImage'
  };

  export type BookOrderByRelevanceFieldEnum = (typeof BookOrderByRelevanceFieldEnum)[keyof typeof BookOrderByRelevanceFieldEnum]


  export const BookCouponOrderByRelevanceFieldEnum: {
    code: 'code',
    type: 'type',
    description: 'description'
  };

  export type BookCouponOrderByRelevanceFieldEnum = (typeof BookCouponOrderByRelevanceFieldEnum)[keyof typeof BookCouponOrderByRelevanceFieldEnum]


  export const BookOrderOrderByRelevanceFieldEnum: {
    paymentId: 'paymentId',
    orderId: 'orderId',
    status: 'status'
  };

  export type BookOrderOrderByRelevanceFieldEnum = (typeof BookOrderOrderByRelevanceFieldEnum)[keyof typeof BookOrderOrderByRelevanceFieldEnum]


  export const PaymentOrderByRelevanceFieldEnum: {
    referenceId: 'referenceId',
    provider: 'provider',
    status: 'status'
  };

  export type PaymentOrderByRelevanceFieldEnum = (typeof PaymentOrderByRelevanceFieldEnum)[keyof typeof PaymentOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NewsOrderByRelevanceFieldEnum: {
    title: 'title',
    titleEn: 'titleEn',
    slug: 'slug',
    excerpt: 'excerpt',
    image: 'image',
    category: 'category',
    date: 'date',
    readTime: 'readTime',
    author: 'author'
  };

  export type NewsOrderByRelevanceFieldEnum = (typeof NewsOrderByRelevanceFieldEnum)[keyof typeof NewsOrderByRelevanceFieldEnum]


  export const GopalPariwarOrderByRelevanceFieldEnum: {
    heroImage: 'heroImage',
    heroTitle: 'heroTitle',
    heroSubtitle: 'heroSubtitle',
    spiritualEducation: 'spiritualEducation'
  };

  export type GopalPariwarOrderByRelevanceFieldEnum = (typeof GopalPariwarOrderByRelevanceFieldEnum)[keyof typeof GopalPariwarOrderByRelevanceFieldEnum]


  export const GaushalaOrderByRelevanceFieldEnum: {
    name: 'name',
    photo: 'photo',
    address: 'address',
    contactDetails: 'contactDetails',
    description: 'description',
    city: 'city',
    state: 'state',
    pincode: 'pincode',
    contactPerson: 'contactPerson'
  };

  export type GaushalaOrderByRelevanceFieldEnum = (typeof GaushalaOrderByRelevanceFieldEnum)[keyof typeof GaushalaOrderByRelevanceFieldEnum]


  export const CardOrderByRelevanceFieldEnum: {
    title: 'title',
    titleEn: 'titleEn',
    link: 'link',
    image: 'image'
  };

  export type CardOrderByRelevanceFieldEnum = (typeof CardOrderByRelevanceFieldEnum)[keyof typeof CardOrderByRelevanceFieldEnum]


  export const DtaSanssthanOrderByRelevanceFieldEnum: {
    name: 'name',
    person: 'person',
    image: 'image',
    description: 'description',
    email: 'email',
    phone: 'phone',
    altPhone: 'altPhone',
    website: 'website',
    timing: 'timing'
  };

  export type DtaSanssthanOrderByRelevanceFieldEnum = (typeof DtaSanssthanOrderByRelevanceFieldEnum)[keyof typeof DtaSanssthanOrderByRelevanceFieldEnum]


  export const PrivacyPolicyOrderByRelevanceFieldEnum: {
    title: 'title',
    subtitle: 'subtitle',
    email: 'email',
    phone: 'phone',
    callingHours: 'callingHours',
    mailingAddress: 'mailingAddress'
  };

  export type PrivacyPolicyOrderByRelevanceFieldEnum = (typeof PrivacyPolicyOrderByRelevanceFieldEnum)[keyof typeof PrivacyPolicyOrderByRelevanceFieldEnum]


  export const TermsConditionsOrderByRelevanceFieldEnum: {
    title: 'title',
    subtitle: 'subtitle',
    email: 'email',
    phone: 'phone',
    callingHours: 'callingHours',
    mailingAddress: 'mailingAddress'
  };

  export type TermsConditionsOrderByRelevanceFieldEnum = (typeof TermsConditionsOrderByRelevanceFieldEnum)[keyof typeof TermsConditionsOrderByRelevanceFieldEnum]


  export const BannerOrderByRelevanceFieldEnum: {
    title: 'title',
    image: 'image',
    publicId: 'publicId'
  };

  export type BannerOrderByRelevanceFieldEnum = (typeof BannerOrderByRelevanceFieldEnum)[keyof typeof BannerOrderByRelevanceFieldEnum]


  export const MessageOrderByRelevanceFieldEnum: {
    info: 'info'
  };

  export type MessageOrderByRelevanceFieldEnum = (typeof MessageOrderByRelevanceFieldEnum)[keyof typeof MessageOrderByRelevanceFieldEnum]


  export const FoundationOrderByRelevanceFieldEnum: {
    name: 'name',
    tagline: 'tagline',
    logoUrl: 'logoUrl',
    description: 'description',
    establishedYear: 'establishedYear'
  };

  export type FoundationOrderByRelevanceFieldEnum = (typeof FoundationOrderByRelevanceFieldEnum)[keyof typeof FoundationOrderByRelevanceFieldEnum]


  export const FoundationStatOrderByRelevanceFieldEnum: {
    label: 'label',
    value: 'value'
  };

  export type FoundationStatOrderByRelevanceFieldEnum = (typeof FoundationStatOrderByRelevanceFieldEnum)[keyof typeof FoundationStatOrderByRelevanceFieldEnum]


  export const FoundationActivityOrderByRelevanceFieldEnum: {
    activityText: 'activityText'
  };

  export type FoundationActivityOrderByRelevanceFieldEnum = (typeof FoundationActivityOrderByRelevanceFieldEnum)[keyof typeof FoundationActivityOrderByRelevanceFieldEnum]


  export const FoundationObjectiveOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description'
  };

  export type FoundationObjectiveOrderByRelevanceFieldEnum = (typeof FoundationObjectiveOrderByRelevanceFieldEnum)[keyof typeof FoundationObjectiveOrderByRelevanceFieldEnum]


  export const FoundationContactOrderByRelevanceFieldEnum: {
    email: 'email',
    phone: 'phone',
    address: 'address',
    website: 'website'
  };

  export type FoundationContactOrderByRelevanceFieldEnum = (typeof FoundationContactOrderByRelevanceFieldEnum)[keyof typeof FoundationContactOrderByRelevanceFieldEnum]


  export const FoundationMediaOrderByRelevanceFieldEnum: {
    fileName: 'fileName',
    filePath: 'filePath',
    fileType: 'fileType',
    altText: 'altText'
  };

  export type FoundationMediaOrderByRelevanceFieldEnum = (typeof FoundationMediaOrderByRelevanceFieldEnum)[keyof typeof FoundationMediaOrderByRelevanceFieldEnum]


  export const EventOrderByRelevanceFieldEnum: {
    title: 'title',
    time: 'time',
    location: 'location',
    duration: 'duration',
    color: 'color',
    description: 'description'
  };

  export type EventOrderByRelevanceFieldEnum = (typeof EventOrderByRelevanceFieldEnum)[keyof typeof EventOrderByRelevanceFieldEnum]


  export const BhajanOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    artist: 'artist',
    album: 'album',
    duration: 'duration',
    imageUrl: 'imageUrl',
    audioUrl: 'audioUrl',
    audioPath: 'audioPath'
  };

  export type BhajanOrderByRelevanceFieldEnum = (typeof BhajanOrderByRelevanceFieldEnum)[keyof typeof BhajanOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ObjectiveType'
   */
  export type EnumObjectiveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ObjectiveType'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    otpCode?: StringNullableFilter<"User"> | string | null
    otpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerified?: BoolFilter<"User"> | boolean
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    bookOrders?: BookOrderListRelationFilter
    bookPurchases?: BookPurchaseListRelationFilter
    donations?: DonationListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    otpCode?: SortOrderInput | SortOrder
    otpExpires?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpires?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookOrders?: BookOrderOrderByRelationAggregateInput
    bookPurchases?: BookPurchaseOrderByRelationAggregateInput
    donations?: DonationOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    otpCode?: StringNullableFilter<"User"> | string | null
    otpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerified?: BoolFilter<"User"> | boolean
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    bookOrders?: BookOrderListRelationFilter
    bookPurchases?: BookPurchaseListRelationFilter
    donations?: DonationListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    otpCode?: SortOrderInput | SortOrder
    otpExpires?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpires?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    otpCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    otpExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type DonationWhereInput = {
    AND?: DonationWhereInput | DonationWhereInput[]
    OR?: DonationWhereInput[]
    NOT?: DonationWhereInput | DonationWhereInput[]
    id?: IntFilter<"Donation"> | number
    userId?: IntFilter<"Donation"> | number
    amount?: FloatFilter<"Donation"> | number
    status?: StringFilter<"Donation"> | string
    paymentMethod?: StringNullableFilter<"Donation"> | string | null
    transactionId?: StringFilter<"Donation"> | string
    createdAt?: DateTimeFilter<"Donation"> | Date | string
    updatedAt?: DateTimeFilter<"Donation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DonationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: DonationOrderByRelevanceInput
  }

  export type DonationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    transactionId?: string
    AND?: DonationWhereInput | DonationWhereInput[]
    OR?: DonationWhereInput[]
    NOT?: DonationWhereInput | DonationWhereInput[]
    userId?: IntFilter<"Donation"> | number
    amount?: FloatFilter<"Donation"> | number
    status?: StringFilter<"Donation"> | string
    paymentMethod?: StringNullableFilter<"Donation"> | string | null
    createdAt?: DateTimeFilter<"Donation"> | Date | string
    updatedAt?: DateTimeFilter<"Donation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "transactionId">

  export type DonationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DonationCountOrderByAggregateInput
    _avg?: DonationAvgOrderByAggregateInput
    _max?: DonationMaxOrderByAggregateInput
    _min?: DonationMinOrderByAggregateInput
    _sum?: DonationSumOrderByAggregateInput
  }

  export type DonationScalarWhereWithAggregatesInput = {
    AND?: DonationScalarWhereWithAggregatesInput | DonationScalarWhereWithAggregatesInput[]
    OR?: DonationScalarWhereWithAggregatesInput[]
    NOT?: DonationScalarWhereWithAggregatesInput | DonationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Donation"> | number
    userId?: IntWithAggregatesFilter<"Donation"> | number
    amount?: FloatWithAggregatesFilter<"Donation"> | number
    status?: StringWithAggregatesFilter<"Donation"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"Donation"> | string | null
    transactionId?: StringWithAggregatesFilter<"Donation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Donation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Donation"> | Date | string
  }

  export type BookWhereInput = {
    AND?: BookWhereInput | BookWhereInput[]
    OR?: BookWhereInput[]
    NOT?: BookWhereInput | BookWhereInput[]
    id?: IntFilter<"Book"> | number
    name?: StringFilter<"Book"> | string
    author?: StringFilter<"Book"> | string
    fileName?: StringFilter<"Book"> | string
    filePath?: StringFilter<"Book"> | string
    fileSize?: StringFilter<"Book"> | string
    price?: FloatFilter<"Book"> | number
    description?: StringNullableFilter<"Book"> | string | null
    coverImage?: StringNullableFilter<"Book"> | string | null
    uploadDate?: DateTimeFilter<"Book"> | Date | string
    createdAt?: DateTimeFilter<"Book"> | Date | string
    updatedAt?: DateTimeFilter<"Book"> | Date | string
    purchases?: BookPurchaseListRelationFilter
    orderItems?: BookOrderItemListRelationFilter
  }

  export type BookOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    author?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    uploadDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchases?: BookPurchaseOrderByRelationAggregateInput
    orderItems?: BookOrderItemOrderByRelationAggregateInput
    _relevance?: BookOrderByRelevanceInput
  }

  export type BookWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookWhereInput | BookWhereInput[]
    OR?: BookWhereInput[]
    NOT?: BookWhereInput | BookWhereInput[]
    name?: StringFilter<"Book"> | string
    author?: StringFilter<"Book"> | string
    fileName?: StringFilter<"Book"> | string
    filePath?: StringFilter<"Book"> | string
    fileSize?: StringFilter<"Book"> | string
    price?: FloatFilter<"Book"> | number
    description?: StringNullableFilter<"Book"> | string | null
    coverImage?: StringNullableFilter<"Book"> | string | null
    uploadDate?: DateTimeFilter<"Book"> | Date | string
    createdAt?: DateTimeFilter<"Book"> | Date | string
    updatedAt?: DateTimeFilter<"Book"> | Date | string
    purchases?: BookPurchaseListRelationFilter
    orderItems?: BookOrderItemListRelationFilter
  }, "id">

  export type BookOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    author?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    uploadDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookCountOrderByAggregateInput
    _avg?: BookAvgOrderByAggregateInput
    _max?: BookMaxOrderByAggregateInput
    _min?: BookMinOrderByAggregateInput
    _sum?: BookSumOrderByAggregateInput
  }

  export type BookScalarWhereWithAggregatesInput = {
    AND?: BookScalarWhereWithAggregatesInput | BookScalarWhereWithAggregatesInput[]
    OR?: BookScalarWhereWithAggregatesInput[]
    NOT?: BookScalarWhereWithAggregatesInput | BookScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Book"> | number
    name?: StringWithAggregatesFilter<"Book"> | string
    author?: StringWithAggregatesFilter<"Book"> | string
    fileName?: StringWithAggregatesFilter<"Book"> | string
    filePath?: StringWithAggregatesFilter<"Book"> | string
    fileSize?: StringWithAggregatesFilter<"Book"> | string
    price?: FloatWithAggregatesFilter<"Book"> | number
    description?: StringNullableWithAggregatesFilter<"Book"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"Book"> | string | null
    uploadDate?: DateTimeWithAggregatesFilter<"Book"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Book"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Book"> | Date | string
  }

  export type BookCouponWhereInput = {
    AND?: BookCouponWhereInput | BookCouponWhereInput[]
    OR?: BookCouponWhereInput[]
    NOT?: BookCouponWhereInput | BookCouponWhereInput[]
    id?: IntFilter<"BookCoupon"> | number
    code?: StringFilter<"BookCoupon"> | string
    discount?: FloatFilter<"BookCoupon"> | number
    type?: StringFilter<"BookCoupon"> | string
    description?: StringNullableFilter<"BookCoupon"> | string | null
    active?: BoolFilter<"BookCoupon"> | boolean
    createdAt?: DateTimeFilter<"BookCoupon"> | Date | string
    updatedAt?: DateTimeFilter<"BookCoupon"> | Date | string
    orders?: BookOrderListRelationFilter
  }

  export type BookCouponOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    discount?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: BookOrderOrderByRelationAggregateInput
    _relevance?: BookCouponOrderByRelevanceInput
  }

  export type BookCouponWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: BookCouponWhereInput | BookCouponWhereInput[]
    OR?: BookCouponWhereInput[]
    NOT?: BookCouponWhereInput | BookCouponWhereInput[]
    discount?: FloatFilter<"BookCoupon"> | number
    type?: StringFilter<"BookCoupon"> | string
    description?: StringNullableFilter<"BookCoupon"> | string | null
    active?: BoolFilter<"BookCoupon"> | boolean
    createdAt?: DateTimeFilter<"BookCoupon"> | Date | string
    updatedAt?: DateTimeFilter<"BookCoupon"> | Date | string
    orders?: BookOrderListRelationFilter
  }, "id" | "code">

  export type BookCouponOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    discount?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookCouponCountOrderByAggregateInput
    _avg?: BookCouponAvgOrderByAggregateInput
    _max?: BookCouponMaxOrderByAggregateInput
    _min?: BookCouponMinOrderByAggregateInput
    _sum?: BookCouponSumOrderByAggregateInput
  }

  export type BookCouponScalarWhereWithAggregatesInput = {
    AND?: BookCouponScalarWhereWithAggregatesInput | BookCouponScalarWhereWithAggregatesInput[]
    OR?: BookCouponScalarWhereWithAggregatesInput[]
    NOT?: BookCouponScalarWhereWithAggregatesInput | BookCouponScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BookCoupon"> | number
    code?: StringWithAggregatesFilter<"BookCoupon"> | string
    discount?: FloatWithAggregatesFilter<"BookCoupon"> | number
    type?: StringWithAggregatesFilter<"BookCoupon"> | string
    description?: StringNullableWithAggregatesFilter<"BookCoupon"> | string | null
    active?: BoolWithAggregatesFilter<"BookCoupon"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BookCoupon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BookCoupon"> | Date | string
  }

  export type BookOrderWhereInput = {
    AND?: BookOrderWhereInput | BookOrderWhereInput[]
    OR?: BookOrderWhereInput[]
    NOT?: BookOrderWhereInput | BookOrderWhereInput[]
    id?: IntFilter<"BookOrder"> | number
    userId?: IntFilter<"BookOrder"> | number
    totalAmount?: FloatFilter<"BookOrder"> | number
    discountAmount?: FloatFilter<"BookOrder"> | number
    finalAmount?: FloatFilter<"BookOrder"> | number
    couponId?: IntNullableFilter<"BookOrder"> | number | null
    paymentId?: StringNullableFilter<"BookOrder"> | string | null
    orderId?: StringNullableFilter<"BookOrder"> | string | null
    status?: StringFilter<"BookOrder"> | string
    createdAt?: DateTimeFilter<"BookOrder"> | Date | string
    updatedAt?: DateTimeFilter<"BookOrder"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coupon?: XOR<BookCouponNullableScalarRelationFilter, BookCouponWhereInput> | null
    items?: BookOrderItemListRelationFilter
    purchases?: BookPurchaseListRelationFilter
  }

  export type BookOrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    couponId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    coupon?: BookCouponOrderByWithRelationInput
    items?: BookOrderItemOrderByRelationAggregateInput
    purchases?: BookPurchaseOrderByRelationAggregateInput
    _relevance?: BookOrderOrderByRelevanceInput
  }

  export type BookOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookOrderWhereInput | BookOrderWhereInput[]
    OR?: BookOrderWhereInput[]
    NOT?: BookOrderWhereInput | BookOrderWhereInput[]
    userId?: IntFilter<"BookOrder"> | number
    totalAmount?: FloatFilter<"BookOrder"> | number
    discountAmount?: FloatFilter<"BookOrder"> | number
    finalAmount?: FloatFilter<"BookOrder"> | number
    couponId?: IntNullableFilter<"BookOrder"> | number | null
    paymentId?: StringNullableFilter<"BookOrder"> | string | null
    orderId?: StringNullableFilter<"BookOrder"> | string | null
    status?: StringFilter<"BookOrder"> | string
    createdAt?: DateTimeFilter<"BookOrder"> | Date | string
    updatedAt?: DateTimeFilter<"BookOrder"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coupon?: XOR<BookCouponNullableScalarRelationFilter, BookCouponWhereInput> | null
    items?: BookOrderItemListRelationFilter
    purchases?: BookPurchaseListRelationFilter
  }, "id">

  export type BookOrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    couponId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookOrderCountOrderByAggregateInput
    _avg?: BookOrderAvgOrderByAggregateInput
    _max?: BookOrderMaxOrderByAggregateInput
    _min?: BookOrderMinOrderByAggregateInput
    _sum?: BookOrderSumOrderByAggregateInput
  }

  export type BookOrderScalarWhereWithAggregatesInput = {
    AND?: BookOrderScalarWhereWithAggregatesInput | BookOrderScalarWhereWithAggregatesInput[]
    OR?: BookOrderScalarWhereWithAggregatesInput[]
    NOT?: BookOrderScalarWhereWithAggregatesInput | BookOrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BookOrder"> | number
    userId?: IntWithAggregatesFilter<"BookOrder"> | number
    totalAmount?: FloatWithAggregatesFilter<"BookOrder"> | number
    discountAmount?: FloatWithAggregatesFilter<"BookOrder"> | number
    finalAmount?: FloatWithAggregatesFilter<"BookOrder"> | number
    couponId?: IntNullableWithAggregatesFilter<"BookOrder"> | number | null
    paymentId?: StringNullableWithAggregatesFilter<"BookOrder"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"BookOrder"> | string | null
    status?: StringWithAggregatesFilter<"BookOrder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BookOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BookOrder"> | Date | string
  }

  export type BookOrderItemWhereInput = {
    AND?: BookOrderItemWhereInput | BookOrderItemWhereInput[]
    OR?: BookOrderItemWhereInput[]
    NOT?: BookOrderItemWhereInput | BookOrderItemWhereInput[]
    id?: IntFilter<"BookOrderItem"> | number
    orderId?: IntFilter<"BookOrderItem"> | number
    bookId?: IntFilter<"BookOrderItem"> | number
    price?: FloatFilter<"BookOrderItem"> | number
    order?: XOR<BookOrderScalarRelationFilter, BookOrderWhereInput>
    book?: XOR<BookScalarRelationFilter, BookWhereInput>
  }

  export type BookOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    bookId?: SortOrder
    price?: SortOrder
    order?: BookOrderOrderByWithRelationInput
    book?: BookOrderByWithRelationInput
  }

  export type BookOrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookOrderItemWhereInput | BookOrderItemWhereInput[]
    OR?: BookOrderItemWhereInput[]
    NOT?: BookOrderItemWhereInput | BookOrderItemWhereInput[]
    orderId?: IntFilter<"BookOrderItem"> | number
    bookId?: IntFilter<"BookOrderItem"> | number
    price?: FloatFilter<"BookOrderItem"> | number
    order?: XOR<BookOrderScalarRelationFilter, BookOrderWhereInput>
    book?: XOR<BookScalarRelationFilter, BookWhereInput>
  }, "id">

  export type BookOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    bookId?: SortOrder
    price?: SortOrder
    _count?: BookOrderItemCountOrderByAggregateInput
    _avg?: BookOrderItemAvgOrderByAggregateInput
    _max?: BookOrderItemMaxOrderByAggregateInput
    _min?: BookOrderItemMinOrderByAggregateInput
    _sum?: BookOrderItemSumOrderByAggregateInput
  }

  export type BookOrderItemScalarWhereWithAggregatesInput = {
    AND?: BookOrderItemScalarWhereWithAggregatesInput | BookOrderItemScalarWhereWithAggregatesInput[]
    OR?: BookOrderItemScalarWhereWithAggregatesInput[]
    NOT?: BookOrderItemScalarWhereWithAggregatesInput | BookOrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BookOrderItem"> | number
    orderId?: IntWithAggregatesFilter<"BookOrderItem"> | number
    bookId?: IntWithAggregatesFilter<"BookOrderItem"> | number
    price?: FloatWithAggregatesFilter<"BookOrderItem"> | number
  }

  export type BookPurchaseWhereInput = {
    AND?: BookPurchaseWhereInput | BookPurchaseWhereInput[]
    OR?: BookPurchaseWhereInput[]
    NOT?: BookPurchaseWhereInput | BookPurchaseWhereInput[]
    id?: IntFilter<"BookPurchase"> | number
    userId?: IntFilter<"BookPurchase"> | number
    bookId?: IntFilter<"BookPurchase"> | number
    orderId?: IntFilter<"BookPurchase"> | number
    purchaseDate?: DateTimeFilter<"BookPurchase"> | Date | string
    accessGranted?: BoolFilter<"BookPurchase"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    book?: XOR<BookScalarRelationFilter, BookWhereInput>
    order?: XOR<BookOrderScalarRelationFilter, BookOrderWhereInput>
  }

  export type BookPurchaseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    orderId?: SortOrder
    purchaseDate?: SortOrder
    accessGranted?: SortOrder
    user?: UserOrderByWithRelationInput
    book?: BookOrderByWithRelationInput
    order?: BookOrderOrderByWithRelationInput
  }

  export type BookPurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_bookId?: BookPurchaseUserIdBookIdCompoundUniqueInput
    AND?: BookPurchaseWhereInput | BookPurchaseWhereInput[]
    OR?: BookPurchaseWhereInput[]
    NOT?: BookPurchaseWhereInput | BookPurchaseWhereInput[]
    userId?: IntFilter<"BookPurchase"> | number
    bookId?: IntFilter<"BookPurchase"> | number
    orderId?: IntFilter<"BookPurchase"> | number
    purchaseDate?: DateTimeFilter<"BookPurchase"> | Date | string
    accessGranted?: BoolFilter<"BookPurchase"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    book?: XOR<BookScalarRelationFilter, BookWhereInput>
    order?: XOR<BookOrderScalarRelationFilter, BookOrderWhereInput>
  }, "id" | "userId_bookId">

  export type BookPurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    orderId?: SortOrder
    purchaseDate?: SortOrder
    accessGranted?: SortOrder
    _count?: BookPurchaseCountOrderByAggregateInput
    _avg?: BookPurchaseAvgOrderByAggregateInput
    _max?: BookPurchaseMaxOrderByAggregateInput
    _min?: BookPurchaseMinOrderByAggregateInput
    _sum?: BookPurchaseSumOrderByAggregateInput
  }

  export type BookPurchaseScalarWhereWithAggregatesInput = {
    AND?: BookPurchaseScalarWhereWithAggregatesInput | BookPurchaseScalarWhereWithAggregatesInput[]
    OR?: BookPurchaseScalarWhereWithAggregatesInput[]
    NOT?: BookPurchaseScalarWhereWithAggregatesInput | BookPurchaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BookPurchase"> | number
    userId?: IntWithAggregatesFilter<"BookPurchase"> | number
    bookId?: IntWithAggregatesFilter<"BookPurchase"> | number
    orderId?: IntWithAggregatesFilter<"BookPurchase"> | number
    purchaseDate?: DateTimeWithAggregatesFilter<"BookPurchase"> | Date | string
    accessGranted?: BoolWithAggregatesFilter<"BookPurchase"> | boolean
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    userId?: IntFilter<"Payment"> | number
    referenceId?: StringFilter<"Payment"> | string
    provider?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    referenceId?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: PaymentOrderByRelevanceInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    userId?: IntFilter<"Payment"> | number
    referenceId?: StringFilter<"Payment"> | string
    provider?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    referenceId?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    userId?: IntWithAggregatesFilter<"Payment"> | number
    referenceId?: StringWithAggregatesFilter<"Payment"> | string
    provider?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    status?: StringWithAggregatesFilter<"Payment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type NewsWhereInput = {
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    id?: IntFilter<"News"> | number
    title?: StringFilter<"News"> | string
    titleEn?: StringFilter<"News"> | string
    slug?: StringFilter<"News"> | string
    excerpt?: StringFilter<"News"> | string
    image?: StringFilter<"News"> | string
    category?: StringFilter<"News"> | string
    date?: StringFilter<"News"> | string
    readTime?: StringFilter<"News"> | string
    views?: IntFilter<"News"> | number
    featured?: BoolFilter<"News"> | boolean
    content?: JsonFilter<"News">
    tags?: JsonFilter<"News">
    author?: StringFilter<"News"> | string
    authorId?: IntNullableFilter<"News"> | number | null
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
  }

  export type NewsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    image?: SortOrder
    category?: SortOrder
    date?: SortOrder
    readTime?: SortOrder
    views?: SortOrder
    featured?: SortOrder
    content?: SortOrder
    tags?: SortOrder
    author?: SortOrder
    authorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: NewsOrderByRelevanceInput
  }

  export type NewsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    title?: StringFilter<"News"> | string
    titleEn?: StringFilter<"News"> | string
    excerpt?: StringFilter<"News"> | string
    image?: StringFilter<"News"> | string
    category?: StringFilter<"News"> | string
    date?: StringFilter<"News"> | string
    readTime?: StringFilter<"News"> | string
    views?: IntFilter<"News"> | number
    featured?: BoolFilter<"News"> | boolean
    content?: JsonFilter<"News">
    tags?: JsonFilter<"News">
    author?: StringFilter<"News"> | string
    authorId?: IntNullableFilter<"News"> | number | null
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
  }, "id" | "slug">

  export type NewsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    image?: SortOrder
    category?: SortOrder
    date?: SortOrder
    readTime?: SortOrder
    views?: SortOrder
    featured?: SortOrder
    content?: SortOrder
    tags?: SortOrder
    author?: SortOrder
    authorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NewsCountOrderByAggregateInput
    _avg?: NewsAvgOrderByAggregateInput
    _max?: NewsMaxOrderByAggregateInput
    _min?: NewsMinOrderByAggregateInput
    _sum?: NewsSumOrderByAggregateInput
  }

  export type NewsScalarWhereWithAggregatesInput = {
    AND?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    OR?: NewsScalarWhereWithAggregatesInput[]
    NOT?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"News"> | number
    title?: StringWithAggregatesFilter<"News"> | string
    titleEn?: StringWithAggregatesFilter<"News"> | string
    slug?: StringWithAggregatesFilter<"News"> | string
    excerpt?: StringWithAggregatesFilter<"News"> | string
    image?: StringWithAggregatesFilter<"News"> | string
    category?: StringWithAggregatesFilter<"News"> | string
    date?: StringWithAggregatesFilter<"News"> | string
    readTime?: StringWithAggregatesFilter<"News"> | string
    views?: IntWithAggregatesFilter<"News"> | number
    featured?: BoolWithAggregatesFilter<"News"> | boolean
    content?: JsonWithAggregatesFilter<"News">
    tags?: JsonWithAggregatesFilter<"News">
    author?: StringWithAggregatesFilter<"News"> | string
    authorId?: IntNullableWithAggregatesFilter<"News"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"News"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"News"> | Date | string
  }

  export type GopalPariwarWhereInput = {
    AND?: GopalPariwarWhereInput | GopalPariwarWhereInput[]
    OR?: GopalPariwarWhereInput[]
    NOT?: GopalPariwarWhereInput | GopalPariwarWhereInput[]
    id?: IntFilter<"GopalPariwar"> | number
    heroImage?: StringFilter<"GopalPariwar"> | string
    heroTitle?: StringFilter<"GopalPariwar"> | string
    heroSubtitle?: StringFilter<"GopalPariwar"> | string
    personalInfo?: JsonFilter<"GopalPariwar">
    spiritualEducation?: StringNullableFilter<"GopalPariwar"> | string | null
    lifeJourney?: JsonFilter<"GopalPariwar">
    responsibilities?: JsonFilter<"GopalPariwar">
    pledges?: JsonFilter<"GopalPariwar">
    createdAt?: DateTimeFilter<"GopalPariwar"> | Date | string
    updatedAt?: DateTimeFilter<"GopalPariwar"> | Date | string
  }

  export type GopalPariwarOrderByWithRelationInput = {
    id?: SortOrder
    heroImage?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    personalInfo?: SortOrder
    spiritualEducation?: SortOrderInput | SortOrder
    lifeJourney?: SortOrder
    responsibilities?: SortOrder
    pledges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: GopalPariwarOrderByRelevanceInput
  }

  export type GopalPariwarWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GopalPariwarWhereInput | GopalPariwarWhereInput[]
    OR?: GopalPariwarWhereInput[]
    NOT?: GopalPariwarWhereInput | GopalPariwarWhereInput[]
    heroImage?: StringFilter<"GopalPariwar"> | string
    heroTitle?: StringFilter<"GopalPariwar"> | string
    heroSubtitle?: StringFilter<"GopalPariwar"> | string
    personalInfo?: JsonFilter<"GopalPariwar">
    spiritualEducation?: StringNullableFilter<"GopalPariwar"> | string | null
    lifeJourney?: JsonFilter<"GopalPariwar">
    responsibilities?: JsonFilter<"GopalPariwar">
    pledges?: JsonFilter<"GopalPariwar">
    createdAt?: DateTimeFilter<"GopalPariwar"> | Date | string
    updatedAt?: DateTimeFilter<"GopalPariwar"> | Date | string
  }, "id">

  export type GopalPariwarOrderByWithAggregationInput = {
    id?: SortOrder
    heroImage?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    personalInfo?: SortOrder
    spiritualEducation?: SortOrderInput | SortOrder
    lifeJourney?: SortOrder
    responsibilities?: SortOrder
    pledges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GopalPariwarCountOrderByAggregateInput
    _avg?: GopalPariwarAvgOrderByAggregateInput
    _max?: GopalPariwarMaxOrderByAggregateInput
    _min?: GopalPariwarMinOrderByAggregateInput
    _sum?: GopalPariwarSumOrderByAggregateInput
  }

  export type GopalPariwarScalarWhereWithAggregatesInput = {
    AND?: GopalPariwarScalarWhereWithAggregatesInput | GopalPariwarScalarWhereWithAggregatesInput[]
    OR?: GopalPariwarScalarWhereWithAggregatesInput[]
    NOT?: GopalPariwarScalarWhereWithAggregatesInput | GopalPariwarScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GopalPariwar"> | number
    heroImage?: StringWithAggregatesFilter<"GopalPariwar"> | string
    heroTitle?: StringWithAggregatesFilter<"GopalPariwar"> | string
    heroSubtitle?: StringWithAggregatesFilter<"GopalPariwar"> | string
    personalInfo?: JsonWithAggregatesFilter<"GopalPariwar">
    spiritualEducation?: StringNullableWithAggregatesFilter<"GopalPariwar"> | string | null
    lifeJourney?: JsonWithAggregatesFilter<"GopalPariwar">
    responsibilities?: JsonWithAggregatesFilter<"GopalPariwar">
    pledges?: JsonWithAggregatesFilter<"GopalPariwar">
    createdAt?: DateTimeWithAggregatesFilter<"GopalPariwar"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GopalPariwar"> | Date | string
  }

  export type GaushalaWhereInput = {
    AND?: GaushalaWhereInput | GaushalaWhereInput[]
    OR?: GaushalaWhereInput[]
    NOT?: GaushalaWhereInput | GaushalaWhereInput[]
    id?: IntFilter<"Gaushala"> | number
    name?: StringFilter<"Gaushala"> | string
    photo?: StringNullableFilter<"Gaushala"> | string | null
    address?: StringFilter<"Gaushala"> | string
    establishmentYear?: IntFilter<"Gaushala"> | number
    contactDetails?: StringFilter<"Gaushala"> | string
    totalCows?: IntFilter<"Gaushala"> | number
    capacity?: IntFilter<"Gaushala"> | number
    description?: StringNullableFilter<"Gaushala"> | string | null
    city?: StringFilter<"Gaushala"> | string
    state?: StringFilter<"Gaushala"> | string
    pincode?: StringFilter<"Gaushala"> | string
    contactPerson?: StringFilter<"Gaushala"> | string
    createdAt?: DateTimeFilter<"Gaushala"> | Date | string
    updatedAt?: DateTimeFilter<"Gaushala"> | Date | string
  }

  export type GaushalaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    photo?: SortOrderInput | SortOrder
    address?: SortOrder
    establishmentYear?: SortOrder
    contactDetails?: SortOrder
    totalCows?: SortOrder
    capacity?: SortOrder
    description?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    contactPerson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: GaushalaOrderByRelevanceInput
  }

  export type GaushalaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GaushalaWhereInput | GaushalaWhereInput[]
    OR?: GaushalaWhereInput[]
    NOT?: GaushalaWhereInput | GaushalaWhereInput[]
    name?: StringFilter<"Gaushala"> | string
    photo?: StringNullableFilter<"Gaushala"> | string | null
    address?: StringFilter<"Gaushala"> | string
    establishmentYear?: IntFilter<"Gaushala"> | number
    contactDetails?: StringFilter<"Gaushala"> | string
    totalCows?: IntFilter<"Gaushala"> | number
    capacity?: IntFilter<"Gaushala"> | number
    description?: StringNullableFilter<"Gaushala"> | string | null
    city?: StringFilter<"Gaushala"> | string
    state?: StringFilter<"Gaushala"> | string
    pincode?: StringFilter<"Gaushala"> | string
    contactPerson?: StringFilter<"Gaushala"> | string
    createdAt?: DateTimeFilter<"Gaushala"> | Date | string
    updatedAt?: DateTimeFilter<"Gaushala"> | Date | string
  }, "id">

  export type GaushalaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    photo?: SortOrderInput | SortOrder
    address?: SortOrder
    establishmentYear?: SortOrder
    contactDetails?: SortOrder
    totalCows?: SortOrder
    capacity?: SortOrder
    description?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    contactPerson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GaushalaCountOrderByAggregateInput
    _avg?: GaushalaAvgOrderByAggregateInput
    _max?: GaushalaMaxOrderByAggregateInput
    _min?: GaushalaMinOrderByAggregateInput
    _sum?: GaushalaSumOrderByAggregateInput
  }

  export type GaushalaScalarWhereWithAggregatesInput = {
    AND?: GaushalaScalarWhereWithAggregatesInput | GaushalaScalarWhereWithAggregatesInput[]
    OR?: GaushalaScalarWhereWithAggregatesInput[]
    NOT?: GaushalaScalarWhereWithAggregatesInput | GaushalaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Gaushala"> | number
    name?: StringWithAggregatesFilter<"Gaushala"> | string
    photo?: StringNullableWithAggregatesFilter<"Gaushala"> | string | null
    address?: StringWithAggregatesFilter<"Gaushala"> | string
    establishmentYear?: IntWithAggregatesFilter<"Gaushala"> | number
    contactDetails?: StringWithAggregatesFilter<"Gaushala"> | string
    totalCows?: IntWithAggregatesFilter<"Gaushala"> | number
    capacity?: IntWithAggregatesFilter<"Gaushala"> | number
    description?: StringNullableWithAggregatesFilter<"Gaushala"> | string | null
    city?: StringWithAggregatesFilter<"Gaushala"> | string
    state?: StringWithAggregatesFilter<"Gaushala"> | string
    pincode?: StringWithAggregatesFilter<"Gaushala"> | string
    contactPerson?: StringWithAggregatesFilter<"Gaushala"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Gaushala"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Gaushala"> | Date | string
  }

  export type CardWhereInput = {
    AND?: CardWhereInput | CardWhereInput[]
    OR?: CardWhereInput[]
    NOT?: CardWhereInput | CardWhereInput[]
    id?: IntFilter<"Card"> | number
    title?: StringFilter<"Card"> | string
    titleEn?: StringNullableFilter<"Card"> | string | null
    link?: StringFilter<"Card"> | string
    image?: StringNullableFilter<"Card"> | string | null
    order?: IntNullableFilter<"Card"> | number | null
    createdAt?: DateTimeFilter<"Card"> | Date | string
    updatedAt?: DateTimeFilter<"Card"> | Date | string
  }

  export type CardOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrderInput | SortOrder
    link?: SortOrder
    image?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: CardOrderByRelevanceInput
  }

  export type CardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CardWhereInput | CardWhereInput[]
    OR?: CardWhereInput[]
    NOT?: CardWhereInput | CardWhereInput[]
    title?: StringFilter<"Card"> | string
    titleEn?: StringNullableFilter<"Card"> | string | null
    link?: StringFilter<"Card"> | string
    image?: StringNullableFilter<"Card"> | string | null
    order?: IntNullableFilter<"Card"> | number | null
    createdAt?: DateTimeFilter<"Card"> | Date | string
    updatedAt?: DateTimeFilter<"Card"> | Date | string
  }, "id">

  export type CardOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrderInput | SortOrder
    link?: SortOrder
    image?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CardCountOrderByAggregateInput
    _avg?: CardAvgOrderByAggregateInput
    _max?: CardMaxOrderByAggregateInput
    _min?: CardMinOrderByAggregateInput
    _sum?: CardSumOrderByAggregateInput
  }

  export type CardScalarWhereWithAggregatesInput = {
    AND?: CardScalarWhereWithAggregatesInput | CardScalarWhereWithAggregatesInput[]
    OR?: CardScalarWhereWithAggregatesInput[]
    NOT?: CardScalarWhereWithAggregatesInput | CardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Card"> | number
    title?: StringWithAggregatesFilter<"Card"> | string
    titleEn?: StringNullableWithAggregatesFilter<"Card"> | string | null
    link?: StringWithAggregatesFilter<"Card"> | string
    image?: StringNullableWithAggregatesFilter<"Card"> | string | null
    order?: IntNullableWithAggregatesFilter<"Card"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Card"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Card"> | Date | string
  }

  export type DtaSanssthanWhereInput = {
    AND?: DtaSanssthanWhereInput | DtaSanssthanWhereInput[]
    OR?: DtaSanssthanWhereInput[]
    NOT?: DtaSanssthanWhereInput | DtaSanssthanWhereInput[]
    id?: IntFilter<"DtaSanssthan"> | number
    name?: StringFilter<"DtaSanssthan"> | string
    person?: StringNullableFilter<"DtaSanssthan"> | string | null
    image?: StringNullableFilter<"DtaSanssthan"> | string | null
    description?: StringNullableFilter<"DtaSanssthan"> | string | null
    email?: StringNullableFilter<"DtaSanssthan"> | string | null
    phone?: StringNullableFilter<"DtaSanssthan"> | string | null
    altPhone?: StringNullableFilter<"DtaSanssthan"> | string | null
    website?: StringNullableFilter<"DtaSanssthan"> | string | null
    timing?: StringNullableFilter<"DtaSanssthan"> | string | null
    createdAt?: DateTimeFilter<"DtaSanssthan"> | Date | string
    updatedAt?: DateTimeFilter<"DtaSanssthan"> | Date | string
  }

  export type DtaSanssthanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    person?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    altPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    timing?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: DtaSanssthanOrderByRelevanceInput
  }

  export type DtaSanssthanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DtaSanssthanWhereInput | DtaSanssthanWhereInput[]
    OR?: DtaSanssthanWhereInput[]
    NOT?: DtaSanssthanWhereInput | DtaSanssthanWhereInput[]
    name?: StringFilter<"DtaSanssthan"> | string
    person?: StringNullableFilter<"DtaSanssthan"> | string | null
    image?: StringNullableFilter<"DtaSanssthan"> | string | null
    description?: StringNullableFilter<"DtaSanssthan"> | string | null
    email?: StringNullableFilter<"DtaSanssthan"> | string | null
    phone?: StringNullableFilter<"DtaSanssthan"> | string | null
    altPhone?: StringNullableFilter<"DtaSanssthan"> | string | null
    website?: StringNullableFilter<"DtaSanssthan"> | string | null
    timing?: StringNullableFilter<"DtaSanssthan"> | string | null
    createdAt?: DateTimeFilter<"DtaSanssthan"> | Date | string
    updatedAt?: DateTimeFilter<"DtaSanssthan"> | Date | string
  }, "id">

  export type DtaSanssthanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    person?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    altPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    timing?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DtaSanssthanCountOrderByAggregateInput
    _avg?: DtaSanssthanAvgOrderByAggregateInput
    _max?: DtaSanssthanMaxOrderByAggregateInput
    _min?: DtaSanssthanMinOrderByAggregateInput
    _sum?: DtaSanssthanSumOrderByAggregateInput
  }

  export type DtaSanssthanScalarWhereWithAggregatesInput = {
    AND?: DtaSanssthanScalarWhereWithAggregatesInput | DtaSanssthanScalarWhereWithAggregatesInput[]
    OR?: DtaSanssthanScalarWhereWithAggregatesInput[]
    NOT?: DtaSanssthanScalarWhereWithAggregatesInput | DtaSanssthanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DtaSanssthan"> | number
    name?: StringWithAggregatesFilter<"DtaSanssthan"> | string
    person?: StringNullableWithAggregatesFilter<"DtaSanssthan"> | string | null
    image?: StringNullableWithAggregatesFilter<"DtaSanssthan"> | string | null
    description?: StringNullableWithAggregatesFilter<"DtaSanssthan"> | string | null
    email?: StringNullableWithAggregatesFilter<"DtaSanssthan"> | string | null
    phone?: StringNullableWithAggregatesFilter<"DtaSanssthan"> | string | null
    altPhone?: StringNullableWithAggregatesFilter<"DtaSanssthan"> | string | null
    website?: StringNullableWithAggregatesFilter<"DtaSanssthan"> | string | null
    timing?: StringNullableWithAggregatesFilter<"DtaSanssthan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DtaSanssthan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DtaSanssthan"> | Date | string
  }

  export type PrivacyPolicyWhereInput = {
    AND?: PrivacyPolicyWhereInput | PrivacyPolicyWhereInput[]
    OR?: PrivacyPolicyWhereInput[]
    NOT?: PrivacyPolicyWhereInput | PrivacyPolicyWhereInput[]
    id?: IntFilter<"PrivacyPolicy"> | number
    title?: StringFilter<"PrivacyPolicy"> | string
    subtitle?: StringNullableFilter<"PrivacyPolicy"> | string | null
    sections?: JsonFilter<"PrivacyPolicy">
    email?: StringNullableFilter<"PrivacyPolicy"> | string | null
    phone?: StringNullableFilter<"PrivacyPolicy"> | string | null
    callingHours?: StringNullableFilter<"PrivacyPolicy"> | string | null
    mailingAddress?: StringNullableFilter<"PrivacyPolicy"> | string | null
    createdAt?: DateTimeFilter<"PrivacyPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"PrivacyPolicy"> | Date | string
  }

  export type PrivacyPolicyOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    sections?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    callingHours?: SortOrderInput | SortOrder
    mailingAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: PrivacyPolicyOrderByRelevanceInput
  }

  export type PrivacyPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PrivacyPolicyWhereInput | PrivacyPolicyWhereInput[]
    OR?: PrivacyPolicyWhereInput[]
    NOT?: PrivacyPolicyWhereInput | PrivacyPolicyWhereInput[]
    title?: StringFilter<"PrivacyPolicy"> | string
    subtitle?: StringNullableFilter<"PrivacyPolicy"> | string | null
    sections?: JsonFilter<"PrivacyPolicy">
    email?: StringNullableFilter<"PrivacyPolicy"> | string | null
    phone?: StringNullableFilter<"PrivacyPolicy"> | string | null
    callingHours?: StringNullableFilter<"PrivacyPolicy"> | string | null
    mailingAddress?: StringNullableFilter<"PrivacyPolicy"> | string | null
    createdAt?: DateTimeFilter<"PrivacyPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"PrivacyPolicy"> | Date | string
  }, "id">

  export type PrivacyPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    sections?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    callingHours?: SortOrderInput | SortOrder
    mailingAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PrivacyPolicyCountOrderByAggregateInput
    _avg?: PrivacyPolicyAvgOrderByAggregateInput
    _max?: PrivacyPolicyMaxOrderByAggregateInput
    _min?: PrivacyPolicyMinOrderByAggregateInput
    _sum?: PrivacyPolicySumOrderByAggregateInput
  }

  export type PrivacyPolicyScalarWhereWithAggregatesInput = {
    AND?: PrivacyPolicyScalarWhereWithAggregatesInput | PrivacyPolicyScalarWhereWithAggregatesInput[]
    OR?: PrivacyPolicyScalarWhereWithAggregatesInput[]
    NOT?: PrivacyPolicyScalarWhereWithAggregatesInput | PrivacyPolicyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PrivacyPolicy"> | number
    title?: StringWithAggregatesFilter<"PrivacyPolicy"> | string
    subtitle?: StringNullableWithAggregatesFilter<"PrivacyPolicy"> | string | null
    sections?: JsonWithAggregatesFilter<"PrivacyPolicy">
    email?: StringNullableWithAggregatesFilter<"PrivacyPolicy"> | string | null
    phone?: StringNullableWithAggregatesFilter<"PrivacyPolicy"> | string | null
    callingHours?: StringNullableWithAggregatesFilter<"PrivacyPolicy"> | string | null
    mailingAddress?: StringNullableWithAggregatesFilter<"PrivacyPolicy"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PrivacyPolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PrivacyPolicy"> | Date | string
  }

  export type TermsConditionsWhereInput = {
    AND?: TermsConditionsWhereInput | TermsConditionsWhereInput[]
    OR?: TermsConditionsWhereInput[]
    NOT?: TermsConditionsWhereInput | TermsConditionsWhereInput[]
    id?: IntFilter<"TermsConditions"> | number
    title?: StringFilter<"TermsConditions"> | string
    subtitle?: StringNullableFilter<"TermsConditions"> | string | null
    sections?: JsonFilter<"TermsConditions">
    email?: StringNullableFilter<"TermsConditions"> | string | null
    phone?: StringNullableFilter<"TermsConditions"> | string | null
    callingHours?: StringNullableFilter<"TermsConditions"> | string | null
    mailingAddress?: StringNullableFilter<"TermsConditions"> | string | null
    createdAt?: DateTimeFilter<"TermsConditions"> | Date | string
    updatedAt?: DateTimeFilter<"TermsConditions"> | Date | string
  }

  export type TermsConditionsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    sections?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    callingHours?: SortOrderInput | SortOrder
    mailingAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: TermsConditionsOrderByRelevanceInput
  }

  export type TermsConditionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TermsConditionsWhereInput | TermsConditionsWhereInput[]
    OR?: TermsConditionsWhereInput[]
    NOT?: TermsConditionsWhereInput | TermsConditionsWhereInput[]
    title?: StringFilter<"TermsConditions"> | string
    subtitle?: StringNullableFilter<"TermsConditions"> | string | null
    sections?: JsonFilter<"TermsConditions">
    email?: StringNullableFilter<"TermsConditions"> | string | null
    phone?: StringNullableFilter<"TermsConditions"> | string | null
    callingHours?: StringNullableFilter<"TermsConditions"> | string | null
    mailingAddress?: StringNullableFilter<"TermsConditions"> | string | null
    createdAt?: DateTimeFilter<"TermsConditions"> | Date | string
    updatedAt?: DateTimeFilter<"TermsConditions"> | Date | string
  }, "id">

  export type TermsConditionsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    sections?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    callingHours?: SortOrderInput | SortOrder
    mailingAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TermsConditionsCountOrderByAggregateInput
    _avg?: TermsConditionsAvgOrderByAggregateInput
    _max?: TermsConditionsMaxOrderByAggregateInput
    _min?: TermsConditionsMinOrderByAggregateInput
    _sum?: TermsConditionsSumOrderByAggregateInput
  }

  export type TermsConditionsScalarWhereWithAggregatesInput = {
    AND?: TermsConditionsScalarWhereWithAggregatesInput | TermsConditionsScalarWhereWithAggregatesInput[]
    OR?: TermsConditionsScalarWhereWithAggregatesInput[]
    NOT?: TermsConditionsScalarWhereWithAggregatesInput | TermsConditionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TermsConditions"> | number
    title?: StringWithAggregatesFilter<"TermsConditions"> | string
    subtitle?: StringNullableWithAggregatesFilter<"TermsConditions"> | string | null
    sections?: JsonWithAggregatesFilter<"TermsConditions">
    email?: StringNullableWithAggregatesFilter<"TermsConditions"> | string | null
    phone?: StringNullableWithAggregatesFilter<"TermsConditions"> | string | null
    callingHours?: StringNullableWithAggregatesFilter<"TermsConditions"> | string | null
    mailingAddress?: StringNullableWithAggregatesFilter<"TermsConditions"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TermsConditions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TermsConditions"> | Date | string
  }

  export type BannerWhereInput = {
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    id?: IntFilter<"Banner"> | number
    title?: StringFilter<"Banner"> | string
    image?: StringFilter<"Banner"> | string
    active?: BoolFilter<"Banner"> | boolean
    order?: IntFilter<"Banner"> | number
    publicId?: StringFilter<"Banner"> | string
    createdAt?: DateTimeFilter<"Banner"> | Date | string
    updatedAt?: DateTimeFilter<"Banner"> | Date | string
  }

  export type BannerOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    active?: SortOrder
    order?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: BannerOrderByRelevanceInput
  }

  export type BannerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    title?: StringFilter<"Banner"> | string
    image?: StringFilter<"Banner"> | string
    active?: BoolFilter<"Banner"> | boolean
    order?: IntFilter<"Banner"> | number
    publicId?: StringFilter<"Banner"> | string
    createdAt?: DateTimeFilter<"Banner"> | Date | string
    updatedAt?: DateTimeFilter<"Banner"> | Date | string
  }, "id">

  export type BannerOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    active?: SortOrder
    order?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BannerCountOrderByAggregateInput
    _avg?: BannerAvgOrderByAggregateInput
    _max?: BannerMaxOrderByAggregateInput
    _min?: BannerMinOrderByAggregateInput
    _sum?: BannerSumOrderByAggregateInput
  }

  export type BannerScalarWhereWithAggregatesInput = {
    AND?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    OR?: BannerScalarWhereWithAggregatesInput[]
    NOT?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Banner"> | number
    title?: StringWithAggregatesFilter<"Banner"> | string
    image?: StringWithAggregatesFilter<"Banner"> | string
    active?: BoolWithAggregatesFilter<"Banner"> | boolean
    order?: IntWithAggregatesFilter<"Banner"> | number
    publicId?: StringWithAggregatesFilter<"Banner"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: IntFilter<"Message"> | number
    info?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    info?: SortOrder
    createdAt?: SortOrder
    _relevance?: MessageOrderByRelevanceInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    info?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    info?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Message"> | number
    info?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type FoundationWhereInput = {
    AND?: FoundationWhereInput | FoundationWhereInput[]
    OR?: FoundationWhereInput[]
    NOT?: FoundationWhereInput | FoundationWhereInput[]
    id?: IntFilter<"Foundation"> | number
    name?: StringFilter<"Foundation"> | string
    tagline?: StringNullableFilter<"Foundation"> | string | null
    logoUrl?: StringNullableFilter<"Foundation"> | string | null
    description?: StringNullableFilter<"Foundation"> | string | null
    establishedYear?: StringNullableFilter<"Foundation"> | string | null
    isActive?: BoolFilter<"Foundation"> | boolean
    createdAt?: DateTimeFilter<"Foundation"> | Date | string
    updatedAt?: DateTimeFilter<"Foundation"> | Date | string
    createdById?: IntNullableFilter<"Foundation"> | number | null
    updatedById?: IntNullableFilter<"Foundation"> | number | null
    stats?: FoundationStatListRelationFilter
    activities?: FoundationActivityListRelationFilter
    objectives?: FoundationObjectiveListRelationFilter
    contact?: XOR<FoundationContactNullableScalarRelationFilter, FoundationContactWhereInput> | null
    media?: FoundationMediaListRelationFilter
  }

  export type FoundationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tagline?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    establishedYear?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    stats?: FoundationStatOrderByRelationAggregateInput
    activities?: FoundationActivityOrderByRelationAggregateInput
    objectives?: FoundationObjectiveOrderByRelationAggregateInput
    contact?: FoundationContactOrderByWithRelationInput
    media?: FoundationMediaOrderByRelationAggregateInput
    _relevance?: FoundationOrderByRelevanceInput
  }

  export type FoundationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoundationWhereInput | FoundationWhereInput[]
    OR?: FoundationWhereInput[]
    NOT?: FoundationWhereInput | FoundationWhereInput[]
    name?: StringFilter<"Foundation"> | string
    tagline?: StringNullableFilter<"Foundation"> | string | null
    logoUrl?: StringNullableFilter<"Foundation"> | string | null
    description?: StringNullableFilter<"Foundation"> | string | null
    establishedYear?: StringNullableFilter<"Foundation"> | string | null
    isActive?: BoolFilter<"Foundation"> | boolean
    createdAt?: DateTimeFilter<"Foundation"> | Date | string
    updatedAt?: DateTimeFilter<"Foundation"> | Date | string
    createdById?: IntNullableFilter<"Foundation"> | number | null
    updatedById?: IntNullableFilter<"Foundation"> | number | null
    stats?: FoundationStatListRelationFilter
    activities?: FoundationActivityListRelationFilter
    objectives?: FoundationObjectiveListRelationFilter
    contact?: XOR<FoundationContactNullableScalarRelationFilter, FoundationContactWhereInput> | null
    media?: FoundationMediaListRelationFilter
  }, "id">

  export type FoundationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    tagline?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    establishedYear?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: FoundationCountOrderByAggregateInput
    _avg?: FoundationAvgOrderByAggregateInput
    _max?: FoundationMaxOrderByAggregateInput
    _min?: FoundationMinOrderByAggregateInput
    _sum?: FoundationSumOrderByAggregateInput
  }

  export type FoundationScalarWhereWithAggregatesInput = {
    AND?: FoundationScalarWhereWithAggregatesInput | FoundationScalarWhereWithAggregatesInput[]
    OR?: FoundationScalarWhereWithAggregatesInput[]
    NOT?: FoundationScalarWhereWithAggregatesInput | FoundationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Foundation"> | number
    name?: StringWithAggregatesFilter<"Foundation"> | string
    tagline?: StringNullableWithAggregatesFilter<"Foundation"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Foundation"> | string | null
    description?: StringNullableWithAggregatesFilter<"Foundation"> | string | null
    establishedYear?: StringNullableWithAggregatesFilter<"Foundation"> | string | null
    isActive?: BoolWithAggregatesFilter<"Foundation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Foundation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Foundation"> | Date | string
    createdById?: IntNullableWithAggregatesFilter<"Foundation"> | number | null
    updatedById?: IntNullableWithAggregatesFilter<"Foundation"> | number | null
  }

  export type FoundationStatWhereInput = {
    AND?: FoundationStatWhereInput | FoundationStatWhereInput[]
    OR?: FoundationStatWhereInput[]
    NOT?: FoundationStatWhereInput | FoundationStatWhereInput[]
    id?: IntFilter<"FoundationStat"> | number
    foundationId?: IntFilter<"FoundationStat"> | number
    label?: StringFilter<"FoundationStat"> | string
    value?: StringFilter<"FoundationStat"> | string
    displayOrder?: IntFilter<"FoundationStat"> | number
    createdAt?: DateTimeFilter<"FoundationStat"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationStat"> | Date | string
    foundation?: XOR<FoundationScalarRelationFilter, FoundationWhereInput>
  }

  export type FoundationStatOrderByWithRelationInput = {
    id?: SortOrder
    foundationId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    foundation?: FoundationOrderByWithRelationInput
    _relevance?: FoundationStatOrderByRelevanceInput
  }

  export type FoundationStatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoundationStatWhereInput | FoundationStatWhereInput[]
    OR?: FoundationStatWhereInput[]
    NOT?: FoundationStatWhereInput | FoundationStatWhereInput[]
    foundationId?: IntFilter<"FoundationStat"> | number
    label?: StringFilter<"FoundationStat"> | string
    value?: StringFilter<"FoundationStat"> | string
    displayOrder?: IntFilter<"FoundationStat"> | number
    createdAt?: DateTimeFilter<"FoundationStat"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationStat"> | Date | string
    foundation?: XOR<FoundationScalarRelationFilter, FoundationWhereInput>
  }, "id">

  export type FoundationStatOrderByWithAggregationInput = {
    id?: SortOrder
    foundationId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoundationStatCountOrderByAggregateInput
    _avg?: FoundationStatAvgOrderByAggregateInput
    _max?: FoundationStatMaxOrderByAggregateInput
    _min?: FoundationStatMinOrderByAggregateInput
    _sum?: FoundationStatSumOrderByAggregateInput
  }

  export type FoundationStatScalarWhereWithAggregatesInput = {
    AND?: FoundationStatScalarWhereWithAggregatesInput | FoundationStatScalarWhereWithAggregatesInput[]
    OR?: FoundationStatScalarWhereWithAggregatesInput[]
    NOT?: FoundationStatScalarWhereWithAggregatesInput | FoundationStatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoundationStat"> | number
    foundationId?: IntWithAggregatesFilter<"FoundationStat"> | number
    label?: StringWithAggregatesFilter<"FoundationStat"> | string
    value?: StringWithAggregatesFilter<"FoundationStat"> | string
    displayOrder?: IntWithAggregatesFilter<"FoundationStat"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FoundationStat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoundationStat"> | Date | string
  }

  export type FoundationActivityWhereInput = {
    AND?: FoundationActivityWhereInput | FoundationActivityWhereInput[]
    OR?: FoundationActivityWhereInput[]
    NOT?: FoundationActivityWhereInput | FoundationActivityWhereInput[]
    id?: IntFilter<"FoundationActivity"> | number
    foundationId?: IntFilter<"FoundationActivity"> | number
    activityText?: StringFilter<"FoundationActivity"> | string
    displayOrder?: IntFilter<"FoundationActivity"> | number
    createdAt?: DateTimeFilter<"FoundationActivity"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationActivity"> | Date | string
    foundation?: XOR<FoundationScalarRelationFilter, FoundationWhereInput>
  }

  export type FoundationActivityOrderByWithRelationInput = {
    id?: SortOrder
    foundationId?: SortOrder
    activityText?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    foundation?: FoundationOrderByWithRelationInput
    _relevance?: FoundationActivityOrderByRelevanceInput
  }

  export type FoundationActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoundationActivityWhereInput | FoundationActivityWhereInput[]
    OR?: FoundationActivityWhereInput[]
    NOT?: FoundationActivityWhereInput | FoundationActivityWhereInput[]
    foundationId?: IntFilter<"FoundationActivity"> | number
    activityText?: StringFilter<"FoundationActivity"> | string
    displayOrder?: IntFilter<"FoundationActivity"> | number
    createdAt?: DateTimeFilter<"FoundationActivity"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationActivity"> | Date | string
    foundation?: XOR<FoundationScalarRelationFilter, FoundationWhereInput>
  }, "id">

  export type FoundationActivityOrderByWithAggregationInput = {
    id?: SortOrder
    foundationId?: SortOrder
    activityText?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoundationActivityCountOrderByAggregateInput
    _avg?: FoundationActivityAvgOrderByAggregateInput
    _max?: FoundationActivityMaxOrderByAggregateInput
    _min?: FoundationActivityMinOrderByAggregateInput
    _sum?: FoundationActivitySumOrderByAggregateInput
  }

  export type FoundationActivityScalarWhereWithAggregatesInput = {
    AND?: FoundationActivityScalarWhereWithAggregatesInput | FoundationActivityScalarWhereWithAggregatesInput[]
    OR?: FoundationActivityScalarWhereWithAggregatesInput[]
    NOT?: FoundationActivityScalarWhereWithAggregatesInput | FoundationActivityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoundationActivity"> | number
    foundationId?: IntWithAggregatesFilter<"FoundationActivity"> | number
    activityText?: StringWithAggregatesFilter<"FoundationActivity"> | string
    displayOrder?: IntWithAggregatesFilter<"FoundationActivity"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FoundationActivity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoundationActivity"> | Date | string
  }

  export type FoundationObjectiveWhereInput = {
    AND?: FoundationObjectiveWhereInput | FoundationObjectiveWhereInput[]
    OR?: FoundationObjectiveWhereInput[]
    NOT?: FoundationObjectiveWhereInput | FoundationObjectiveWhereInput[]
    id?: IntFilter<"FoundationObjective"> | number
    foundationId?: IntFilter<"FoundationObjective"> | number
    title?: StringFilter<"FoundationObjective"> | string
    description?: StringNullableFilter<"FoundationObjective"> | string | null
    objectiveType?: EnumObjectiveTypeFilter<"FoundationObjective"> | $Enums.ObjectiveType
    displayOrder?: IntFilter<"FoundationObjective"> | number
    createdAt?: DateTimeFilter<"FoundationObjective"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationObjective"> | Date | string
    foundation?: XOR<FoundationScalarRelationFilter, FoundationWhereInput>
  }

  export type FoundationObjectiveOrderByWithRelationInput = {
    id?: SortOrder
    foundationId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    objectiveType?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    foundation?: FoundationOrderByWithRelationInput
    _relevance?: FoundationObjectiveOrderByRelevanceInput
  }

  export type FoundationObjectiveWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoundationObjectiveWhereInput | FoundationObjectiveWhereInput[]
    OR?: FoundationObjectiveWhereInput[]
    NOT?: FoundationObjectiveWhereInput | FoundationObjectiveWhereInput[]
    foundationId?: IntFilter<"FoundationObjective"> | number
    title?: StringFilter<"FoundationObjective"> | string
    description?: StringNullableFilter<"FoundationObjective"> | string | null
    objectiveType?: EnumObjectiveTypeFilter<"FoundationObjective"> | $Enums.ObjectiveType
    displayOrder?: IntFilter<"FoundationObjective"> | number
    createdAt?: DateTimeFilter<"FoundationObjective"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationObjective"> | Date | string
    foundation?: XOR<FoundationScalarRelationFilter, FoundationWhereInput>
  }, "id">

  export type FoundationObjectiveOrderByWithAggregationInput = {
    id?: SortOrder
    foundationId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    objectiveType?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoundationObjectiveCountOrderByAggregateInput
    _avg?: FoundationObjectiveAvgOrderByAggregateInput
    _max?: FoundationObjectiveMaxOrderByAggregateInput
    _min?: FoundationObjectiveMinOrderByAggregateInput
    _sum?: FoundationObjectiveSumOrderByAggregateInput
  }

  export type FoundationObjectiveScalarWhereWithAggregatesInput = {
    AND?: FoundationObjectiveScalarWhereWithAggregatesInput | FoundationObjectiveScalarWhereWithAggregatesInput[]
    OR?: FoundationObjectiveScalarWhereWithAggregatesInput[]
    NOT?: FoundationObjectiveScalarWhereWithAggregatesInput | FoundationObjectiveScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoundationObjective"> | number
    foundationId?: IntWithAggregatesFilter<"FoundationObjective"> | number
    title?: StringWithAggregatesFilter<"FoundationObjective"> | string
    description?: StringNullableWithAggregatesFilter<"FoundationObjective"> | string | null
    objectiveType?: EnumObjectiveTypeWithAggregatesFilter<"FoundationObjective"> | $Enums.ObjectiveType
    displayOrder?: IntWithAggregatesFilter<"FoundationObjective"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FoundationObjective"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoundationObjective"> | Date | string
  }

  export type FoundationContactWhereInput = {
    AND?: FoundationContactWhereInput | FoundationContactWhereInput[]
    OR?: FoundationContactWhereInput[]
    NOT?: FoundationContactWhereInput | FoundationContactWhereInput[]
    id?: IntFilter<"FoundationContact"> | number
    foundationId?: IntFilter<"FoundationContact"> | number
    email?: StringNullableFilter<"FoundationContact"> | string | null
    phone?: StringNullableFilter<"FoundationContact"> | string | null
    address?: StringNullableFilter<"FoundationContact"> | string | null
    website?: StringNullableFilter<"FoundationContact"> | string | null
    socialMediaLinks?: JsonNullableFilter<"FoundationContact">
    createdAt?: DateTimeFilter<"FoundationContact"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationContact"> | Date | string
    foundation?: XOR<FoundationScalarRelationFilter, FoundationWhereInput>
  }

  export type FoundationContactOrderByWithRelationInput = {
    id?: SortOrder
    foundationId?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    socialMediaLinks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    foundation?: FoundationOrderByWithRelationInput
    _relevance?: FoundationContactOrderByRelevanceInput
  }

  export type FoundationContactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    foundationId?: number
    AND?: FoundationContactWhereInput | FoundationContactWhereInput[]
    OR?: FoundationContactWhereInput[]
    NOT?: FoundationContactWhereInput | FoundationContactWhereInput[]
    email?: StringNullableFilter<"FoundationContact"> | string | null
    phone?: StringNullableFilter<"FoundationContact"> | string | null
    address?: StringNullableFilter<"FoundationContact"> | string | null
    website?: StringNullableFilter<"FoundationContact"> | string | null
    socialMediaLinks?: JsonNullableFilter<"FoundationContact">
    createdAt?: DateTimeFilter<"FoundationContact"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationContact"> | Date | string
    foundation?: XOR<FoundationScalarRelationFilter, FoundationWhereInput>
  }, "id" | "foundationId">

  export type FoundationContactOrderByWithAggregationInput = {
    id?: SortOrder
    foundationId?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    socialMediaLinks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoundationContactCountOrderByAggregateInput
    _avg?: FoundationContactAvgOrderByAggregateInput
    _max?: FoundationContactMaxOrderByAggregateInput
    _min?: FoundationContactMinOrderByAggregateInput
    _sum?: FoundationContactSumOrderByAggregateInput
  }

  export type FoundationContactScalarWhereWithAggregatesInput = {
    AND?: FoundationContactScalarWhereWithAggregatesInput | FoundationContactScalarWhereWithAggregatesInput[]
    OR?: FoundationContactScalarWhereWithAggregatesInput[]
    NOT?: FoundationContactScalarWhereWithAggregatesInput | FoundationContactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoundationContact"> | number
    foundationId?: IntWithAggregatesFilter<"FoundationContact"> | number
    email?: StringNullableWithAggregatesFilter<"FoundationContact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"FoundationContact"> | string | null
    address?: StringNullableWithAggregatesFilter<"FoundationContact"> | string | null
    website?: StringNullableWithAggregatesFilter<"FoundationContact"> | string | null
    socialMediaLinks?: JsonNullableWithAggregatesFilter<"FoundationContact">
    createdAt?: DateTimeWithAggregatesFilter<"FoundationContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoundationContact"> | Date | string
  }

  export type FoundationMediaWhereInput = {
    AND?: FoundationMediaWhereInput | FoundationMediaWhereInput[]
    OR?: FoundationMediaWhereInput[]
    NOT?: FoundationMediaWhereInput | FoundationMediaWhereInput[]
    id?: IntFilter<"FoundationMedia"> | number
    foundationId?: IntNullableFilter<"FoundationMedia"> | number | null
    fileName?: StringFilter<"FoundationMedia"> | string
    filePath?: StringFilter<"FoundationMedia"> | string
    fileType?: StringNullableFilter<"FoundationMedia"> | string | null
    fileSize?: IntNullableFilter<"FoundationMedia"> | number | null
    mediaType?: EnumMediaTypeFilter<"FoundationMedia"> | $Enums.MediaType
    altText?: StringNullableFilter<"FoundationMedia"> | string | null
    createdAt?: DateTimeFilter<"FoundationMedia"> | Date | string
    foundation?: XOR<FoundationNullableScalarRelationFilter, FoundationWhereInput> | null
  }

  export type FoundationMediaOrderByWithRelationInput = {
    id?: SortOrder
    foundationId?: SortOrderInput | SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    altText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    foundation?: FoundationOrderByWithRelationInput
    _relevance?: FoundationMediaOrderByRelevanceInput
  }

  export type FoundationMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoundationMediaWhereInput | FoundationMediaWhereInput[]
    OR?: FoundationMediaWhereInput[]
    NOT?: FoundationMediaWhereInput | FoundationMediaWhereInput[]
    foundationId?: IntNullableFilter<"FoundationMedia"> | number | null
    fileName?: StringFilter<"FoundationMedia"> | string
    filePath?: StringFilter<"FoundationMedia"> | string
    fileType?: StringNullableFilter<"FoundationMedia"> | string | null
    fileSize?: IntNullableFilter<"FoundationMedia"> | number | null
    mediaType?: EnumMediaTypeFilter<"FoundationMedia"> | $Enums.MediaType
    altText?: StringNullableFilter<"FoundationMedia"> | string | null
    createdAt?: DateTimeFilter<"FoundationMedia"> | Date | string
    foundation?: XOR<FoundationNullableScalarRelationFilter, FoundationWhereInput> | null
  }, "id">

  export type FoundationMediaOrderByWithAggregationInput = {
    id?: SortOrder
    foundationId?: SortOrderInput | SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    altText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FoundationMediaCountOrderByAggregateInput
    _avg?: FoundationMediaAvgOrderByAggregateInput
    _max?: FoundationMediaMaxOrderByAggregateInput
    _min?: FoundationMediaMinOrderByAggregateInput
    _sum?: FoundationMediaSumOrderByAggregateInput
  }

  export type FoundationMediaScalarWhereWithAggregatesInput = {
    AND?: FoundationMediaScalarWhereWithAggregatesInput | FoundationMediaScalarWhereWithAggregatesInput[]
    OR?: FoundationMediaScalarWhereWithAggregatesInput[]
    NOT?: FoundationMediaScalarWhereWithAggregatesInput | FoundationMediaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoundationMedia"> | number
    foundationId?: IntNullableWithAggregatesFilter<"FoundationMedia"> | number | null
    fileName?: StringWithAggregatesFilter<"FoundationMedia"> | string
    filePath?: StringWithAggregatesFilter<"FoundationMedia"> | string
    fileType?: StringNullableWithAggregatesFilter<"FoundationMedia"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"FoundationMedia"> | number | null
    mediaType?: EnumMediaTypeWithAggregatesFilter<"FoundationMedia"> | $Enums.MediaType
    altText?: StringNullableWithAggregatesFilter<"FoundationMedia"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FoundationMedia"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: IntFilter<"Event"> | number
    title?: StringFilter<"Event"> | string
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeFilter<"Event"> | Date | string
    time?: StringNullableFilter<"Event"> | string | null
    location?: StringFilter<"Event"> | string
    duration?: StringFilter<"Event"> | string
    color?: StringFilter<"Event"> | string
    liveLinks?: JsonNullableFilter<"Event">
    description?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    time?: SortOrderInput | SortOrder
    location?: SortOrder
    duration?: SortOrder
    color?: SortOrder
    liveLinks?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: EventOrderByRelevanceInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeFilter<"Event"> | Date | string
    time?: StringNullableFilter<"Event"> | string | null
    location?: StringFilter<"Event"> | string
    duration?: StringFilter<"Event"> | string
    color?: StringFilter<"Event"> | string
    liveLinks?: JsonNullableFilter<"Event">
    description?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    time?: SortOrderInput | SortOrder
    location?: SortOrder
    duration?: SortOrder
    color?: SortOrder
    liveLinks?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Event"> | number
    title?: StringWithAggregatesFilter<"Event"> | string
    startDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    time?: StringNullableWithAggregatesFilter<"Event"> | string | null
    location?: StringWithAggregatesFilter<"Event"> | string
    duration?: StringWithAggregatesFilter<"Event"> | string
    color?: StringWithAggregatesFilter<"Event"> | string
    liveLinks?: JsonNullableWithAggregatesFilter<"Event">
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type BhajanWhereInput = {
    AND?: BhajanWhereInput | BhajanWhereInput[]
    OR?: BhajanWhereInput[]
    NOT?: BhajanWhereInput | BhajanWhereInput[]
    id?: StringFilter<"Bhajan"> | string
    name?: StringFilter<"Bhajan"> | string
    artist?: StringFilter<"Bhajan"> | string
    album?: StringNullableFilter<"Bhajan"> | string | null
    duration?: StringFilter<"Bhajan"> | string
    imageUrl?: StringNullableFilter<"Bhajan"> | string | null
    audioUrl?: StringFilter<"Bhajan"> | string
    audioPath?: StringFilter<"Bhajan"> | string
    createdAt?: DateTimeFilter<"Bhajan"> | Date | string
    updatedAt?: DateTimeFilter<"Bhajan"> | Date | string
  }

  export type BhajanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    artist?: SortOrder
    album?: SortOrderInput | SortOrder
    duration?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrder
    audioPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: BhajanOrderByRelevanceInput
  }

  export type BhajanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BhajanWhereInput | BhajanWhereInput[]
    OR?: BhajanWhereInput[]
    NOT?: BhajanWhereInput | BhajanWhereInput[]
    name?: StringFilter<"Bhajan"> | string
    artist?: StringFilter<"Bhajan"> | string
    album?: StringNullableFilter<"Bhajan"> | string | null
    duration?: StringFilter<"Bhajan"> | string
    imageUrl?: StringNullableFilter<"Bhajan"> | string | null
    audioUrl?: StringFilter<"Bhajan"> | string
    audioPath?: StringFilter<"Bhajan"> | string
    createdAt?: DateTimeFilter<"Bhajan"> | Date | string
    updatedAt?: DateTimeFilter<"Bhajan"> | Date | string
  }, "id">

  export type BhajanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    artist?: SortOrder
    album?: SortOrderInput | SortOrder
    duration?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrder
    audioPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BhajanCountOrderByAggregateInput
    _max?: BhajanMaxOrderByAggregateInput
    _min?: BhajanMinOrderByAggregateInput
  }

  export type BhajanScalarWhereWithAggregatesInput = {
    AND?: BhajanScalarWhereWithAggregatesInput | BhajanScalarWhereWithAggregatesInput[]
    OR?: BhajanScalarWhereWithAggregatesInput[]
    NOT?: BhajanScalarWhereWithAggregatesInput | BhajanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bhajan"> | string
    name?: StringWithAggregatesFilter<"Bhajan"> | string
    artist?: StringWithAggregatesFilter<"Bhajan"> | string
    album?: StringNullableWithAggregatesFilter<"Bhajan"> | string | null
    duration?: StringWithAggregatesFilter<"Bhajan"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Bhajan"> | string | null
    audioUrl?: StringWithAggregatesFilter<"Bhajan"> | string
    audioPath?: StringWithAggregatesFilter<"Bhajan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Bhajan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bhajan"> | Date | string
  }

  export type UserCreateInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookOrders?: BookOrderCreateNestedManyWithoutUserInput
    bookPurchases?: BookPurchaseCreateNestedManyWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookOrders?: BookOrderUncheckedCreateNestedManyWithoutUserInput
    bookPurchases?: BookPurchaseUncheckedCreateNestedManyWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookOrders?: BookOrderUpdateManyWithoutUserNestedInput
    bookPurchases?: BookPurchaseUpdateManyWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookOrders?: BookOrderUncheckedUpdateManyWithoutUserNestedInput
    bookPurchases?: BookPurchaseUncheckedUpdateManyWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationCreateInput = {
    amount: number
    status?: string
    paymentMethod?: string | null
    transactionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDonationsInput
  }

  export type DonationUncheckedCreateInput = {
    id?: number
    userId: number
    amount: number
    status?: string
    paymentMethod?: string | null
    transactionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDonationsNestedInput
  }

  export type DonationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationCreateManyInput = {
    id?: number
    userId: number
    amount: number
    status?: string
    paymentMethod?: string | null
    transactionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCreateInput = {
    name: string
    author: string
    fileName: string
    filePath: string
    fileSize: string
    price: number
    description?: string | null
    coverImage?: string | null
    uploadDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: BookPurchaseCreateNestedManyWithoutBookInput
    orderItems?: BookOrderItemCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateInput = {
    id?: number
    name: string
    author: string
    fileName: string
    filePath: string
    fileSize: string
    price: number
    description?: string | null
    coverImage?: string | null
    uploadDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: BookPurchaseUncheckedCreateNestedManyWithoutBookInput
    orderItems?: BookOrderItemUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: BookPurchaseUpdateManyWithoutBookNestedInput
    orderItems?: BookOrderItemUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: BookPurchaseUncheckedUpdateManyWithoutBookNestedInput
    orderItems?: BookOrderItemUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookCreateManyInput = {
    id?: number
    name: string
    author: string
    fileName: string
    filePath: string
    fileSize: string
    price: number
    description?: string | null
    coverImage?: string | null
    uploadDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCouponCreateInput = {
    code: string
    discount: number
    type: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: BookOrderCreateNestedManyWithoutCouponInput
  }

  export type BookCouponUncheckedCreateInput = {
    id?: number
    code: string
    discount: number
    type: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: BookOrderUncheckedCreateNestedManyWithoutCouponInput
  }

  export type BookCouponUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: BookOrderUpdateManyWithoutCouponNestedInput
  }

  export type BookCouponUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: BookOrderUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type BookCouponCreateManyInput = {
    id?: number
    code: string
    discount: number
    type: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCouponUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCouponUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookOrderCreateInput = {
    totalAmount: number
    discountAmount?: number
    finalAmount: number
    paymentId?: string | null
    orderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBookOrdersInput
    coupon?: BookCouponCreateNestedOneWithoutOrdersInput
    items?: BookOrderItemCreateNestedManyWithoutOrderInput
    purchases?: BookPurchaseCreateNestedManyWithoutOrderInput
  }

  export type BookOrderUncheckedCreateInput = {
    id?: number
    userId: number
    totalAmount: number
    discountAmount?: number
    finalAmount: number
    couponId?: number | null
    paymentId?: string | null
    orderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: BookOrderItemUncheckedCreateNestedManyWithoutOrderInput
    purchases?: BookPurchaseUncheckedCreateNestedManyWithoutOrderInput
  }

  export type BookOrderUpdateInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalAmount?: FloatFieldUpdateOperationsInput | number
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookOrdersNestedInput
    coupon?: BookCouponUpdateOneWithoutOrdersNestedInput
    items?: BookOrderItemUpdateManyWithoutOrderNestedInput
    purchases?: BookPurchaseUpdateManyWithoutOrderNestedInput
  }

  export type BookOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalAmount?: FloatFieldUpdateOperationsInput | number
    couponId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: BookOrderItemUncheckedUpdateManyWithoutOrderNestedInput
    purchases?: BookPurchaseUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type BookOrderCreateManyInput = {
    id?: number
    userId: number
    totalAmount: number
    discountAmount?: number
    finalAmount: number
    couponId?: number | null
    paymentId?: string | null
    orderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookOrderUpdateManyMutationInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalAmount?: FloatFieldUpdateOperationsInput | number
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalAmount?: FloatFieldUpdateOperationsInput | number
    couponId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookOrderItemCreateInput = {
    price: number
    order: BookOrderCreateNestedOneWithoutItemsInput
    book: BookCreateNestedOneWithoutOrderItemsInput
  }

  export type BookOrderItemUncheckedCreateInput = {
    id?: number
    orderId: number
    bookId: number
    price: number
  }

  export type BookOrderItemUpdateInput = {
    price?: FloatFieldUpdateOperationsInput | number
    order?: BookOrderUpdateOneRequiredWithoutItemsNestedInput
    book?: BookUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type BookOrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type BookOrderItemCreateManyInput = {
    id?: number
    orderId: number
    bookId: number
    price: number
  }

  export type BookOrderItemUpdateManyMutationInput = {
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type BookOrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type BookPurchaseCreateInput = {
    purchaseDate?: Date | string
    accessGranted?: boolean
    user: UserCreateNestedOneWithoutBookPurchasesInput
    book: BookCreateNestedOneWithoutPurchasesInput
    order: BookOrderCreateNestedOneWithoutPurchasesInput
  }

  export type BookPurchaseUncheckedCreateInput = {
    id?: number
    userId: number
    bookId: number
    orderId: number
    purchaseDate?: Date | string
    accessGranted?: boolean
  }

  export type BookPurchaseUpdateInput = {
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutBookPurchasesNestedInput
    book?: BookUpdateOneRequiredWithoutPurchasesNestedInput
    order?: BookOrderUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type BookPurchaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookPurchaseCreateManyInput = {
    id?: number
    userId: number
    bookId: number
    orderId: number
    purchaseDate?: Date | string
    accessGranted?: boolean
  }

  export type BookPurchaseUpdateManyMutationInput = {
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookPurchaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentCreateInput = {
    referenceId: string
    provider: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    userId: number
    referenceId: string
    provider: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    referenceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    referenceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    userId: number
    referenceId: string
    provider: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    referenceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    referenceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsCreateInput = {
    title: string
    titleEn: string
    slug: string
    excerpt: string
    image: string
    category: string
    date: string
    readTime: string
    views?: number
    featured?: boolean
    content: JsonNullValueInput | InputJsonValue
    tags: JsonNullValueInput | InputJsonValue
    author: string
    authorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsUncheckedCreateInput = {
    id?: number
    title: string
    titleEn: string
    slug: string
    excerpt: string
    image: string
    category: string
    date: string
    readTime: string
    views?: number
    featured?: boolean
    content: JsonNullValueInput | InputJsonValue
    tags: JsonNullValueInput | InputJsonValue
    author: string
    authorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    readTime?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    content?: JsonNullValueInput | InputJsonValue
    tags?: JsonNullValueInput | InputJsonValue
    author?: StringFieldUpdateOperationsInput | string
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    readTime?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    content?: JsonNullValueInput | InputJsonValue
    tags?: JsonNullValueInput | InputJsonValue
    author?: StringFieldUpdateOperationsInput | string
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsCreateManyInput = {
    id?: number
    title: string
    titleEn: string
    slug: string
    excerpt: string
    image: string
    category: string
    date: string
    readTime: string
    views?: number
    featured?: boolean
    content: JsonNullValueInput | InputJsonValue
    tags: JsonNullValueInput | InputJsonValue
    author: string
    authorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    readTime?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    content?: JsonNullValueInput | InputJsonValue
    tags?: JsonNullValueInput | InputJsonValue
    author?: StringFieldUpdateOperationsInput | string
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    readTime?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
    content?: JsonNullValueInput | InputJsonValue
    tags?: JsonNullValueInput | InputJsonValue
    author?: StringFieldUpdateOperationsInput | string
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GopalPariwarCreateInput = {
    heroImage: string
    heroTitle: string
    heroSubtitle: string
    personalInfo: JsonNullValueInput | InputJsonValue
    spiritualEducation?: string | null
    lifeJourney: JsonNullValueInput | InputJsonValue
    responsibilities: JsonNullValueInput | InputJsonValue
    pledges: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GopalPariwarUncheckedCreateInput = {
    id?: number
    heroImage: string
    heroTitle: string
    heroSubtitle: string
    personalInfo: JsonNullValueInput | InputJsonValue
    spiritualEducation?: string | null
    lifeJourney: JsonNullValueInput | InputJsonValue
    responsibilities: JsonNullValueInput | InputJsonValue
    pledges: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GopalPariwarUpdateInput = {
    heroImage?: StringFieldUpdateOperationsInput | string
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    personalInfo?: JsonNullValueInput | InputJsonValue
    spiritualEducation?: NullableStringFieldUpdateOperationsInput | string | null
    lifeJourney?: JsonNullValueInput | InputJsonValue
    responsibilities?: JsonNullValueInput | InputJsonValue
    pledges?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GopalPariwarUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    heroImage?: StringFieldUpdateOperationsInput | string
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    personalInfo?: JsonNullValueInput | InputJsonValue
    spiritualEducation?: NullableStringFieldUpdateOperationsInput | string | null
    lifeJourney?: JsonNullValueInput | InputJsonValue
    responsibilities?: JsonNullValueInput | InputJsonValue
    pledges?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GopalPariwarCreateManyInput = {
    id?: number
    heroImage: string
    heroTitle: string
    heroSubtitle: string
    personalInfo: JsonNullValueInput | InputJsonValue
    spiritualEducation?: string | null
    lifeJourney: JsonNullValueInput | InputJsonValue
    responsibilities: JsonNullValueInput | InputJsonValue
    pledges: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GopalPariwarUpdateManyMutationInput = {
    heroImage?: StringFieldUpdateOperationsInput | string
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    personalInfo?: JsonNullValueInput | InputJsonValue
    spiritualEducation?: NullableStringFieldUpdateOperationsInput | string | null
    lifeJourney?: JsonNullValueInput | InputJsonValue
    responsibilities?: JsonNullValueInput | InputJsonValue
    pledges?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GopalPariwarUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    heroImage?: StringFieldUpdateOperationsInput | string
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    personalInfo?: JsonNullValueInput | InputJsonValue
    spiritualEducation?: NullableStringFieldUpdateOperationsInput | string | null
    lifeJourney?: JsonNullValueInput | InputJsonValue
    responsibilities?: JsonNullValueInput | InputJsonValue
    pledges?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaushalaCreateInput = {
    name: string
    photo?: string | null
    address: string
    establishmentYear: number
    contactDetails: string
    totalCows: number
    capacity: number
    description?: string | null
    city: string
    state: string
    pincode: string
    contactPerson: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaushalaUncheckedCreateInput = {
    id?: number
    name: string
    photo?: string | null
    address: string
    establishmentYear: number
    contactDetails: string
    totalCows: number
    capacity: number
    description?: string | null
    city: string
    state: string
    pincode: string
    contactPerson: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaushalaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    establishmentYear?: IntFieldUpdateOperationsInput | number
    contactDetails?: StringFieldUpdateOperationsInput | string
    totalCows?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaushalaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    establishmentYear?: IntFieldUpdateOperationsInput | number
    contactDetails?: StringFieldUpdateOperationsInput | string
    totalCows?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaushalaCreateManyInput = {
    id?: number
    name: string
    photo?: string | null
    address: string
    establishmentYear: number
    contactDetails: string
    totalCows: number
    capacity: number
    description?: string | null
    city: string
    state: string
    pincode: string
    contactPerson: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaushalaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    establishmentYear?: IntFieldUpdateOperationsInput | number
    contactDetails?: StringFieldUpdateOperationsInput | string
    totalCows?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaushalaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    establishmentYear?: IntFieldUpdateOperationsInput | number
    contactDetails?: StringFieldUpdateOperationsInput | string
    totalCows?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardCreateInput = {
    title: string
    titleEn?: string | null
    link: string
    image?: string | null
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CardUncheckedCreateInput = {
    id?: number
    title: string
    titleEn?: string | null
    link: string
    image?: string | null
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CardUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardCreateManyInput = {
    id?: number
    title: string
    titleEn?: string | null
    link: string
    image?: string | null
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CardUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DtaSanssthanCreateInput = {
    name: string
    person?: string | null
    image?: string | null
    description?: string | null
    email?: string | null
    phone?: string | null
    altPhone?: string | null
    website?: string | null
    timing?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DtaSanssthanUncheckedCreateInput = {
    id?: number
    name: string
    person?: string | null
    image?: string | null
    description?: string | null
    email?: string | null
    phone?: string | null
    altPhone?: string | null
    website?: string | null
    timing?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DtaSanssthanUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    person?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DtaSanssthanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    person?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DtaSanssthanCreateManyInput = {
    id?: number
    name: string
    person?: string | null
    image?: string | null
    description?: string | null
    email?: string | null
    phone?: string | null
    altPhone?: string | null
    website?: string | null
    timing?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DtaSanssthanUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    person?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DtaSanssthanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    person?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyPolicyCreateInput = {
    title: string
    subtitle?: string | null
    sections: JsonNullValueInput | InputJsonValue
    email?: string | null
    phone?: string | null
    callingHours?: string | null
    mailingAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivacyPolicyUncheckedCreateInput = {
    id?: number
    title: string
    subtitle?: string | null
    sections: JsonNullValueInput | InputJsonValue
    email?: string | null
    phone?: string | null
    callingHours?: string | null
    mailingAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivacyPolicyUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    callingHours?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyPolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    callingHours?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyPolicyCreateManyInput = {
    id?: number
    title: string
    subtitle?: string | null
    sections: JsonNullValueInput | InputJsonValue
    email?: string | null
    phone?: string | null
    callingHours?: string | null
    mailingAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivacyPolicyUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    callingHours?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyPolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    callingHours?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermsConditionsCreateInput = {
    title: string
    subtitle?: string | null
    sections: JsonNullValueInput | InputJsonValue
    email?: string | null
    phone?: string | null
    callingHours?: string | null
    mailingAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermsConditionsUncheckedCreateInput = {
    id?: number
    title: string
    subtitle?: string | null
    sections: JsonNullValueInput | InputJsonValue
    email?: string | null
    phone?: string | null
    callingHours?: string | null
    mailingAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermsConditionsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    callingHours?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermsConditionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    callingHours?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermsConditionsCreateManyInput = {
    id?: number
    title: string
    subtitle?: string | null
    sections: JsonNullValueInput | InputJsonValue
    email?: string | null
    phone?: string | null
    callingHours?: string | null
    mailingAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermsConditionsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    callingHours?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermsConditionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    callingHours?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerCreateInput = {
    title: string
    image: string
    active?: boolean
    order: number
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUncheckedCreateInput = {
    id?: number
    title: string
    image: string
    active?: boolean
    order: number
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerCreateManyInput = {
    id?: number
    title: string
    image: string
    active?: boolean
    order: number
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    info: string
    createdAt?: Date | string
  }

  export type MessageUncheckedCreateInput = {
    id?: number
    info: string
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    info?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    info?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: number
    info: string
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    info?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    info?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationCreateInput = {
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatCreateNestedManyWithoutFoundationInput
    activities?: FoundationActivityCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactCreateNestedOneWithoutFoundationInput
    media?: FoundationMediaCreateNestedManyWithoutFoundationInput
  }

  export type FoundationUncheckedCreateInput = {
    id?: number
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatUncheckedCreateNestedManyWithoutFoundationInput
    activities?: FoundationActivityUncheckedCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveUncheckedCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactUncheckedCreateNestedOneWithoutFoundationInput
    media?: FoundationMediaUncheckedCreateNestedManyWithoutFoundationInput
  }

  export type FoundationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUpdateManyWithoutFoundationNestedInput
    activities?: FoundationActivityUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUpdateOneWithoutFoundationNestedInput
    media?: FoundationMediaUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUncheckedUpdateManyWithoutFoundationNestedInput
    activities?: FoundationActivityUncheckedUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUncheckedUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUncheckedUpdateOneWithoutFoundationNestedInput
    media?: FoundationMediaUncheckedUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationCreateManyInput = {
    id?: number
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
  }

  export type FoundationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FoundationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FoundationStatCreateInput = {
    label: string
    value: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    foundation: FoundationCreateNestedOneWithoutStatsInput
  }

  export type FoundationStatUncheckedCreateInput = {
    id?: number
    foundationId: number
    label: string
    value: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationStatUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foundation?: FoundationUpdateOneRequiredWithoutStatsNestedInput
  }

  export type FoundationStatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationStatCreateManyInput = {
    id?: number
    foundationId: number
    label: string
    value: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationStatUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationStatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationActivityCreateInput = {
    activityText: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    foundation: FoundationCreateNestedOneWithoutActivitiesInput
  }

  export type FoundationActivityUncheckedCreateInput = {
    id?: number
    foundationId: number
    activityText: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationActivityUpdateInput = {
    activityText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foundation?: FoundationUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type FoundationActivityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: IntFieldUpdateOperationsInput | number
    activityText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationActivityCreateManyInput = {
    id?: number
    foundationId: number
    activityText: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationActivityUpdateManyMutationInput = {
    activityText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationActivityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: IntFieldUpdateOperationsInput | number
    activityText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationObjectiveCreateInput = {
    title: string
    description?: string | null
    objectiveType?: $Enums.ObjectiveType
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    foundation: FoundationCreateNestedOneWithoutObjectivesInput
  }

  export type FoundationObjectiveUncheckedCreateInput = {
    id?: number
    foundationId: number
    title: string
    description?: string | null
    objectiveType?: $Enums.ObjectiveType
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationObjectiveUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveType?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foundation?: FoundationUpdateOneRequiredWithoutObjectivesNestedInput
  }

  export type FoundationObjectiveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveType?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationObjectiveCreateManyInput = {
    id?: number
    foundationId: number
    title: string
    description?: string | null
    objectiveType?: $Enums.ObjectiveType
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationObjectiveUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveType?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationObjectiveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveType?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationContactCreateInput = {
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    foundation: FoundationCreateNestedOneWithoutContactInput
  }

  export type FoundationContactUncheckedCreateInput = {
    id?: number
    foundationId: number
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationContactUpdateInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foundation?: FoundationUpdateOneRequiredWithoutContactNestedInput
  }

  export type FoundationContactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationContactCreateManyInput = {
    id?: number
    foundationId: number
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationContactUpdateManyMutationInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationContactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationMediaCreateInput = {
    fileName: string
    filePath: string
    fileType?: string | null
    fileSize?: number | null
    mediaType?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    foundation?: FoundationCreateNestedOneWithoutMediaInput
  }

  export type FoundationMediaUncheckedCreateInput = {
    id?: number
    foundationId?: number | null
    fileName: string
    filePath: string
    fileType?: string | null
    fileSize?: number | null
    mediaType?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
  }

  export type FoundationMediaUpdateInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foundation?: FoundationUpdateOneWithoutMediaNestedInput
  }

  export type FoundationMediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: NullableIntFieldUpdateOperationsInput | number | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationMediaCreateManyInput = {
    id?: number
    foundationId?: number | null
    fileName: string
    filePath: string
    fileType?: string | null
    fileSize?: number | null
    mediaType?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
  }

  export type FoundationMediaUpdateManyMutationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationMediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: NullableIntFieldUpdateOperationsInput | number | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    title: string
    startDate: Date | string
    endDate: Date | string
    time?: string | null
    location: string
    duration: string
    color?: string
    liveLinks?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUncheckedCreateInput = {
    id?: number
    title: string
    startDate: Date | string
    endDate: Date | string
    time?: string | null
    location: string
    duration: string
    color?: string
    liveLinks?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    liveLinks?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    liveLinks?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyInput = {
    id?: number
    title: string
    startDate: Date | string
    endDate: Date | string
    time?: string | null
    location: string
    duration: string
    color?: string
    liveLinks?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    liveLinks?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    liveLinks?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BhajanCreateInput = {
    id?: string
    name: string
    artist: string
    album?: string | null
    duration?: string
    imageUrl?: string | null
    audioUrl: string
    audioPath: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BhajanUncheckedCreateInput = {
    id?: string
    name: string
    artist: string
    album?: string | null
    duration?: string
    imageUrl?: string | null
    audioUrl: string
    audioPath: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BhajanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: StringFieldUpdateOperationsInput | string
    audioPath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BhajanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: StringFieldUpdateOperationsInput | string
    audioPath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BhajanCreateManyInput = {
    id?: string
    name: string
    artist: string
    album?: string | null
    duration?: string
    imageUrl?: string | null
    audioUrl: string
    audioPath: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BhajanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: StringFieldUpdateOperationsInput | string
    audioPath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BhajanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    album?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: StringFieldUpdateOperationsInput | string
    audioPath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BookOrderListRelationFilter = {
    every?: BookOrderWhereInput
    some?: BookOrderWhereInput
    none?: BookOrderWhereInput
  }

  export type BookPurchaseListRelationFilter = {
    every?: BookPurchaseWhereInput
    some?: BookPurchaseWhereInput
    none?: BookPurchaseWhereInput
  }

  export type DonationListRelationFilter = {
    every?: DonationWhereInput
    some?: DonationWhereInput
    none?: DonationWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BookOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookPurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DonationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    image?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    otpCode?: SortOrder
    otpExpires?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    image?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    otpCode?: SortOrder
    otpExpires?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    image?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    otpCode?: SortOrder
    otpExpires?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DonationOrderByRelevanceInput = {
    fields: DonationOrderByRelevanceFieldEnum | DonationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DonationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DonationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }

  export type DonationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DonationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DonationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BookOrderItemListRelationFilter = {
    every?: BookOrderItemWhereInput
    some?: BookOrderItemWhereInput
    none?: BookOrderItemWhereInput
  }

  export type BookOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookOrderByRelevanceInput = {
    fields: BookOrderByRelevanceFieldEnum | BookOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BookCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    author?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    price?: SortOrder
    description?: SortOrder
    coverImage?: SortOrder
    uploadDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type BookMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    author?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    price?: SortOrder
    description?: SortOrder
    coverImage?: SortOrder
    uploadDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    author?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    price?: SortOrder
    description?: SortOrder
    coverImage?: SortOrder
    uploadDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type BookCouponOrderByRelevanceInput = {
    fields: BookCouponOrderByRelevanceFieldEnum | BookCouponOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BookCouponCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookCouponAvgOrderByAggregateInput = {
    id?: SortOrder
    discount?: SortOrder
  }

  export type BookCouponMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookCouponMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookCouponSumOrderByAggregateInput = {
    id?: SortOrder
    discount?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BookCouponNullableScalarRelationFilter = {
    is?: BookCouponWhereInput | null
    isNot?: BookCouponWhereInput | null
  }

  export type BookOrderOrderByRelevanceInput = {
    fields: BookOrderOrderByRelevanceFieldEnum | BookOrderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BookOrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    couponId?: SortOrder
    paymentId?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    couponId?: SortOrder
  }

  export type BookOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    couponId?: SortOrder
    paymentId?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookOrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    couponId?: SortOrder
    paymentId?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookOrderSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    couponId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BookOrderScalarRelationFilter = {
    is?: BookOrderWhereInput
    isNot?: BookOrderWhereInput
  }

  export type BookScalarRelationFilter = {
    is?: BookWhereInput
    isNot?: BookWhereInput
  }

  export type BookOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    bookId?: SortOrder
    price?: SortOrder
  }

  export type BookOrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    bookId?: SortOrder
    price?: SortOrder
  }

  export type BookOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    bookId?: SortOrder
    price?: SortOrder
  }

  export type BookOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    bookId?: SortOrder
    price?: SortOrder
  }

  export type BookOrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    bookId?: SortOrder
    price?: SortOrder
  }

  export type BookPurchaseUserIdBookIdCompoundUniqueInput = {
    userId: number
    bookId: number
  }

  export type BookPurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    orderId?: SortOrder
    purchaseDate?: SortOrder
    accessGranted?: SortOrder
  }

  export type BookPurchaseAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    orderId?: SortOrder
  }

  export type BookPurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    orderId?: SortOrder
    purchaseDate?: SortOrder
    accessGranted?: SortOrder
  }

  export type BookPurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    orderId?: SortOrder
    purchaseDate?: SortOrder
    accessGranted?: SortOrder
  }

  export type BookPurchaseSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookId?: SortOrder
    orderId?: SortOrder
  }

  export type PaymentOrderByRelevanceInput = {
    fields: PaymentOrderByRelevanceFieldEnum | PaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    referenceId?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    referenceId?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    referenceId?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NewsOrderByRelevanceInput = {
    fields: NewsOrderByRelevanceFieldEnum | NewsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NewsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    image?: SortOrder
    category?: SortOrder
    date?: SortOrder
    readTime?: SortOrder
    views?: SortOrder
    featured?: SortOrder
    content?: SortOrder
    tags?: SortOrder
    author?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsAvgOrderByAggregateInput = {
    id?: SortOrder
    views?: SortOrder
    authorId?: SortOrder
  }

  export type NewsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    image?: SortOrder
    category?: SortOrder
    date?: SortOrder
    readTime?: SortOrder
    views?: SortOrder
    featured?: SortOrder
    author?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    image?: SortOrder
    category?: SortOrder
    date?: SortOrder
    readTime?: SortOrder
    views?: SortOrder
    featured?: SortOrder
    author?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsSumOrderByAggregateInput = {
    id?: SortOrder
    views?: SortOrder
    authorId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type GopalPariwarOrderByRelevanceInput = {
    fields: GopalPariwarOrderByRelevanceFieldEnum | GopalPariwarOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GopalPariwarCountOrderByAggregateInput = {
    id?: SortOrder
    heroImage?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    personalInfo?: SortOrder
    spiritualEducation?: SortOrder
    lifeJourney?: SortOrder
    responsibilities?: SortOrder
    pledges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GopalPariwarAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GopalPariwarMaxOrderByAggregateInput = {
    id?: SortOrder
    heroImage?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    spiritualEducation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GopalPariwarMinOrderByAggregateInput = {
    id?: SortOrder
    heroImage?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    spiritualEducation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GopalPariwarSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GaushalaOrderByRelevanceInput = {
    fields: GaushalaOrderByRelevanceFieldEnum | GaushalaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GaushalaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    photo?: SortOrder
    address?: SortOrder
    establishmentYear?: SortOrder
    contactDetails?: SortOrder
    totalCows?: SortOrder
    capacity?: SortOrder
    description?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    contactPerson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaushalaAvgOrderByAggregateInput = {
    id?: SortOrder
    establishmentYear?: SortOrder
    totalCows?: SortOrder
    capacity?: SortOrder
  }

  export type GaushalaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    photo?: SortOrder
    address?: SortOrder
    establishmentYear?: SortOrder
    contactDetails?: SortOrder
    totalCows?: SortOrder
    capacity?: SortOrder
    description?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    contactPerson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaushalaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    photo?: SortOrder
    address?: SortOrder
    establishmentYear?: SortOrder
    contactDetails?: SortOrder
    totalCows?: SortOrder
    capacity?: SortOrder
    description?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    contactPerson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaushalaSumOrderByAggregateInput = {
    id?: SortOrder
    establishmentYear?: SortOrder
    totalCows?: SortOrder
    capacity?: SortOrder
  }

  export type CardOrderByRelevanceInput = {
    fields: CardOrderByRelevanceFieldEnum | CardOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CardCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    link?: SortOrder
    image?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type CardMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    link?: SortOrder
    image?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    link?: SortOrder
    image?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type DtaSanssthanOrderByRelevanceInput = {
    fields: DtaSanssthanOrderByRelevanceFieldEnum | DtaSanssthanOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DtaSanssthanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    person?: SortOrder
    image?: SortOrder
    description?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    altPhone?: SortOrder
    website?: SortOrder
    timing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DtaSanssthanAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DtaSanssthanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    person?: SortOrder
    image?: SortOrder
    description?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    altPhone?: SortOrder
    website?: SortOrder
    timing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DtaSanssthanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    person?: SortOrder
    image?: SortOrder
    description?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    altPhone?: SortOrder
    website?: SortOrder
    timing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DtaSanssthanSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PrivacyPolicyOrderByRelevanceInput = {
    fields: PrivacyPolicyOrderByRelevanceFieldEnum | PrivacyPolicyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PrivacyPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    sections?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    callingHours?: SortOrder
    mailingAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivacyPolicyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PrivacyPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    callingHours?: SortOrder
    mailingAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivacyPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    callingHours?: SortOrder
    mailingAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivacyPolicySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TermsConditionsOrderByRelevanceInput = {
    fields: TermsConditionsOrderByRelevanceFieldEnum | TermsConditionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TermsConditionsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    sections?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    callingHours?: SortOrder
    mailingAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TermsConditionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TermsConditionsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    callingHours?: SortOrder
    mailingAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TermsConditionsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    callingHours?: SortOrder
    mailingAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TermsConditionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BannerOrderByRelevanceInput = {
    fields: BannerOrderByRelevanceFieldEnum | BannerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BannerCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    active?: SortOrder
    order?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type BannerMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    active?: SortOrder
    order?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    active?: SortOrder
    order?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type MessageOrderByRelevanceInput = {
    fields: MessageOrderByRelevanceFieldEnum | MessageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    info?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    info?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    info?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FoundationStatListRelationFilter = {
    every?: FoundationStatWhereInput
    some?: FoundationStatWhereInput
    none?: FoundationStatWhereInput
  }

  export type FoundationActivityListRelationFilter = {
    every?: FoundationActivityWhereInput
    some?: FoundationActivityWhereInput
    none?: FoundationActivityWhereInput
  }

  export type FoundationObjectiveListRelationFilter = {
    every?: FoundationObjectiveWhereInput
    some?: FoundationObjectiveWhereInput
    none?: FoundationObjectiveWhereInput
  }

  export type FoundationContactNullableScalarRelationFilter = {
    is?: FoundationContactWhereInput | null
    isNot?: FoundationContactWhereInput | null
  }

  export type FoundationMediaListRelationFilter = {
    every?: FoundationMediaWhereInput
    some?: FoundationMediaWhereInput
    none?: FoundationMediaWhereInput
  }

  export type FoundationStatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoundationActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoundationObjectiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoundationMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoundationOrderByRelevanceInput = {
    fields: FoundationOrderByRelevanceFieldEnum | FoundationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FoundationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tagline?: SortOrder
    logoUrl?: SortOrder
    description?: SortOrder
    establishedYear?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type FoundationAvgOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type FoundationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tagline?: SortOrder
    logoUrl?: SortOrder
    description?: SortOrder
    establishedYear?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type FoundationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tagline?: SortOrder
    logoUrl?: SortOrder
    description?: SortOrder
    establishedYear?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type FoundationSumOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type FoundationScalarRelationFilter = {
    is?: FoundationWhereInput
    isNot?: FoundationWhereInput
  }

  export type FoundationStatOrderByRelevanceInput = {
    fields: FoundationStatOrderByRelevanceFieldEnum | FoundationStatOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FoundationStatCountOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationStatAvgOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    displayOrder?: SortOrder
  }

  export type FoundationStatMaxOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationStatMinOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationStatSumOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    displayOrder?: SortOrder
  }

  export type FoundationActivityOrderByRelevanceInput = {
    fields: FoundationActivityOrderByRelevanceFieldEnum | FoundationActivityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FoundationActivityCountOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    activityText?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationActivityAvgOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    displayOrder?: SortOrder
  }

  export type FoundationActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    activityText?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationActivityMinOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    activityText?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationActivitySumOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    displayOrder?: SortOrder
  }

  export type EnumObjectiveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectiveType | EnumObjectiveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectiveType[]
    notIn?: $Enums.ObjectiveType[]
    not?: NestedEnumObjectiveTypeFilter<$PrismaModel> | $Enums.ObjectiveType
  }

  export type FoundationObjectiveOrderByRelevanceInput = {
    fields: FoundationObjectiveOrderByRelevanceFieldEnum | FoundationObjectiveOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FoundationObjectiveCountOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    objectiveType?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationObjectiveAvgOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    displayOrder?: SortOrder
  }

  export type FoundationObjectiveMaxOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    objectiveType?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationObjectiveMinOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    objectiveType?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationObjectiveSumOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    displayOrder?: SortOrder
  }

  export type EnumObjectiveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectiveType | EnumObjectiveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectiveType[]
    notIn?: $Enums.ObjectiveType[]
    not?: NestedEnumObjectiveTypeWithAggregatesFilter<$PrismaModel> | $Enums.ObjectiveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumObjectiveTypeFilter<$PrismaModel>
    _max?: NestedEnumObjectiveTypeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FoundationContactOrderByRelevanceInput = {
    fields: FoundationContactOrderByRelevanceFieldEnum | FoundationContactOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FoundationContactCountOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    website?: SortOrder
    socialMediaLinks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationContactAvgOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
  }

  export type FoundationContactMaxOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationContactMinOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationContactSumOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[]
    notIn?: $Enums.MediaType[]
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type FoundationNullableScalarRelationFilter = {
    is?: FoundationWhereInput | null
    isNot?: FoundationWhereInput | null
  }

  export type FoundationMediaOrderByRelevanceInput = {
    fields: FoundationMediaOrderByRelevanceFieldEnum | FoundationMediaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FoundationMediaCountOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    mediaType?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
  }

  export type FoundationMediaAvgOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    fileSize?: SortOrder
  }

  export type FoundationMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    mediaType?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
  }

  export type FoundationMediaMinOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    mediaType?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
  }

  export type FoundationMediaSumOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    fileSize?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[]
    notIn?: $Enums.MediaType[]
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type EventOrderByRelevanceInput = {
    fields: EventOrderByRelevanceFieldEnum | EventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    time?: SortOrder
    location?: SortOrder
    duration?: SortOrder
    color?: SortOrder
    liveLinks?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    time?: SortOrder
    location?: SortOrder
    duration?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    time?: SortOrder
    location?: SortOrder
    duration?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BhajanOrderByRelevanceInput = {
    fields: BhajanOrderByRelevanceFieldEnum | BhajanOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BhajanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    artist?: SortOrder
    album?: SortOrder
    duration?: SortOrder
    imageUrl?: SortOrder
    audioUrl?: SortOrder
    audioPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BhajanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    artist?: SortOrder
    album?: SortOrder
    duration?: SortOrder
    imageUrl?: SortOrder
    audioUrl?: SortOrder
    audioPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BhajanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    artist?: SortOrder
    album?: SortOrder
    duration?: SortOrder
    imageUrl?: SortOrder
    audioUrl?: SortOrder
    audioPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookOrderCreateNestedManyWithoutUserInput = {
    create?: XOR<BookOrderCreateWithoutUserInput, BookOrderUncheckedCreateWithoutUserInput> | BookOrderCreateWithoutUserInput[] | BookOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookOrderCreateOrConnectWithoutUserInput | BookOrderCreateOrConnectWithoutUserInput[]
    createMany?: BookOrderCreateManyUserInputEnvelope
    connect?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
  }

  export type BookPurchaseCreateNestedManyWithoutUserInput = {
    create?: XOR<BookPurchaseCreateWithoutUserInput, BookPurchaseUncheckedCreateWithoutUserInput> | BookPurchaseCreateWithoutUserInput[] | BookPurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookPurchaseCreateOrConnectWithoutUserInput | BookPurchaseCreateOrConnectWithoutUserInput[]
    createMany?: BookPurchaseCreateManyUserInputEnvelope
    connect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
  }

  export type DonationCreateNestedManyWithoutUserInput = {
    create?: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput> | DonationCreateWithoutUserInput[] | DonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutUserInput | DonationCreateOrConnectWithoutUserInput[]
    createMany?: DonationCreateManyUserInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type BookOrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookOrderCreateWithoutUserInput, BookOrderUncheckedCreateWithoutUserInput> | BookOrderCreateWithoutUserInput[] | BookOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookOrderCreateOrConnectWithoutUserInput | BookOrderCreateOrConnectWithoutUserInput[]
    createMany?: BookOrderCreateManyUserInputEnvelope
    connect?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
  }

  export type BookPurchaseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookPurchaseCreateWithoutUserInput, BookPurchaseUncheckedCreateWithoutUserInput> | BookPurchaseCreateWithoutUserInput[] | BookPurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookPurchaseCreateOrConnectWithoutUserInput | BookPurchaseCreateOrConnectWithoutUserInput[]
    createMany?: BookPurchaseCreateManyUserInputEnvelope
    connect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
  }

  export type DonationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput> | DonationCreateWithoutUserInput[] | DonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutUserInput | DonationCreateOrConnectWithoutUserInput[]
    createMany?: DonationCreateManyUserInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BookOrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookOrderCreateWithoutUserInput, BookOrderUncheckedCreateWithoutUserInput> | BookOrderCreateWithoutUserInput[] | BookOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookOrderCreateOrConnectWithoutUserInput | BookOrderCreateOrConnectWithoutUserInput[]
    upsert?: BookOrderUpsertWithWhereUniqueWithoutUserInput | BookOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookOrderCreateManyUserInputEnvelope
    set?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
    disconnect?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
    delete?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
    connect?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
    update?: BookOrderUpdateWithWhereUniqueWithoutUserInput | BookOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookOrderUpdateManyWithWhereWithoutUserInput | BookOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookOrderScalarWhereInput | BookOrderScalarWhereInput[]
  }

  export type BookPurchaseUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookPurchaseCreateWithoutUserInput, BookPurchaseUncheckedCreateWithoutUserInput> | BookPurchaseCreateWithoutUserInput[] | BookPurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookPurchaseCreateOrConnectWithoutUserInput | BookPurchaseCreateOrConnectWithoutUserInput[]
    upsert?: BookPurchaseUpsertWithWhereUniqueWithoutUserInput | BookPurchaseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookPurchaseCreateManyUserInputEnvelope
    set?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    disconnect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    delete?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    connect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    update?: BookPurchaseUpdateWithWhereUniqueWithoutUserInput | BookPurchaseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookPurchaseUpdateManyWithWhereWithoutUserInput | BookPurchaseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookPurchaseScalarWhereInput | BookPurchaseScalarWhereInput[]
  }

  export type DonationUpdateManyWithoutUserNestedInput = {
    create?: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput> | DonationCreateWithoutUserInput[] | DonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutUserInput | DonationCreateOrConnectWithoutUserInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutUserInput | DonationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DonationCreateManyUserInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutUserInput | DonationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutUserInput | DonationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookOrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookOrderCreateWithoutUserInput, BookOrderUncheckedCreateWithoutUserInput> | BookOrderCreateWithoutUserInput[] | BookOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookOrderCreateOrConnectWithoutUserInput | BookOrderCreateOrConnectWithoutUserInput[]
    upsert?: BookOrderUpsertWithWhereUniqueWithoutUserInput | BookOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookOrderCreateManyUserInputEnvelope
    set?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
    disconnect?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
    delete?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
    connect?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
    update?: BookOrderUpdateWithWhereUniqueWithoutUserInput | BookOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookOrderUpdateManyWithWhereWithoutUserInput | BookOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookOrderScalarWhereInput | BookOrderScalarWhereInput[]
  }

  export type BookPurchaseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookPurchaseCreateWithoutUserInput, BookPurchaseUncheckedCreateWithoutUserInput> | BookPurchaseCreateWithoutUserInput[] | BookPurchaseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookPurchaseCreateOrConnectWithoutUserInput | BookPurchaseCreateOrConnectWithoutUserInput[]
    upsert?: BookPurchaseUpsertWithWhereUniqueWithoutUserInput | BookPurchaseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookPurchaseCreateManyUserInputEnvelope
    set?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    disconnect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    delete?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    connect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    update?: BookPurchaseUpdateWithWhereUniqueWithoutUserInput | BookPurchaseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookPurchaseUpdateManyWithWhereWithoutUserInput | BookPurchaseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookPurchaseScalarWhereInput | BookPurchaseScalarWhereInput[]
  }

  export type DonationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput> | DonationCreateWithoutUserInput[] | DonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutUserInput | DonationCreateOrConnectWithoutUserInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutUserInput | DonationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DonationCreateManyUserInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutUserInput | DonationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutUserInput | DonationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDonationsInput = {
    create?: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDonationsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutDonationsNestedInput = {
    create?: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDonationsInput
    upsert?: UserUpsertWithoutDonationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDonationsInput, UserUpdateWithoutDonationsInput>, UserUncheckedUpdateWithoutDonationsInput>
  }

  export type BookPurchaseCreateNestedManyWithoutBookInput = {
    create?: XOR<BookPurchaseCreateWithoutBookInput, BookPurchaseUncheckedCreateWithoutBookInput> | BookPurchaseCreateWithoutBookInput[] | BookPurchaseUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookPurchaseCreateOrConnectWithoutBookInput | BookPurchaseCreateOrConnectWithoutBookInput[]
    createMany?: BookPurchaseCreateManyBookInputEnvelope
    connect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
  }

  export type BookOrderItemCreateNestedManyWithoutBookInput = {
    create?: XOR<BookOrderItemCreateWithoutBookInput, BookOrderItemUncheckedCreateWithoutBookInput> | BookOrderItemCreateWithoutBookInput[] | BookOrderItemUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookOrderItemCreateOrConnectWithoutBookInput | BookOrderItemCreateOrConnectWithoutBookInput[]
    createMany?: BookOrderItemCreateManyBookInputEnvelope
    connect?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
  }

  export type BookPurchaseUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<BookPurchaseCreateWithoutBookInput, BookPurchaseUncheckedCreateWithoutBookInput> | BookPurchaseCreateWithoutBookInput[] | BookPurchaseUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookPurchaseCreateOrConnectWithoutBookInput | BookPurchaseCreateOrConnectWithoutBookInput[]
    createMany?: BookPurchaseCreateManyBookInputEnvelope
    connect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
  }

  export type BookOrderItemUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<BookOrderItemCreateWithoutBookInput, BookOrderItemUncheckedCreateWithoutBookInput> | BookOrderItemCreateWithoutBookInput[] | BookOrderItemUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookOrderItemCreateOrConnectWithoutBookInput | BookOrderItemCreateOrConnectWithoutBookInput[]
    createMany?: BookOrderItemCreateManyBookInputEnvelope
    connect?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
  }

  export type BookPurchaseUpdateManyWithoutBookNestedInput = {
    create?: XOR<BookPurchaseCreateWithoutBookInput, BookPurchaseUncheckedCreateWithoutBookInput> | BookPurchaseCreateWithoutBookInput[] | BookPurchaseUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookPurchaseCreateOrConnectWithoutBookInput | BookPurchaseCreateOrConnectWithoutBookInput[]
    upsert?: BookPurchaseUpsertWithWhereUniqueWithoutBookInput | BookPurchaseUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: BookPurchaseCreateManyBookInputEnvelope
    set?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    disconnect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    delete?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    connect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    update?: BookPurchaseUpdateWithWhereUniqueWithoutBookInput | BookPurchaseUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: BookPurchaseUpdateManyWithWhereWithoutBookInput | BookPurchaseUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: BookPurchaseScalarWhereInput | BookPurchaseScalarWhereInput[]
  }

  export type BookOrderItemUpdateManyWithoutBookNestedInput = {
    create?: XOR<BookOrderItemCreateWithoutBookInput, BookOrderItemUncheckedCreateWithoutBookInput> | BookOrderItemCreateWithoutBookInput[] | BookOrderItemUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookOrderItemCreateOrConnectWithoutBookInput | BookOrderItemCreateOrConnectWithoutBookInput[]
    upsert?: BookOrderItemUpsertWithWhereUniqueWithoutBookInput | BookOrderItemUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: BookOrderItemCreateManyBookInputEnvelope
    set?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
    disconnect?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
    delete?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
    connect?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
    update?: BookOrderItemUpdateWithWhereUniqueWithoutBookInput | BookOrderItemUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: BookOrderItemUpdateManyWithWhereWithoutBookInput | BookOrderItemUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: BookOrderItemScalarWhereInput | BookOrderItemScalarWhereInput[]
  }

  export type BookPurchaseUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<BookPurchaseCreateWithoutBookInput, BookPurchaseUncheckedCreateWithoutBookInput> | BookPurchaseCreateWithoutBookInput[] | BookPurchaseUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookPurchaseCreateOrConnectWithoutBookInput | BookPurchaseCreateOrConnectWithoutBookInput[]
    upsert?: BookPurchaseUpsertWithWhereUniqueWithoutBookInput | BookPurchaseUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: BookPurchaseCreateManyBookInputEnvelope
    set?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    disconnect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    delete?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    connect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    update?: BookPurchaseUpdateWithWhereUniqueWithoutBookInput | BookPurchaseUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: BookPurchaseUpdateManyWithWhereWithoutBookInput | BookPurchaseUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: BookPurchaseScalarWhereInput | BookPurchaseScalarWhereInput[]
  }

  export type BookOrderItemUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<BookOrderItemCreateWithoutBookInput, BookOrderItemUncheckedCreateWithoutBookInput> | BookOrderItemCreateWithoutBookInput[] | BookOrderItemUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookOrderItemCreateOrConnectWithoutBookInput | BookOrderItemCreateOrConnectWithoutBookInput[]
    upsert?: BookOrderItemUpsertWithWhereUniqueWithoutBookInput | BookOrderItemUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: BookOrderItemCreateManyBookInputEnvelope
    set?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
    disconnect?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
    delete?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
    connect?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
    update?: BookOrderItemUpdateWithWhereUniqueWithoutBookInput | BookOrderItemUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: BookOrderItemUpdateManyWithWhereWithoutBookInput | BookOrderItemUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: BookOrderItemScalarWhereInput | BookOrderItemScalarWhereInput[]
  }

  export type BookOrderCreateNestedManyWithoutCouponInput = {
    create?: XOR<BookOrderCreateWithoutCouponInput, BookOrderUncheckedCreateWithoutCouponInput> | BookOrderCreateWithoutCouponInput[] | BookOrderUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: BookOrderCreateOrConnectWithoutCouponInput | BookOrderCreateOrConnectWithoutCouponInput[]
    createMany?: BookOrderCreateManyCouponInputEnvelope
    connect?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
  }

  export type BookOrderUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<BookOrderCreateWithoutCouponInput, BookOrderUncheckedCreateWithoutCouponInput> | BookOrderCreateWithoutCouponInput[] | BookOrderUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: BookOrderCreateOrConnectWithoutCouponInput | BookOrderCreateOrConnectWithoutCouponInput[]
    createMany?: BookOrderCreateManyCouponInputEnvelope
    connect?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
  }

  export type BookOrderUpdateManyWithoutCouponNestedInput = {
    create?: XOR<BookOrderCreateWithoutCouponInput, BookOrderUncheckedCreateWithoutCouponInput> | BookOrderCreateWithoutCouponInput[] | BookOrderUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: BookOrderCreateOrConnectWithoutCouponInput | BookOrderCreateOrConnectWithoutCouponInput[]
    upsert?: BookOrderUpsertWithWhereUniqueWithoutCouponInput | BookOrderUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: BookOrderCreateManyCouponInputEnvelope
    set?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
    disconnect?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
    delete?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
    connect?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
    update?: BookOrderUpdateWithWhereUniqueWithoutCouponInput | BookOrderUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: BookOrderUpdateManyWithWhereWithoutCouponInput | BookOrderUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: BookOrderScalarWhereInput | BookOrderScalarWhereInput[]
  }

  export type BookOrderUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<BookOrderCreateWithoutCouponInput, BookOrderUncheckedCreateWithoutCouponInput> | BookOrderCreateWithoutCouponInput[] | BookOrderUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: BookOrderCreateOrConnectWithoutCouponInput | BookOrderCreateOrConnectWithoutCouponInput[]
    upsert?: BookOrderUpsertWithWhereUniqueWithoutCouponInput | BookOrderUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: BookOrderCreateManyCouponInputEnvelope
    set?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
    disconnect?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
    delete?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
    connect?: BookOrderWhereUniqueInput | BookOrderWhereUniqueInput[]
    update?: BookOrderUpdateWithWhereUniqueWithoutCouponInput | BookOrderUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: BookOrderUpdateManyWithWhereWithoutCouponInput | BookOrderUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: BookOrderScalarWhereInput | BookOrderScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBookOrdersInput = {
    create?: XOR<UserCreateWithoutBookOrdersInput, UserUncheckedCreateWithoutBookOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type BookCouponCreateNestedOneWithoutOrdersInput = {
    create?: XOR<BookCouponCreateWithoutOrdersInput, BookCouponUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: BookCouponCreateOrConnectWithoutOrdersInput
    connect?: BookCouponWhereUniqueInput
  }

  export type BookOrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<BookOrderItemCreateWithoutOrderInput, BookOrderItemUncheckedCreateWithoutOrderInput> | BookOrderItemCreateWithoutOrderInput[] | BookOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: BookOrderItemCreateOrConnectWithoutOrderInput | BookOrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: BookOrderItemCreateManyOrderInputEnvelope
    connect?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
  }

  export type BookPurchaseCreateNestedManyWithoutOrderInput = {
    create?: XOR<BookPurchaseCreateWithoutOrderInput, BookPurchaseUncheckedCreateWithoutOrderInput> | BookPurchaseCreateWithoutOrderInput[] | BookPurchaseUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: BookPurchaseCreateOrConnectWithoutOrderInput | BookPurchaseCreateOrConnectWithoutOrderInput[]
    createMany?: BookPurchaseCreateManyOrderInputEnvelope
    connect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
  }

  export type BookOrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<BookOrderItemCreateWithoutOrderInput, BookOrderItemUncheckedCreateWithoutOrderInput> | BookOrderItemCreateWithoutOrderInput[] | BookOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: BookOrderItemCreateOrConnectWithoutOrderInput | BookOrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: BookOrderItemCreateManyOrderInputEnvelope
    connect?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
  }

  export type BookPurchaseUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<BookPurchaseCreateWithoutOrderInput, BookPurchaseUncheckedCreateWithoutOrderInput> | BookPurchaseCreateWithoutOrderInput[] | BookPurchaseUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: BookPurchaseCreateOrConnectWithoutOrderInput | BookPurchaseCreateOrConnectWithoutOrderInput[]
    createMany?: BookPurchaseCreateManyOrderInputEnvelope
    connect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutBookOrdersNestedInput = {
    create?: XOR<UserCreateWithoutBookOrdersInput, UserUncheckedCreateWithoutBookOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookOrdersInput
    upsert?: UserUpsertWithoutBookOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookOrdersInput, UserUpdateWithoutBookOrdersInput>, UserUncheckedUpdateWithoutBookOrdersInput>
  }

  export type BookCouponUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<BookCouponCreateWithoutOrdersInput, BookCouponUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: BookCouponCreateOrConnectWithoutOrdersInput
    upsert?: BookCouponUpsertWithoutOrdersInput
    disconnect?: BookCouponWhereInput | boolean
    delete?: BookCouponWhereInput | boolean
    connect?: BookCouponWhereUniqueInput
    update?: XOR<XOR<BookCouponUpdateToOneWithWhereWithoutOrdersInput, BookCouponUpdateWithoutOrdersInput>, BookCouponUncheckedUpdateWithoutOrdersInput>
  }

  export type BookOrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<BookOrderItemCreateWithoutOrderInput, BookOrderItemUncheckedCreateWithoutOrderInput> | BookOrderItemCreateWithoutOrderInput[] | BookOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: BookOrderItemCreateOrConnectWithoutOrderInput | BookOrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: BookOrderItemUpsertWithWhereUniqueWithoutOrderInput | BookOrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: BookOrderItemCreateManyOrderInputEnvelope
    set?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
    disconnect?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
    delete?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
    connect?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
    update?: BookOrderItemUpdateWithWhereUniqueWithoutOrderInput | BookOrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: BookOrderItemUpdateManyWithWhereWithoutOrderInput | BookOrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: BookOrderItemScalarWhereInput | BookOrderItemScalarWhereInput[]
  }

  export type BookPurchaseUpdateManyWithoutOrderNestedInput = {
    create?: XOR<BookPurchaseCreateWithoutOrderInput, BookPurchaseUncheckedCreateWithoutOrderInput> | BookPurchaseCreateWithoutOrderInput[] | BookPurchaseUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: BookPurchaseCreateOrConnectWithoutOrderInput | BookPurchaseCreateOrConnectWithoutOrderInput[]
    upsert?: BookPurchaseUpsertWithWhereUniqueWithoutOrderInput | BookPurchaseUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: BookPurchaseCreateManyOrderInputEnvelope
    set?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    disconnect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    delete?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    connect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    update?: BookPurchaseUpdateWithWhereUniqueWithoutOrderInput | BookPurchaseUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: BookPurchaseUpdateManyWithWhereWithoutOrderInput | BookPurchaseUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: BookPurchaseScalarWhereInput | BookPurchaseScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookOrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<BookOrderItemCreateWithoutOrderInput, BookOrderItemUncheckedCreateWithoutOrderInput> | BookOrderItemCreateWithoutOrderInput[] | BookOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: BookOrderItemCreateOrConnectWithoutOrderInput | BookOrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: BookOrderItemUpsertWithWhereUniqueWithoutOrderInput | BookOrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: BookOrderItemCreateManyOrderInputEnvelope
    set?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
    disconnect?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
    delete?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
    connect?: BookOrderItemWhereUniqueInput | BookOrderItemWhereUniqueInput[]
    update?: BookOrderItemUpdateWithWhereUniqueWithoutOrderInput | BookOrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: BookOrderItemUpdateManyWithWhereWithoutOrderInput | BookOrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: BookOrderItemScalarWhereInput | BookOrderItemScalarWhereInput[]
  }

  export type BookPurchaseUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<BookPurchaseCreateWithoutOrderInput, BookPurchaseUncheckedCreateWithoutOrderInput> | BookPurchaseCreateWithoutOrderInput[] | BookPurchaseUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: BookPurchaseCreateOrConnectWithoutOrderInput | BookPurchaseCreateOrConnectWithoutOrderInput[]
    upsert?: BookPurchaseUpsertWithWhereUniqueWithoutOrderInput | BookPurchaseUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: BookPurchaseCreateManyOrderInputEnvelope
    set?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    disconnect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    delete?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    connect?: BookPurchaseWhereUniqueInput | BookPurchaseWhereUniqueInput[]
    update?: BookPurchaseUpdateWithWhereUniqueWithoutOrderInput | BookPurchaseUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: BookPurchaseUpdateManyWithWhereWithoutOrderInput | BookPurchaseUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: BookPurchaseScalarWhereInput | BookPurchaseScalarWhereInput[]
  }

  export type BookOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<BookOrderCreateWithoutItemsInput, BookOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BookOrderCreateOrConnectWithoutItemsInput
    connect?: BookOrderWhereUniqueInput
  }

  export type BookCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<BookCreateWithoutOrderItemsInput, BookUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: BookCreateOrConnectWithoutOrderItemsInput
    connect?: BookWhereUniqueInput
  }

  export type BookOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<BookOrderCreateWithoutItemsInput, BookOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BookOrderCreateOrConnectWithoutItemsInput
    upsert?: BookOrderUpsertWithoutItemsInput
    connect?: BookOrderWhereUniqueInput
    update?: XOR<XOR<BookOrderUpdateToOneWithWhereWithoutItemsInput, BookOrderUpdateWithoutItemsInput>, BookOrderUncheckedUpdateWithoutItemsInput>
  }

  export type BookUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<BookCreateWithoutOrderItemsInput, BookUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: BookCreateOrConnectWithoutOrderItemsInput
    upsert?: BookUpsertWithoutOrderItemsInput
    connect?: BookWhereUniqueInput
    update?: XOR<XOR<BookUpdateToOneWithWhereWithoutOrderItemsInput, BookUpdateWithoutOrderItemsInput>, BookUncheckedUpdateWithoutOrderItemsInput>
  }

  export type UserCreateNestedOneWithoutBookPurchasesInput = {
    create?: XOR<UserCreateWithoutBookPurchasesInput, UserUncheckedCreateWithoutBookPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookPurchasesInput
    connect?: UserWhereUniqueInput
  }

  export type BookCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<BookCreateWithoutPurchasesInput, BookUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: BookCreateOrConnectWithoutPurchasesInput
    connect?: BookWhereUniqueInput
  }

  export type BookOrderCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<BookOrderCreateWithoutPurchasesInput, BookOrderUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: BookOrderCreateOrConnectWithoutPurchasesInput
    connect?: BookOrderWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBookPurchasesNestedInput = {
    create?: XOR<UserCreateWithoutBookPurchasesInput, UserUncheckedCreateWithoutBookPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookPurchasesInput
    upsert?: UserUpsertWithoutBookPurchasesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookPurchasesInput, UserUpdateWithoutBookPurchasesInput>, UserUncheckedUpdateWithoutBookPurchasesInput>
  }

  export type BookUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<BookCreateWithoutPurchasesInput, BookUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: BookCreateOrConnectWithoutPurchasesInput
    upsert?: BookUpsertWithoutPurchasesInput
    connect?: BookWhereUniqueInput
    update?: XOR<XOR<BookUpdateToOneWithWhereWithoutPurchasesInput, BookUpdateWithoutPurchasesInput>, BookUncheckedUpdateWithoutPurchasesInput>
  }

  export type BookOrderUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<BookOrderCreateWithoutPurchasesInput, BookOrderUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: BookOrderCreateOrConnectWithoutPurchasesInput
    upsert?: BookOrderUpsertWithoutPurchasesInput
    connect?: BookOrderWhereUniqueInput
    update?: XOR<XOR<BookOrderUpdateToOneWithWhereWithoutPurchasesInput, BookOrderUpdateWithoutPurchasesInput>, BookOrderUncheckedUpdateWithoutPurchasesInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type FoundationStatCreateNestedManyWithoutFoundationInput = {
    create?: XOR<FoundationStatCreateWithoutFoundationInput, FoundationStatUncheckedCreateWithoutFoundationInput> | FoundationStatCreateWithoutFoundationInput[] | FoundationStatUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationStatCreateOrConnectWithoutFoundationInput | FoundationStatCreateOrConnectWithoutFoundationInput[]
    createMany?: FoundationStatCreateManyFoundationInputEnvelope
    connect?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
  }

  export type FoundationActivityCreateNestedManyWithoutFoundationInput = {
    create?: XOR<FoundationActivityCreateWithoutFoundationInput, FoundationActivityUncheckedCreateWithoutFoundationInput> | FoundationActivityCreateWithoutFoundationInput[] | FoundationActivityUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationActivityCreateOrConnectWithoutFoundationInput | FoundationActivityCreateOrConnectWithoutFoundationInput[]
    createMany?: FoundationActivityCreateManyFoundationInputEnvelope
    connect?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
  }

  export type FoundationObjectiveCreateNestedManyWithoutFoundationInput = {
    create?: XOR<FoundationObjectiveCreateWithoutFoundationInput, FoundationObjectiveUncheckedCreateWithoutFoundationInput> | FoundationObjectiveCreateWithoutFoundationInput[] | FoundationObjectiveUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationObjectiveCreateOrConnectWithoutFoundationInput | FoundationObjectiveCreateOrConnectWithoutFoundationInput[]
    createMany?: FoundationObjectiveCreateManyFoundationInputEnvelope
    connect?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
  }

  export type FoundationContactCreateNestedOneWithoutFoundationInput = {
    create?: XOR<FoundationContactCreateWithoutFoundationInput, FoundationContactUncheckedCreateWithoutFoundationInput>
    connectOrCreate?: FoundationContactCreateOrConnectWithoutFoundationInput
    connect?: FoundationContactWhereUniqueInput
  }

  export type FoundationMediaCreateNestedManyWithoutFoundationInput = {
    create?: XOR<FoundationMediaCreateWithoutFoundationInput, FoundationMediaUncheckedCreateWithoutFoundationInput> | FoundationMediaCreateWithoutFoundationInput[] | FoundationMediaUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationMediaCreateOrConnectWithoutFoundationInput | FoundationMediaCreateOrConnectWithoutFoundationInput[]
    createMany?: FoundationMediaCreateManyFoundationInputEnvelope
    connect?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
  }

  export type FoundationStatUncheckedCreateNestedManyWithoutFoundationInput = {
    create?: XOR<FoundationStatCreateWithoutFoundationInput, FoundationStatUncheckedCreateWithoutFoundationInput> | FoundationStatCreateWithoutFoundationInput[] | FoundationStatUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationStatCreateOrConnectWithoutFoundationInput | FoundationStatCreateOrConnectWithoutFoundationInput[]
    createMany?: FoundationStatCreateManyFoundationInputEnvelope
    connect?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
  }

  export type FoundationActivityUncheckedCreateNestedManyWithoutFoundationInput = {
    create?: XOR<FoundationActivityCreateWithoutFoundationInput, FoundationActivityUncheckedCreateWithoutFoundationInput> | FoundationActivityCreateWithoutFoundationInput[] | FoundationActivityUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationActivityCreateOrConnectWithoutFoundationInput | FoundationActivityCreateOrConnectWithoutFoundationInput[]
    createMany?: FoundationActivityCreateManyFoundationInputEnvelope
    connect?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
  }

  export type FoundationObjectiveUncheckedCreateNestedManyWithoutFoundationInput = {
    create?: XOR<FoundationObjectiveCreateWithoutFoundationInput, FoundationObjectiveUncheckedCreateWithoutFoundationInput> | FoundationObjectiveCreateWithoutFoundationInput[] | FoundationObjectiveUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationObjectiveCreateOrConnectWithoutFoundationInput | FoundationObjectiveCreateOrConnectWithoutFoundationInput[]
    createMany?: FoundationObjectiveCreateManyFoundationInputEnvelope
    connect?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
  }

  export type FoundationContactUncheckedCreateNestedOneWithoutFoundationInput = {
    create?: XOR<FoundationContactCreateWithoutFoundationInput, FoundationContactUncheckedCreateWithoutFoundationInput>
    connectOrCreate?: FoundationContactCreateOrConnectWithoutFoundationInput
    connect?: FoundationContactWhereUniqueInput
  }

  export type FoundationMediaUncheckedCreateNestedManyWithoutFoundationInput = {
    create?: XOR<FoundationMediaCreateWithoutFoundationInput, FoundationMediaUncheckedCreateWithoutFoundationInput> | FoundationMediaCreateWithoutFoundationInput[] | FoundationMediaUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationMediaCreateOrConnectWithoutFoundationInput | FoundationMediaCreateOrConnectWithoutFoundationInput[]
    createMany?: FoundationMediaCreateManyFoundationInputEnvelope
    connect?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
  }

  export type FoundationStatUpdateManyWithoutFoundationNestedInput = {
    create?: XOR<FoundationStatCreateWithoutFoundationInput, FoundationStatUncheckedCreateWithoutFoundationInput> | FoundationStatCreateWithoutFoundationInput[] | FoundationStatUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationStatCreateOrConnectWithoutFoundationInput | FoundationStatCreateOrConnectWithoutFoundationInput[]
    upsert?: FoundationStatUpsertWithWhereUniqueWithoutFoundationInput | FoundationStatUpsertWithWhereUniqueWithoutFoundationInput[]
    createMany?: FoundationStatCreateManyFoundationInputEnvelope
    set?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
    disconnect?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
    delete?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
    connect?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
    update?: FoundationStatUpdateWithWhereUniqueWithoutFoundationInput | FoundationStatUpdateWithWhereUniqueWithoutFoundationInput[]
    updateMany?: FoundationStatUpdateManyWithWhereWithoutFoundationInput | FoundationStatUpdateManyWithWhereWithoutFoundationInput[]
    deleteMany?: FoundationStatScalarWhereInput | FoundationStatScalarWhereInput[]
  }

  export type FoundationActivityUpdateManyWithoutFoundationNestedInput = {
    create?: XOR<FoundationActivityCreateWithoutFoundationInput, FoundationActivityUncheckedCreateWithoutFoundationInput> | FoundationActivityCreateWithoutFoundationInput[] | FoundationActivityUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationActivityCreateOrConnectWithoutFoundationInput | FoundationActivityCreateOrConnectWithoutFoundationInput[]
    upsert?: FoundationActivityUpsertWithWhereUniqueWithoutFoundationInput | FoundationActivityUpsertWithWhereUniqueWithoutFoundationInput[]
    createMany?: FoundationActivityCreateManyFoundationInputEnvelope
    set?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
    disconnect?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
    delete?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
    connect?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
    update?: FoundationActivityUpdateWithWhereUniqueWithoutFoundationInput | FoundationActivityUpdateWithWhereUniqueWithoutFoundationInput[]
    updateMany?: FoundationActivityUpdateManyWithWhereWithoutFoundationInput | FoundationActivityUpdateManyWithWhereWithoutFoundationInput[]
    deleteMany?: FoundationActivityScalarWhereInput | FoundationActivityScalarWhereInput[]
  }

  export type FoundationObjectiveUpdateManyWithoutFoundationNestedInput = {
    create?: XOR<FoundationObjectiveCreateWithoutFoundationInput, FoundationObjectiveUncheckedCreateWithoutFoundationInput> | FoundationObjectiveCreateWithoutFoundationInput[] | FoundationObjectiveUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationObjectiveCreateOrConnectWithoutFoundationInput | FoundationObjectiveCreateOrConnectWithoutFoundationInput[]
    upsert?: FoundationObjectiveUpsertWithWhereUniqueWithoutFoundationInput | FoundationObjectiveUpsertWithWhereUniqueWithoutFoundationInput[]
    createMany?: FoundationObjectiveCreateManyFoundationInputEnvelope
    set?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
    disconnect?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
    delete?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
    connect?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
    update?: FoundationObjectiveUpdateWithWhereUniqueWithoutFoundationInput | FoundationObjectiveUpdateWithWhereUniqueWithoutFoundationInput[]
    updateMany?: FoundationObjectiveUpdateManyWithWhereWithoutFoundationInput | FoundationObjectiveUpdateManyWithWhereWithoutFoundationInput[]
    deleteMany?: FoundationObjectiveScalarWhereInput | FoundationObjectiveScalarWhereInput[]
  }

  export type FoundationContactUpdateOneWithoutFoundationNestedInput = {
    create?: XOR<FoundationContactCreateWithoutFoundationInput, FoundationContactUncheckedCreateWithoutFoundationInput>
    connectOrCreate?: FoundationContactCreateOrConnectWithoutFoundationInput
    upsert?: FoundationContactUpsertWithoutFoundationInput
    disconnect?: FoundationContactWhereInput | boolean
    delete?: FoundationContactWhereInput | boolean
    connect?: FoundationContactWhereUniqueInput
    update?: XOR<XOR<FoundationContactUpdateToOneWithWhereWithoutFoundationInput, FoundationContactUpdateWithoutFoundationInput>, FoundationContactUncheckedUpdateWithoutFoundationInput>
  }

  export type FoundationMediaUpdateManyWithoutFoundationNestedInput = {
    create?: XOR<FoundationMediaCreateWithoutFoundationInput, FoundationMediaUncheckedCreateWithoutFoundationInput> | FoundationMediaCreateWithoutFoundationInput[] | FoundationMediaUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationMediaCreateOrConnectWithoutFoundationInput | FoundationMediaCreateOrConnectWithoutFoundationInput[]
    upsert?: FoundationMediaUpsertWithWhereUniqueWithoutFoundationInput | FoundationMediaUpsertWithWhereUniqueWithoutFoundationInput[]
    createMany?: FoundationMediaCreateManyFoundationInputEnvelope
    set?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
    disconnect?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
    delete?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
    connect?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
    update?: FoundationMediaUpdateWithWhereUniqueWithoutFoundationInput | FoundationMediaUpdateWithWhereUniqueWithoutFoundationInput[]
    updateMany?: FoundationMediaUpdateManyWithWhereWithoutFoundationInput | FoundationMediaUpdateManyWithWhereWithoutFoundationInput[]
    deleteMany?: FoundationMediaScalarWhereInput | FoundationMediaScalarWhereInput[]
  }

  export type FoundationStatUncheckedUpdateManyWithoutFoundationNestedInput = {
    create?: XOR<FoundationStatCreateWithoutFoundationInput, FoundationStatUncheckedCreateWithoutFoundationInput> | FoundationStatCreateWithoutFoundationInput[] | FoundationStatUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationStatCreateOrConnectWithoutFoundationInput | FoundationStatCreateOrConnectWithoutFoundationInput[]
    upsert?: FoundationStatUpsertWithWhereUniqueWithoutFoundationInput | FoundationStatUpsertWithWhereUniqueWithoutFoundationInput[]
    createMany?: FoundationStatCreateManyFoundationInputEnvelope
    set?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
    disconnect?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
    delete?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
    connect?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
    update?: FoundationStatUpdateWithWhereUniqueWithoutFoundationInput | FoundationStatUpdateWithWhereUniqueWithoutFoundationInput[]
    updateMany?: FoundationStatUpdateManyWithWhereWithoutFoundationInput | FoundationStatUpdateManyWithWhereWithoutFoundationInput[]
    deleteMany?: FoundationStatScalarWhereInput | FoundationStatScalarWhereInput[]
  }

  export type FoundationActivityUncheckedUpdateManyWithoutFoundationNestedInput = {
    create?: XOR<FoundationActivityCreateWithoutFoundationInput, FoundationActivityUncheckedCreateWithoutFoundationInput> | FoundationActivityCreateWithoutFoundationInput[] | FoundationActivityUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationActivityCreateOrConnectWithoutFoundationInput | FoundationActivityCreateOrConnectWithoutFoundationInput[]
    upsert?: FoundationActivityUpsertWithWhereUniqueWithoutFoundationInput | FoundationActivityUpsertWithWhereUniqueWithoutFoundationInput[]
    createMany?: FoundationActivityCreateManyFoundationInputEnvelope
    set?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
    disconnect?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
    delete?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
    connect?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
    update?: FoundationActivityUpdateWithWhereUniqueWithoutFoundationInput | FoundationActivityUpdateWithWhereUniqueWithoutFoundationInput[]
    updateMany?: FoundationActivityUpdateManyWithWhereWithoutFoundationInput | FoundationActivityUpdateManyWithWhereWithoutFoundationInput[]
    deleteMany?: FoundationActivityScalarWhereInput | FoundationActivityScalarWhereInput[]
  }

  export type FoundationObjectiveUncheckedUpdateManyWithoutFoundationNestedInput = {
    create?: XOR<FoundationObjectiveCreateWithoutFoundationInput, FoundationObjectiveUncheckedCreateWithoutFoundationInput> | FoundationObjectiveCreateWithoutFoundationInput[] | FoundationObjectiveUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationObjectiveCreateOrConnectWithoutFoundationInput | FoundationObjectiveCreateOrConnectWithoutFoundationInput[]
    upsert?: FoundationObjectiveUpsertWithWhereUniqueWithoutFoundationInput | FoundationObjectiveUpsertWithWhereUniqueWithoutFoundationInput[]
    createMany?: FoundationObjectiveCreateManyFoundationInputEnvelope
    set?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
    disconnect?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
    delete?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
    connect?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
    update?: FoundationObjectiveUpdateWithWhereUniqueWithoutFoundationInput | FoundationObjectiveUpdateWithWhereUniqueWithoutFoundationInput[]
    updateMany?: FoundationObjectiveUpdateManyWithWhereWithoutFoundationInput | FoundationObjectiveUpdateManyWithWhereWithoutFoundationInput[]
    deleteMany?: FoundationObjectiveScalarWhereInput | FoundationObjectiveScalarWhereInput[]
  }

  export type FoundationContactUncheckedUpdateOneWithoutFoundationNestedInput = {
    create?: XOR<FoundationContactCreateWithoutFoundationInput, FoundationContactUncheckedCreateWithoutFoundationInput>
    connectOrCreate?: FoundationContactCreateOrConnectWithoutFoundationInput
    upsert?: FoundationContactUpsertWithoutFoundationInput
    disconnect?: FoundationContactWhereInput | boolean
    delete?: FoundationContactWhereInput | boolean
    connect?: FoundationContactWhereUniqueInput
    update?: XOR<XOR<FoundationContactUpdateToOneWithWhereWithoutFoundationInput, FoundationContactUpdateWithoutFoundationInput>, FoundationContactUncheckedUpdateWithoutFoundationInput>
  }

  export type FoundationMediaUncheckedUpdateManyWithoutFoundationNestedInput = {
    create?: XOR<FoundationMediaCreateWithoutFoundationInput, FoundationMediaUncheckedCreateWithoutFoundationInput> | FoundationMediaCreateWithoutFoundationInput[] | FoundationMediaUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationMediaCreateOrConnectWithoutFoundationInput | FoundationMediaCreateOrConnectWithoutFoundationInput[]
    upsert?: FoundationMediaUpsertWithWhereUniqueWithoutFoundationInput | FoundationMediaUpsertWithWhereUniqueWithoutFoundationInput[]
    createMany?: FoundationMediaCreateManyFoundationInputEnvelope
    set?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
    disconnect?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
    delete?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
    connect?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
    update?: FoundationMediaUpdateWithWhereUniqueWithoutFoundationInput | FoundationMediaUpdateWithWhereUniqueWithoutFoundationInput[]
    updateMany?: FoundationMediaUpdateManyWithWhereWithoutFoundationInput | FoundationMediaUpdateManyWithWhereWithoutFoundationInput[]
    deleteMany?: FoundationMediaScalarWhereInput | FoundationMediaScalarWhereInput[]
  }

  export type FoundationCreateNestedOneWithoutStatsInput = {
    create?: XOR<FoundationCreateWithoutStatsInput, FoundationUncheckedCreateWithoutStatsInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutStatsInput
    connect?: FoundationWhereUniqueInput
  }

  export type FoundationUpdateOneRequiredWithoutStatsNestedInput = {
    create?: XOR<FoundationCreateWithoutStatsInput, FoundationUncheckedCreateWithoutStatsInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutStatsInput
    upsert?: FoundationUpsertWithoutStatsInput
    connect?: FoundationWhereUniqueInput
    update?: XOR<XOR<FoundationUpdateToOneWithWhereWithoutStatsInput, FoundationUpdateWithoutStatsInput>, FoundationUncheckedUpdateWithoutStatsInput>
  }

  export type FoundationCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<FoundationCreateWithoutActivitiesInput, FoundationUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutActivitiesInput
    connect?: FoundationWhereUniqueInput
  }

  export type FoundationUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<FoundationCreateWithoutActivitiesInput, FoundationUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutActivitiesInput
    upsert?: FoundationUpsertWithoutActivitiesInput
    connect?: FoundationWhereUniqueInput
    update?: XOR<XOR<FoundationUpdateToOneWithWhereWithoutActivitiesInput, FoundationUpdateWithoutActivitiesInput>, FoundationUncheckedUpdateWithoutActivitiesInput>
  }

  export type FoundationCreateNestedOneWithoutObjectivesInput = {
    create?: XOR<FoundationCreateWithoutObjectivesInput, FoundationUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutObjectivesInput
    connect?: FoundationWhereUniqueInput
  }

  export type EnumObjectiveTypeFieldUpdateOperationsInput = {
    set?: $Enums.ObjectiveType
  }

  export type FoundationUpdateOneRequiredWithoutObjectivesNestedInput = {
    create?: XOR<FoundationCreateWithoutObjectivesInput, FoundationUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutObjectivesInput
    upsert?: FoundationUpsertWithoutObjectivesInput
    connect?: FoundationWhereUniqueInput
    update?: XOR<XOR<FoundationUpdateToOneWithWhereWithoutObjectivesInput, FoundationUpdateWithoutObjectivesInput>, FoundationUncheckedUpdateWithoutObjectivesInput>
  }

  export type FoundationCreateNestedOneWithoutContactInput = {
    create?: XOR<FoundationCreateWithoutContactInput, FoundationUncheckedCreateWithoutContactInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutContactInput
    connect?: FoundationWhereUniqueInput
  }

  export type FoundationUpdateOneRequiredWithoutContactNestedInput = {
    create?: XOR<FoundationCreateWithoutContactInput, FoundationUncheckedCreateWithoutContactInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutContactInput
    upsert?: FoundationUpsertWithoutContactInput
    connect?: FoundationWhereUniqueInput
    update?: XOR<XOR<FoundationUpdateToOneWithWhereWithoutContactInput, FoundationUpdateWithoutContactInput>, FoundationUncheckedUpdateWithoutContactInput>
  }

  export type FoundationCreateNestedOneWithoutMediaInput = {
    create?: XOR<FoundationCreateWithoutMediaInput, FoundationUncheckedCreateWithoutMediaInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutMediaInput
    connect?: FoundationWhereUniqueInput
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type FoundationUpdateOneWithoutMediaNestedInput = {
    create?: XOR<FoundationCreateWithoutMediaInput, FoundationUncheckedCreateWithoutMediaInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutMediaInput
    upsert?: FoundationUpsertWithoutMediaInput
    disconnect?: FoundationWhereInput | boolean
    delete?: FoundationWhereInput | boolean
    connect?: FoundationWhereUniqueInput
    update?: XOR<XOR<FoundationUpdateToOneWithWhereWithoutMediaInput, FoundationUpdateWithoutMediaInput>, FoundationUncheckedUpdateWithoutMediaInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumObjectiveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectiveType | EnumObjectiveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectiveType[]
    notIn?: $Enums.ObjectiveType[]
    not?: NestedEnumObjectiveTypeFilter<$PrismaModel> | $Enums.ObjectiveType
  }

  export type NestedEnumObjectiveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectiveType | EnumObjectiveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectiveType[]
    notIn?: $Enums.ObjectiveType[]
    not?: NestedEnumObjectiveTypeWithAggregatesFilter<$PrismaModel> | $Enums.ObjectiveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumObjectiveTypeFilter<$PrismaModel>
    _max?: NestedEnumObjectiveTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[]
    notIn?: $Enums.MediaType[]
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[]
    notIn?: $Enums.MediaType[]
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type BookOrderCreateWithoutUserInput = {
    totalAmount: number
    discountAmount?: number
    finalAmount: number
    paymentId?: string | null
    orderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coupon?: BookCouponCreateNestedOneWithoutOrdersInput
    items?: BookOrderItemCreateNestedManyWithoutOrderInput
    purchases?: BookPurchaseCreateNestedManyWithoutOrderInput
  }

  export type BookOrderUncheckedCreateWithoutUserInput = {
    id?: number
    totalAmount: number
    discountAmount?: number
    finalAmount: number
    couponId?: number | null
    paymentId?: string | null
    orderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: BookOrderItemUncheckedCreateNestedManyWithoutOrderInput
    purchases?: BookPurchaseUncheckedCreateNestedManyWithoutOrderInput
  }

  export type BookOrderCreateOrConnectWithoutUserInput = {
    where: BookOrderWhereUniqueInput
    create: XOR<BookOrderCreateWithoutUserInput, BookOrderUncheckedCreateWithoutUserInput>
  }

  export type BookOrderCreateManyUserInputEnvelope = {
    data: BookOrderCreateManyUserInput | BookOrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookPurchaseCreateWithoutUserInput = {
    purchaseDate?: Date | string
    accessGranted?: boolean
    book: BookCreateNestedOneWithoutPurchasesInput
    order: BookOrderCreateNestedOneWithoutPurchasesInput
  }

  export type BookPurchaseUncheckedCreateWithoutUserInput = {
    id?: number
    bookId: number
    orderId: number
    purchaseDate?: Date | string
    accessGranted?: boolean
  }

  export type BookPurchaseCreateOrConnectWithoutUserInput = {
    where: BookPurchaseWhereUniqueInput
    create: XOR<BookPurchaseCreateWithoutUserInput, BookPurchaseUncheckedCreateWithoutUserInput>
  }

  export type BookPurchaseCreateManyUserInputEnvelope = {
    data: BookPurchaseCreateManyUserInput | BookPurchaseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DonationCreateWithoutUserInput = {
    amount: number
    status?: string
    paymentMethod?: string | null
    transactionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationUncheckedCreateWithoutUserInput = {
    id?: number
    amount: number
    status?: string
    paymentMethod?: string | null
    transactionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationCreateOrConnectWithoutUserInput = {
    where: DonationWhereUniqueInput
    create: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput>
  }

  export type DonationCreateManyUserInputEnvelope = {
    data: DonationCreateManyUserInput | DonationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    referenceId: string
    provider: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: number
    referenceId: string
    provider: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookOrderUpsertWithWhereUniqueWithoutUserInput = {
    where: BookOrderWhereUniqueInput
    update: XOR<BookOrderUpdateWithoutUserInput, BookOrderUncheckedUpdateWithoutUserInput>
    create: XOR<BookOrderCreateWithoutUserInput, BookOrderUncheckedCreateWithoutUserInput>
  }

  export type BookOrderUpdateWithWhereUniqueWithoutUserInput = {
    where: BookOrderWhereUniqueInput
    data: XOR<BookOrderUpdateWithoutUserInput, BookOrderUncheckedUpdateWithoutUserInput>
  }

  export type BookOrderUpdateManyWithWhereWithoutUserInput = {
    where: BookOrderScalarWhereInput
    data: XOR<BookOrderUpdateManyMutationInput, BookOrderUncheckedUpdateManyWithoutUserInput>
  }

  export type BookOrderScalarWhereInput = {
    AND?: BookOrderScalarWhereInput | BookOrderScalarWhereInput[]
    OR?: BookOrderScalarWhereInput[]
    NOT?: BookOrderScalarWhereInput | BookOrderScalarWhereInput[]
    id?: IntFilter<"BookOrder"> | number
    userId?: IntFilter<"BookOrder"> | number
    totalAmount?: FloatFilter<"BookOrder"> | number
    discountAmount?: FloatFilter<"BookOrder"> | number
    finalAmount?: FloatFilter<"BookOrder"> | number
    couponId?: IntNullableFilter<"BookOrder"> | number | null
    paymentId?: StringNullableFilter<"BookOrder"> | string | null
    orderId?: StringNullableFilter<"BookOrder"> | string | null
    status?: StringFilter<"BookOrder"> | string
    createdAt?: DateTimeFilter<"BookOrder"> | Date | string
    updatedAt?: DateTimeFilter<"BookOrder"> | Date | string
  }

  export type BookPurchaseUpsertWithWhereUniqueWithoutUserInput = {
    where: BookPurchaseWhereUniqueInput
    update: XOR<BookPurchaseUpdateWithoutUserInput, BookPurchaseUncheckedUpdateWithoutUserInput>
    create: XOR<BookPurchaseCreateWithoutUserInput, BookPurchaseUncheckedCreateWithoutUserInput>
  }

  export type BookPurchaseUpdateWithWhereUniqueWithoutUserInput = {
    where: BookPurchaseWhereUniqueInput
    data: XOR<BookPurchaseUpdateWithoutUserInput, BookPurchaseUncheckedUpdateWithoutUserInput>
  }

  export type BookPurchaseUpdateManyWithWhereWithoutUserInput = {
    where: BookPurchaseScalarWhereInput
    data: XOR<BookPurchaseUpdateManyMutationInput, BookPurchaseUncheckedUpdateManyWithoutUserInput>
  }

  export type BookPurchaseScalarWhereInput = {
    AND?: BookPurchaseScalarWhereInput | BookPurchaseScalarWhereInput[]
    OR?: BookPurchaseScalarWhereInput[]
    NOT?: BookPurchaseScalarWhereInput | BookPurchaseScalarWhereInput[]
    id?: IntFilter<"BookPurchase"> | number
    userId?: IntFilter<"BookPurchase"> | number
    bookId?: IntFilter<"BookPurchase"> | number
    orderId?: IntFilter<"BookPurchase"> | number
    purchaseDate?: DateTimeFilter<"BookPurchase"> | Date | string
    accessGranted?: BoolFilter<"BookPurchase"> | boolean
  }

  export type DonationUpsertWithWhereUniqueWithoutUserInput = {
    where: DonationWhereUniqueInput
    update: XOR<DonationUpdateWithoutUserInput, DonationUncheckedUpdateWithoutUserInput>
    create: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput>
  }

  export type DonationUpdateWithWhereUniqueWithoutUserInput = {
    where: DonationWhereUniqueInput
    data: XOR<DonationUpdateWithoutUserInput, DonationUncheckedUpdateWithoutUserInput>
  }

  export type DonationUpdateManyWithWhereWithoutUserInput = {
    where: DonationScalarWhereInput
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyWithoutUserInput>
  }

  export type DonationScalarWhereInput = {
    AND?: DonationScalarWhereInput | DonationScalarWhereInput[]
    OR?: DonationScalarWhereInput[]
    NOT?: DonationScalarWhereInput | DonationScalarWhereInput[]
    id?: IntFilter<"Donation"> | number
    userId?: IntFilter<"Donation"> | number
    amount?: FloatFilter<"Donation"> | number
    status?: StringFilter<"Donation"> | string
    paymentMethod?: StringNullableFilter<"Donation"> | string | null
    transactionId?: StringFilter<"Donation"> | string
    createdAt?: DateTimeFilter<"Donation"> | Date | string
    updatedAt?: DateTimeFilter<"Donation"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    userId?: IntFilter<"Payment"> | number
    referenceId?: StringFilter<"Payment"> | string
    provider?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type UserCreateWithoutDonationsInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookOrders?: BookOrderCreateNestedManyWithoutUserInput
    bookPurchases?: BookPurchaseCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDonationsInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookOrders?: BookOrderUncheckedCreateNestedManyWithoutUserInput
    bookPurchases?: BookPurchaseUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDonationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
  }

  export type UserUpsertWithoutDonationsInput = {
    update: XOR<UserUpdateWithoutDonationsInput, UserUncheckedUpdateWithoutDonationsInput>
    create: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDonationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDonationsInput, UserUncheckedUpdateWithoutDonationsInput>
  }

  export type UserUpdateWithoutDonationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookOrders?: BookOrderUpdateManyWithoutUserNestedInput
    bookPurchases?: BookPurchaseUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDonationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookOrders?: BookOrderUncheckedUpdateManyWithoutUserNestedInput
    bookPurchases?: BookPurchaseUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookPurchaseCreateWithoutBookInput = {
    purchaseDate?: Date | string
    accessGranted?: boolean
    user: UserCreateNestedOneWithoutBookPurchasesInput
    order: BookOrderCreateNestedOneWithoutPurchasesInput
  }

  export type BookPurchaseUncheckedCreateWithoutBookInput = {
    id?: number
    userId: number
    orderId: number
    purchaseDate?: Date | string
    accessGranted?: boolean
  }

  export type BookPurchaseCreateOrConnectWithoutBookInput = {
    where: BookPurchaseWhereUniqueInput
    create: XOR<BookPurchaseCreateWithoutBookInput, BookPurchaseUncheckedCreateWithoutBookInput>
  }

  export type BookPurchaseCreateManyBookInputEnvelope = {
    data: BookPurchaseCreateManyBookInput | BookPurchaseCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type BookOrderItemCreateWithoutBookInput = {
    price: number
    order: BookOrderCreateNestedOneWithoutItemsInput
  }

  export type BookOrderItemUncheckedCreateWithoutBookInput = {
    id?: number
    orderId: number
    price: number
  }

  export type BookOrderItemCreateOrConnectWithoutBookInput = {
    where: BookOrderItemWhereUniqueInput
    create: XOR<BookOrderItemCreateWithoutBookInput, BookOrderItemUncheckedCreateWithoutBookInput>
  }

  export type BookOrderItemCreateManyBookInputEnvelope = {
    data: BookOrderItemCreateManyBookInput | BookOrderItemCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type BookPurchaseUpsertWithWhereUniqueWithoutBookInput = {
    where: BookPurchaseWhereUniqueInput
    update: XOR<BookPurchaseUpdateWithoutBookInput, BookPurchaseUncheckedUpdateWithoutBookInput>
    create: XOR<BookPurchaseCreateWithoutBookInput, BookPurchaseUncheckedCreateWithoutBookInput>
  }

  export type BookPurchaseUpdateWithWhereUniqueWithoutBookInput = {
    where: BookPurchaseWhereUniqueInput
    data: XOR<BookPurchaseUpdateWithoutBookInput, BookPurchaseUncheckedUpdateWithoutBookInput>
  }

  export type BookPurchaseUpdateManyWithWhereWithoutBookInput = {
    where: BookPurchaseScalarWhereInput
    data: XOR<BookPurchaseUpdateManyMutationInput, BookPurchaseUncheckedUpdateManyWithoutBookInput>
  }

  export type BookOrderItemUpsertWithWhereUniqueWithoutBookInput = {
    where: BookOrderItemWhereUniqueInput
    update: XOR<BookOrderItemUpdateWithoutBookInput, BookOrderItemUncheckedUpdateWithoutBookInput>
    create: XOR<BookOrderItemCreateWithoutBookInput, BookOrderItemUncheckedCreateWithoutBookInput>
  }

  export type BookOrderItemUpdateWithWhereUniqueWithoutBookInput = {
    where: BookOrderItemWhereUniqueInput
    data: XOR<BookOrderItemUpdateWithoutBookInput, BookOrderItemUncheckedUpdateWithoutBookInput>
  }

  export type BookOrderItemUpdateManyWithWhereWithoutBookInput = {
    where: BookOrderItemScalarWhereInput
    data: XOR<BookOrderItemUpdateManyMutationInput, BookOrderItemUncheckedUpdateManyWithoutBookInput>
  }

  export type BookOrderItemScalarWhereInput = {
    AND?: BookOrderItemScalarWhereInput | BookOrderItemScalarWhereInput[]
    OR?: BookOrderItemScalarWhereInput[]
    NOT?: BookOrderItemScalarWhereInput | BookOrderItemScalarWhereInput[]
    id?: IntFilter<"BookOrderItem"> | number
    orderId?: IntFilter<"BookOrderItem"> | number
    bookId?: IntFilter<"BookOrderItem"> | number
    price?: FloatFilter<"BookOrderItem"> | number
  }

  export type BookOrderCreateWithoutCouponInput = {
    totalAmount: number
    discountAmount?: number
    finalAmount: number
    paymentId?: string | null
    orderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBookOrdersInput
    items?: BookOrderItemCreateNestedManyWithoutOrderInput
    purchases?: BookPurchaseCreateNestedManyWithoutOrderInput
  }

  export type BookOrderUncheckedCreateWithoutCouponInput = {
    id?: number
    userId: number
    totalAmount: number
    discountAmount?: number
    finalAmount: number
    paymentId?: string | null
    orderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: BookOrderItemUncheckedCreateNestedManyWithoutOrderInput
    purchases?: BookPurchaseUncheckedCreateNestedManyWithoutOrderInput
  }

  export type BookOrderCreateOrConnectWithoutCouponInput = {
    where: BookOrderWhereUniqueInput
    create: XOR<BookOrderCreateWithoutCouponInput, BookOrderUncheckedCreateWithoutCouponInput>
  }

  export type BookOrderCreateManyCouponInputEnvelope = {
    data: BookOrderCreateManyCouponInput | BookOrderCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type BookOrderUpsertWithWhereUniqueWithoutCouponInput = {
    where: BookOrderWhereUniqueInput
    update: XOR<BookOrderUpdateWithoutCouponInput, BookOrderUncheckedUpdateWithoutCouponInput>
    create: XOR<BookOrderCreateWithoutCouponInput, BookOrderUncheckedCreateWithoutCouponInput>
  }

  export type BookOrderUpdateWithWhereUniqueWithoutCouponInput = {
    where: BookOrderWhereUniqueInput
    data: XOR<BookOrderUpdateWithoutCouponInput, BookOrderUncheckedUpdateWithoutCouponInput>
  }

  export type BookOrderUpdateManyWithWhereWithoutCouponInput = {
    where: BookOrderScalarWhereInput
    data: XOR<BookOrderUpdateManyMutationInput, BookOrderUncheckedUpdateManyWithoutCouponInput>
  }

  export type UserCreateWithoutBookOrdersInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookPurchases?: BookPurchaseCreateNestedManyWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookOrdersInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookPurchases?: BookPurchaseUncheckedCreateNestedManyWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookOrdersInput, UserUncheckedCreateWithoutBookOrdersInput>
  }

  export type BookCouponCreateWithoutOrdersInput = {
    code: string
    discount: number
    type: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCouponUncheckedCreateWithoutOrdersInput = {
    id?: number
    code: string
    discount: number
    type: string
    description?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCouponCreateOrConnectWithoutOrdersInput = {
    where: BookCouponWhereUniqueInput
    create: XOR<BookCouponCreateWithoutOrdersInput, BookCouponUncheckedCreateWithoutOrdersInput>
  }

  export type BookOrderItemCreateWithoutOrderInput = {
    price: number
    book: BookCreateNestedOneWithoutOrderItemsInput
  }

  export type BookOrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    bookId: number
    price: number
  }

  export type BookOrderItemCreateOrConnectWithoutOrderInput = {
    where: BookOrderItemWhereUniqueInput
    create: XOR<BookOrderItemCreateWithoutOrderInput, BookOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type BookOrderItemCreateManyOrderInputEnvelope = {
    data: BookOrderItemCreateManyOrderInput | BookOrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type BookPurchaseCreateWithoutOrderInput = {
    purchaseDate?: Date | string
    accessGranted?: boolean
    user: UserCreateNestedOneWithoutBookPurchasesInput
    book: BookCreateNestedOneWithoutPurchasesInput
  }

  export type BookPurchaseUncheckedCreateWithoutOrderInput = {
    id?: number
    userId: number
    bookId: number
    purchaseDate?: Date | string
    accessGranted?: boolean
  }

  export type BookPurchaseCreateOrConnectWithoutOrderInput = {
    where: BookPurchaseWhereUniqueInput
    create: XOR<BookPurchaseCreateWithoutOrderInput, BookPurchaseUncheckedCreateWithoutOrderInput>
  }

  export type BookPurchaseCreateManyOrderInputEnvelope = {
    data: BookPurchaseCreateManyOrderInput | BookPurchaseCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBookOrdersInput = {
    update: XOR<UserUpdateWithoutBookOrdersInput, UserUncheckedUpdateWithoutBookOrdersInput>
    create: XOR<UserCreateWithoutBookOrdersInput, UserUncheckedCreateWithoutBookOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookOrdersInput, UserUncheckedUpdateWithoutBookOrdersInput>
  }

  export type UserUpdateWithoutBookOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookPurchases?: BookPurchaseUpdateManyWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookPurchases?: BookPurchaseUncheckedUpdateManyWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookCouponUpsertWithoutOrdersInput = {
    update: XOR<BookCouponUpdateWithoutOrdersInput, BookCouponUncheckedUpdateWithoutOrdersInput>
    create: XOR<BookCouponCreateWithoutOrdersInput, BookCouponUncheckedCreateWithoutOrdersInput>
    where?: BookCouponWhereInput
  }

  export type BookCouponUpdateToOneWithWhereWithoutOrdersInput = {
    where?: BookCouponWhereInput
    data: XOR<BookCouponUpdateWithoutOrdersInput, BookCouponUncheckedUpdateWithoutOrdersInput>
  }

  export type BookCouponUpdateWithoutOrdersInput = {
    code?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCouponUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookOrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: BookOrderItemWhereUniqueInput
    update: XOR<BookOrderItemUpdateWithoutOrderInput, BookOrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<BookOrderItemCreateWithoutOrderInput, BookOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type BookOrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: BookOrderItemWhereUniqueInput
    data: XOR<BookOrderItemUpdateWithoutOrderInput, BookOrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type BookOrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: BookOrderItemScalarWhereInput
    data: XOR<BookOrderItemUpdateManyMutationInput, BookOrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type BookPurchaseUpsertWithWhereUniqueWithoutOrderInput = {
    where: BookPurchaseWhereUniqueInput
    update: XOR<BookPurchaseUpdateWithoutOrderInput, BookPurchaseUncheckedUpdateWithoutOrderInput>
    create: XOR<BookPurchaseCreateWithoutOrderInput, BookPurchaseUncheckedCreateWithoutOrderInput>
  }

  export type BookPurchaseUpdateWithWhereUniqueWithoutOrderInput = {
    where: BookPurchaseWhereUniqueInput
    data: XOR<BookPurchaseUpdateWithoutOrderInput, BookPurchaseUncheckedUpdateWithoutOrderInput>
  }

  export type BookPurchaseUpdateManyWithWhereWithoutOrderInput = {
    where: BookPurchaseScalarWhereInput
    data: XOR<BookPurchaseUpdateManyMutationInput, BookPurchaseUncheckedUpdateManyWithoutOrderInput>
  }

  export type BookOrderCreateWithoutItemsInput = {
    totalAmount: number
    discountAmount?: number
    finalAmount: number
    paymentId?: string | null
    orderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBookOrdersInput
    coupon?: BookCouponCreateNestedOneWithoutOrdersInput
    purchases?: BookPurchaseCreateNestedManyWithoutOrderInput
  }

  export type BookOrderUncheckedCreateWithoutItemsInput = {
    id?: number
    userId: number
    totalAmount: number
    discountAmount?: number
    finalAmount: number
    couponId?: number | null
    paymentId?: string | null
    orderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: BookPurchaseUncheckedCreateNestedManyWithoutOrderInput
  }

  export type BookOrderCreateOrConnectWithoutItemsInput = {
    where: BookOrderWhereUniqueInput
    create: XOR<BookOrderCreateWithoutItemsInput, BookOrderUncheckedCreateWithoutItemsInput>
  }

  export type BookCreateWithoutOrderItemsInput = {
    name: string
    author: string
    fileName: string
    filePath: string
    fileSize: string
    price: number
    description?: string | null
    coverImage?: string | null
    uploadDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: BookPurchaseCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    name: string
    author: string
    fileName: string
    filePath: string
    fileSize: string
    price: number
    description?: string | null
    coverImage?: string | null
    uploadDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchases?: BookPurchaseUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutOrderItemsInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutOrderItemsInput, BookUncheckedCreateWithoutOrderItemsInput>
  }

  export type BookOrderUpsertWithoutItemsInput = {
    update: XOR<BookOrderUpdateWithoutItemsInput, BookOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<BookOrderCreateWithoutItemsInput, BookOrderUncheckedCreateWithoutItemsInput>
    where?: BookOrderWhereInput
  }

  export type BookOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: BookOrderWhereInput
    data: XOR<BookOrderUpdateWithoutItemsInput, BookOrderUncheckedUpdateWithoutItemsInput>
  }

  export type BookOrderUpdateWithoutItemsInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalAmount?: FloatFieldUpdateOperationsInput | number
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookOrdersNestedInput
    coupon?: BookCouponUpdateOneWithoutOrdersNestedInput
    purchases?: BookPurchaseUpdateManyWithoutOrderNestedInput
  }

  export type BookOrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalAmount?: FloatFieldUpdateOperationsInput | number
    couponId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: BookPurchaseUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type BookUpsertWithoutOrderItemsInput = {
    update: XOR<BookUpdateWithoutOrderItemsInput, BookUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<BookCreateWithoutOrderItemsInput, BookUncheckedCreateWithoutOrderItemsInput>
    where?: BookWhereInput
  }

  export type BookUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: BookWhereInput
    data: XOR<BookUpdateWithoutOrderItemsInput, BookUncheckedUpdateWithoutOrderItemsInput>
  }

  export type BookUpdateWithoutOrderItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: BookPurchaseUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: BookPurchaseUncheckedUpdateManyWithoutBookNestedInput
  }

  export type UserCreateWithoutBookPurchasesInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookOrders?: BookOrderCreateNestedManyWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookPurchasesInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookOrders?: BookOrderUncheckedCreateNestedManyWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookPurchasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookPurchasesInput, UserUncheckedCreateWithoutBookPurchasesInput>
  }

  export type BookCreateWithoutPurchasesInput = {
    name: string
    author: string
    fileName: string
    filePath: string
    fileSize: string
    price: number
    description?: string | null
    coverImage?: string | null
    uploadDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: BookOrderItemCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateWithoutPurchasesInput = {
    id?: number
    name: string
    author: string
    fileName: string
    filePath: string
    fileSize: string
    price: number
    description?: string | null
    coverImage?: string | null
    uploadDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: BookOrderItemUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutPurchasesInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutPurchasesInput, BookUncheckedCreateWithoutPurchasesInput>
  }

  export type BookOrderCreateWithoutPurchasesInput = {
    totalAmount: number
    discountAmount?: number
    finalAmount: number
    paymentId?: string | null
    orderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBookOrdersInput
    coupon?: BookCouponCreateNestedOneWithoutOrdersInput
    items?: BookOrderItemCreateNestedManyWithoutOrderInput
  }

  export type BookOrderUncheckedCreateWithoutPurchasesInput = {
    id?: number
    userId: number
    totalAmount: number
    discountAmount?: number
    finalAmount: number
    couponId?: number | null
    paymentId?: string | null
    orderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: BookOrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type BookOrderCreateOrConnectWithoutPurchasesInput = {
    where: BookOrderWhereUniqueInput
    create: XOR<BookOrderCreateWithoutPurchasesInput, BookOrderUncheckedCreateWithoutPurchasesInput>
  }

  export type UserUpsertWithoutBookPurchasesInput = {
    update: XOR<UserUpdateWithoutBookPurchasesInput, UserUncheckedUpdateWithoutBookPurchasesInput>
    create: XOR<UserCreateWithoutBookPurchasesInput, UserUncheckedCreateWithoutBookPurchasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookPurchasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookPurchasesInput, UserUncheckedUpdateWithoutBookPurchasesInput>
  }

  export type UserUpdateWithoutBookPurchasesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookOrders?: BookOrderUpdateManyWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookPurchasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookOrders?: BookOrderUncheckedUpdateManyWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookUpsertWithoutPurchasesInput = {
    update: XOR<BookUpdateWithoutPurchasesInput, BookUncheckedUpdateWithoutPurchasesInput>
    create: XOR<BookCreateWithoutPurchasesInput, BookUncheckedCreateWithoutPurchasesInput>
    where?: BookWhereInput
  }

  export type BookUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: BookWhereInput
    data: XOR<BookUpdateWithoutPurchasesInput, BookUncheckedUpdateWithoutPurchasesInput>
  }

  export type BookUpdateWithoutPurchasesInput = {
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: BookOrderItemUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutPurchasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: BookOrderItemUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookOrderUpsertWithoutPurchasesInput = {
    update: XOR<BookOrderUpdateWithoutPurchasesInput, BookOrderUncheckedUpdateWithoutPurchasesInput>
    create: XOR<BookOrderCreateWithoutPurchasesInput, BookOrderUncheckedCreateWithoutPurchasesInput>
    where?: BookOrderWhereInput
  }

  export type BookOrderUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: BookOrderWhereInput
    data: XOR<BookOrderUpdateWithoutPurchasesInput, BookOrderUncheckedUpdateWithoutPurchasesInput>
  }

  export type BookOrderUpdateWithoutPurchasesInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalAmount?: FloatFieldUpdateOperationsInput | number
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookOrdersNestedInput
    coupon?: BookCouponUpdateOneWithoutOrdersNestedInput
    items?: BookOrderItemUpdateManyWithoutOrderNestedInput
  }

  export type BookOrderUncheckedUpdateWithoutPurchasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalAmount?: FloatFieldUpdateOperationsInput | number
    couponId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: BookOrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserCreateWithoutPaymentsInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookOrders?: BookOrderCreateNestedManyWithoutUserInput
    bookPurchases?: BookPurchaseCreateNestedManyWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookOrders?: BookOrderUncheckedCreateNestedManyWithoutUserInput
    bookPurchases?: BookPurchaseUncheckedCreateNestedManyWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookOrders?: BookOrderUpdateManyWithoutUserNestedInput
    bookPurchases?: BookPurchaseUpdateManyWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookOrders?: BookOrderUncheckedUpdateManyWithoutUserNestedInput
    bookPurchases?: BookPurchaseUncheckedUpdateManyWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FoundationStatCreateWithoutFoundationInput = {
    label: string
    value: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationStatUncheckedCreateWithoutFoundationInput = {
    id?: number
    label: string
    value: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationStatCreateOrConnectWithoutFoundationInput = {
    where: FoundationStatWhereUniqueInput
    create: XOR<FoundationStatCreateWithoutFoundationInput, FoundationStatUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationStatCreateManyFoundationInputEnvelope = {
    data: FoundationStatCreateManyFoundationInput | FoundationStatCreateManyFoundationInput[]
    skipDuplicates?: boolean
  }

  export type FoundationActivityCreateWithoutFoundationInput = {
    activityText: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationActivityUncheckedCreateWithoutFoundationInput = {
    id?: number
    activityText: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationActivityCreateOrConnectWithoutFoundationInput = {
    where: FoundationActivityWhereUniqueInput
    create: XOR<FoundationActivityCreateWithoutFoundationInput, FoundationActivityUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationActivityCreateManyFoundationInputEnvelope = {
    data: FoundationActivityCreateManyFoundationInput | FoundationActivityCreateManyFoundationInput[]
    skipDuplicates?: boolean
  }

  export type FoundationObjectiveCreateWithoutFoundationInput = {
    title: string
    description?: string | null
    objectiveType?: $Enums.ObjectiveType
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationObjectiveUncheckedCreateWithoutFoundationInput = {
    id?: number
    title: string
    description?: string | null
    objectiveType?: $Enums.ObjectiveType
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationObjectiveCreateOrConnectWithoutFoundationInput = {
    where: FoundationObjectiveWhereUniqueInput
    create: XOR<FoundationObjectiveCreateWithoutFoundationInput, FoundationObjectiveUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationObjectiveCreateManyFoundationInputEnvelope = {
    data: FoundationObjectiveCreateManyFoundationInput | FoundationObjectiveCreateManyFoundationInput[]
    skipDuplicates?: boolean
  }

  export type FoundationContactCreateWithoutFoundationInput = {
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationContactUncheckedCreateWithoutFoundationInput = {
    id?: number
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationContactCreateOrConnectWithoutFoundationInput = {
    where: FoundationContactWhereUniqueInput
    create: XOR<FoundationContactCreateWithoutFoundationInput, FoundationContactUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationMediaCreateWithoutFoundationInput = {
    fileName: string
    filePath: string
    fileType?: string | null
    fileSize?: number | null
    mediaType?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
  }

  export type FoundationMediaUncheckedCreateWithoutFoundationInput = {
    id?: number
    fileName: string
    filePath: string
    fileType?: string | null
    fileSize?: number | null
    mediaType?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
  }

  export type FoundationMediaCreateOrConnectWithoutFoundationInput = {
    where: FoundationMediaWhereUniqueInput
    create: XOR<FoundationMediaCreateWithoutFoundationInput, FoundationMediaUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationMediaCreateManyFoundationInputEnvelope = {
    data: FoundationMediaCreateManyFoundationInput | FoundationMediaCreateManyFoundationInput[]
    skipDuplicates?: boolean
  }

  export type FoundationStatUpsertWithWhereUniqueWithoutFoundationInput = {
    where: FoundationStatWhereUniqueInput
    update: XOR<FoundationStatUpdateWithoutFoundationInput, FoundationStatUncheckedUpdateWithoutFoundationInput>
    create: XOR<FoundationStatCreateWithoutFoundationInput, FoundationStatUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationStatUpdateWithWhereUniqueWithoutFoundationInput = {
    where: FoundationStatWhereUniqueInput
    data: XOR<FoundationStatUpdateWithoutFoundationInput, FoundationStatUncheckedUpdateWithoutFoundationInput>
  }

  export type FoundationStatUpdateManyWithWhereWithoutFoundationInput = {
    where: FoundationStatScalarWhereInput
    data: XOR<FoundationStatUpdateManyMutationInput, FoundationStatUncheckedUpdateManyWithoutFoundationInput>
  }

  export type FoundationStatScalarWhereInput = {
    AND?: FoundationStatScalarWhereInput | FoundationStatScalarWhereInput[]
    OR?: FoundationStatScalarWhereInput[]
    NOT?: FoundationStatScalarWhereInput | FoundationStatScalarWhereInput[]
    id?: IntFilter<"FoundationStat"> | number
    foundationId?: IntFilter<"FoundationStat"> | number
    label?: StringFilter<"FoundationStat"> | string
    value?: StringFilter<"FoundationStat"> | string
    displayOrder?: IntFilter<"FoundationStat"> | number
    createdAt?: DateTimeFilter<"FoundationStat"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationStat"> | Date | string
  }

  export type FoundationActivityUpsertWithWhereUniqueWithoutFoundationInput = {
    where: FoundationActivityWhereUniqueInput
    update: XOR<FoundationActivityUpdateWithoutFoundationInput, FoundationActivityUncheckedUpdateWithoutFoundationInput>
    create: XOR<FoundationActivityCreateWithoutFoundationInput, FoundationActivityUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationActivityUpdateWithWhereUniqueWithoutFoundationInput = {
    where: FoundationActivityWhereUniqueInput
    data: XOR<FoundationActivityUpdateWithoutFoundationInput, FoundationActivityUncheckedUpdateWithoutFoundationInput>
  }

  export type FoundationActivityUpdateManyWithWhereWithoutFoundationInput = {
    where: FoundationActivityScalarWhereInput
    data: XOR<FoundationActivityUpdateManyMutationInput, FoundationActivityUncheckedUpdateManyWithoutFoundationInput>
  }

  export type FoundationActivityScalarWhereInput = {
    AND?: FoundationActivityScalarWhereInput | FoundationActivityScalarWhereInput[]
    OR?: FoundationActivityScalarWhereInput[]
    NOT?: FoundationActivityScalarWhereInput | FoundationActivityScalarWhereInput[]
    id?: IntFilter<"FoundationActivity"> | number
    foundationId?: IntFilter<"FoundationActivity"> | number
    activityText?: StringFilter<"FoundationActivity"> | string
    displayOrder?: IntFilter<"FoundationActivity"> | number
    createdAt?: DateTimeFilter<"FoundationActivity"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationActivity"> | Date | string
  }

  export type FoundationObjectiveUpsertWithWhereUniqueWithoutFoundationInput = {
    where: FoundationObjectiveWhereUniqueInput
    update: XOR<FoundationObjectiveUpdateWithoutFoundationInput, FoundationObjectiveUncheckedUpdateWithoutFoundationInput>
    create: XOR<FoundationObjectiveCreateWithoutFoundationInput, FoundationObjectiveUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationObjectiveUpdateWithWhereUniqueWithoutFoundationInput = {
    where: FoundationObjectiveWhereUniqueInput
    data: XOR<FoundationObjectiveUpdateWithoutFoundationInput, FoundationObjectiveUncheckedUpdateWithoutFoundationInput>
  }

  export type FoundationObjectiveUpdateManyWithWhereWithoutFoundationInput = {
    where: FoundationObjectiveScalarWhereInput
    data: XOR<FoundationObjectiveUpdateManyMutationInput, FoundationObjectiveUncheckedUpdateManyWithoutFoundationInput>
  }

  export type FoundationObjectiveScalarWhereInput = {
    AND?: FoundationObjectiveScalarWhereInput | FoundationObjectiveScalarWhereInput[]
    OR?: FoundationObjectiveScalarWhereInput[]
    NOT?: FoundationObjectiveScalarWhereInput | FoundationObjectiveScalarWhereInput[]
    id?: IntFilter<"FoundationObjective"> | number
    foundationId?: IntFilter<"FoundationObjective"> | number
    title?: StringFilter<"FoundationObjective"> | string
    description?: StringNullableFilter<"FoundationObjective"> | string | null
    objectiveType?: EnumObjectiveTypeFilter<"FoundationObjective"> | $Enums.ObjectiveType
    displayOrder?: IntFilter<"FoundationObjective"> | number
    createdAt?: DateTimeFilter<"FoundationObjective"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationObjective"> | Date | string
  }

  export type FoundationContactUpsertWithoutFoundationInput = {
    update: XOR<FoundationContactUpdateWithoutFoundationInput, FoundationContactUncheckedUpdateWithoutFoundationInput>
    create: XOR<FoundationContactCreateWithoutFoundationInput, FoundationContactUncheckedCreateWithoutFoundationInput>
    where?: FoundationContactWhereInput
  }

  export type FoundationContactUpdateToOneWithWhereWithoutFoundationInput = {
    where?: FoundationContactWhereInput
    data: XOR<FoundationContactUpdateWithoutFoundationInput, FoundationContactUncheckedUpdateWithoutFoundationInput>
  }

  export type FoundationContactUpdateWithoutFoundationInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationContactUncheckedUpdateWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationMediaUpsertWithWhereUniqueWithoutFoundationInput = {
    where: FoundationMediaWhereUniqueInput
    update: XOR<FoundationMediaUpdateWithoutFoundationInput, FoundationMediaUncheckedUpdateWithoutFoundationInput>
    create: XOR<FoundationMediaCreateWithoutFoundationInput, FoundationMediaUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationMediaUpdateWithWhereUniqueWithoutFoundationInput = {
    where: FoundationMediaWhereUniqueInput
    data: XOR<FoundationMediaUpdateWithoutFoundationInput, FoundationMediaUncheckedUpdateWithoutFoundationInput>
  }

  export type FoundationMediaUpdateManyWithWhereWithoutFoundationInput = {
    where: FoundationMediaScalarWhereInput
    data: XOR<FoundationMediaUpdateManyMutationInput, FoundationMediaUncheckedUpdateManyWithoutFoundationInput>
  }

  export type FoundationMediaScalarWhereInput = {
    AND?: FoundationMediaScalarWhereInput | FoundationMediaScalarWhereInput[]
    OR?: FoundationMediaScalarWhereInput[]
    NOT?: FoundationMediaScalarWhereInput | FoundationMediaScalarWhereInput[]
    id?: IntFilter<"FoundationMedia"> | number
    foundationId?: IntNullableFilter<"FoundationMedia"> | number | null
    fileName?: StringFilter<"FoundationMedia"> | string
    filePath?: StringFilter<"FoundationMedia"> | string
    fileType?: StringNullableFilter<"FoundationMedia"> | string | null
    fileSize?: IntNullableFilter<"FoundationMedia"> | number | null
    mediaType?: EnumMediaTypeFilter<"FoundationMedia"> | $Enums.MediaType
    altText?: StringNullableFilter<"FoundationMedia"> | string | null
    createdAt?: DateTimeFilter<"FoundationMedia"> | Date | string
  }

  export type FoundationCreateWithoutStatsInput = {
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    activities?: FoundationActivityCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactCreateNestedOneWithoutFoundationInput
    media?: FoundationMediaCreateNestedManyWithoutFoundationInput
  }

  export type FoundationUncheckedCreateWithoutStatsInput = {
    id?: number
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    activities?: FoundationActivityUncheckedCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveUncheckedCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactUncheckedCreateNestedOneWithoutFoundationInput
    media?: FoundationMediaUncheckedCreateNestedManyWithoutFoundationInput
  }

  export type FoundationCreateOrConnectWithoutStatsInput = {
    where: FoundationWhereUniqueInput
    create: XOR<FoundationCreateWithoutStatsInput, FoundationUncheckedCreateWithoutStatsInput>
  }

  export type FoundationUpsertWithoutStatsInput = {
    update: XOR<FoundationUpdateWithoutStatsInput, FoundationUncheckedUpdateWithoutStatsInput>
    create: XOR<FoundationCreateWithoutStatsInput, FoundationUncheckedCreateWithoutStatsInput>
    where?: FoundationWhereInput
  }

  export type FoundationUpdateToOneWithWhereWithoutStatsInput = {
    where?: FoundationWhereInput
    data: XOR<FoundationUpdateWithoutStatsInput, FoundationUncheckedUpdateWithoutStatsInput>
  }

  export type FoundationUpdateWithoutStatsInput = {
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    activities?: FoundationActivityUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUpdateOneWithoutFoundationNestedInput
    media?: FoundationMediaUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationUncheckedUpdateWithoutStatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    activities?: FoundationActivityUncheckedUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUncheckedUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUncheckedUpdateOneWithoutFoundationNestedInput
    media?: FoundationMediaUncheckedUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationCreateWithoutActivitiesInput = {
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactCreateNestedOneWithoutFoundationInput
    media?: FoundationMediaCreateNestedManyWithoutFoundationInput
  }

  export type FoundationUncheckedCreateWithoutActivitiesInput = {
    id?: number
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatUncheckedCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveUncheckedCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactUncheckedCreateNestedOneWithoutFoundationInput
    media?: FoundationMediaUncheckedCreateNestedManyWithoutFoundationInput
  }

  export type FoundationCreateOrConnectWithoutActivitiesInput = {
    where: FoundationWhereUniqueInput
    create: XOR<FoundationCreateWithoutActivitiesInput, FoundationUncheckedCreateWithoutActivitiesInput>
  }

  export type FoundationUpsertWithoutActivitiesInput = {
    update: XOR<FoundationUpdateWithoutActivitiesInput, FoundationUncheckedUpdateWithoutActivitiesInput>
    create: XOR<FoundationCreateWithoutActivitiesInput, FoundationUncheckedCreateWithoutActivitiesInput>
    where?: FoundationWhereInput
  }

  export type FoundationUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: FoundationWhereInput
    data: XOR<FoundationUpdateWithoutActivitiesInput, FoundationUncheckedUpdateWithoutActivitiesInput>
  }

  export type FoundationUpdateWithoutActivitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUpdateOneWithoutFoundationNestedInput
    media?: FoundationMediaUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationUncheckedUpdateWithoutActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUncheckedUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUncheckedUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUncheckedUpdateOneWithoutFoundationNestedInput
    media?: FoundationMediaUncheckedUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationCreateWithoutObjectivesInput = {
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatCreateNestedManyWithoutFoundationInput
    activities?: FoundationActivityCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactCreateNestedOneWithoutFoundationInput
    media?: FoundationMediaCreateNestedManyWithoutFoundationInput
  }

  export type FoundationUncheckedCreateWithoutObjectivesInput = {
    id?: number
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatUncheckedCreateNestedManyWithoutFoundationInput
    activities?: FoundationActivityUncheckedCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactUncheckedCreateNestedOneWithoutFoundationInput
    media?: FoundationMediaUncheckedCreateNestedManyWithoutFoundationInput
  }

  export type FoundationCreateOrConnectWithoutObjectivesInput = {
    where: FoundationWhereUniqueInput
    create: XOR<FoundationCreateWithoutObjectivesInput, FoundationUncheckedCreateWithoutObjectivesInput>
  }

  export type FoundationUpsertWithoutObjectivesInput = {
    update: XOR<FoundationUpdateWithoutObjectivesInput, FoundationUncheckedUpdateWithoutObjectivesInput>
    create: XOR<FoundationCreateWithoutObjectivesInput, FoundationUncheckedCreateWithoutObjectivesInput>
    where?: FoundationWhereInput
  }

  export type FoundationUpdateToOneWithWhereWithoutObjectivesInput = {
    where?: FoundationWhereInput
    data: XOR<FoundationUpdateWithoutObjectivesInput, FoundationUncheckedUpdateWithoutObjectivesInput>
  }

  export type FoundationUpdateWithoutObjectivesInput = {
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUpdateManyWithoutFoundationNestedInput
    activities?: FoundationActivityUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUpdateOneWithoutFoundationNestedInput
    media?: FoundationMediaUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationUncheckedUpdateWithoutObjectivesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUncheckedUpdateManyWithoutFoundationNestedInput
    activities?: FoundationActivityUncheckedUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUncheckedUpdateOneWithoutFoundationNestedInput
    media?: FoundationMediaUncheckedUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationCreateWithoutContactInput = {
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatCreateNestedManyWithoutFoundationInput
    activities?: FoundationActivityCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveCreateNestedManyWithoutFoundationInput
    media?: FoundationMediaCreateNestedManyWithoutFoundationInput
  }

  export type FoundationUncheckedCreateWithoutContactInput = {
    id?: number
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatUncheckedCreateNestedManyWithoutFoundationInput
    activities?: FoundationActivityUncheckedCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveUncheckedCreateNestedManyWithoutFoundationInput
    media?: FoundationMediaUncheckedCreateNestedManyWithoutFoundationInput
  }

  export type FoundationCreateOrConnectWithoutContactInput = {
    where: FoundationWhereUniqueInput
    create: XOR<FoundationCreateWithoutContactInput, FoundationUncheckedCreateWithoutContactInput>
  }

  export type FoundationUpsertWithoutContactInput = {
    update: XOR<FoundationUpdateWithoutContactInput, FoundationUncheckedUpdateWithoutContactInput>
    create: XOR<FoundationCreateWithoutContactInput, FoundationUncheckedCreateWithoutContactInput>
    where?: FoundationWhereInput
  }

  export type FoundationUpdateToOneWithWhereWithoutContactInput = {
    where?: FoundationWhereInput
    data: XOR<FoundationUpdateWithoutContactInput, FoundationUncheckedUpdateWithoutContactInput>
  }

  export type FoundationUpdateWithoutContactInput = {
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUpdateManyWithoutFoundationNestedInput
    activities?: FoundationActivityUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUpdateManyWithoutFoundationNestedInput
    media?: FoundationMediaUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUncheckedUpdateManyWithoutFoundationNestedInput
    activities?: FoundationActivityUncheckedUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUncheckedUpdateManyWithoutFoundationNestedInput
    media?: FoundationMediaUncheckedUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationCreateWithoutMediaInput = {
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatCreateNestedManyWithoutFoundationInput
    activities?: FoundationActivityCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactCreateNestedOneWithoutFoundationInput
  }

  export type FoundationUncheckedCreateWithoutMediaInput = {
    id?: number
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatUncheckedCreateNestedManyWithoutFoundationInput
    activities?: FoundationActivityUncheckedCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveUncheckedCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactUncheckedCreateNestedOneWithoutFoundationInput
  }

  export type FoundationCreateOrConnectWithoutMediaInput = {
    where: FoundationWhereUniqueInput
    create: XOR<FoundationCreateWithoutMediaInput, FoundationUncheckedCreateWithoutMediaInput>
  }

  export type FoundationUpsertWithoutMediaInput = {
    update: XOR<FoundationUpdateWithoutMediaInput, FoundationUncheckedUpdateWithoutMediaInput>
    create: XOR<FoundationCreateWithoutMediaInput, FoundationUncheckedCreateWithoutMediaInput>
    where?: FoundationWhereInput
  }

  export type FoundationUpdateToOneWithWhereWithoutMediaInput = {
    where?: FoundationWhereInput
    data: XOR<FoundationUpdateWithoutMediaInput, FoundationUncheckedUpdateWithoutMediaInput>
  }

  export type FoundationUpdateWithoutMediaInput = {
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUpdateManyWithoutFoundationNestedInput
    activities?: FoundationActivityUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUpdateOneWithoutFoundationNestedInput
  }

  export type FoundationUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUncheckedUpdateManyWithoutFoundationNestedInput
    activities?: FoundationActivityUncheckedUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUncheckedUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUncheckedUpdateOneWithoutFoundationNestedInput
  }

  export type BookOrderCreateManyUserInput = {
    id?: number
    totalAmount: number
    discountAmount?: number
    finalAmount: number
    couponId?: number | null
    paymentId?: string | null
    orderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookPurchaseCreateManyUserInput = {
    id?: number
    bookId: number
    orderId: number
    purchaseDate?: Date | string
    accessGranted?: boolean
  }

  export type DonationCreateManyUserInput = {
    id?: number
    amount: number
    status?: string
    paymentMethod?: string | null
    transactionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: number
    referenceId: string
    provider: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookOrderUpdateWithoutUserInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalAmount?: FloatFieldUpdateOperationsInput | number
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon?: BookCouponUpdateOneWithoutOrdersNestedInput
    items?: BookOrderItemUpdateManyWithoutOrderNestedInput
    purchases?: BookPurchaseUpdateManyWithoutOrderNestedInput
  }

  export type BookOrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalAmount?: FloatFieldUpdateOperationsInput | number
    couponId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: BookOrderItemUncheckedUpdateManyWithoutOrderNestedInput
    purchases?: BookPurchaseUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type BookOrderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalAmount?: FloatFieldUpdateOperationsInput | number
    couponId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookPurchaseUpdateWithoutUserInput = {
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    book?: BookUpdateOneRequiredWithoutPurchasesNestedInput
    order?: BookOrderUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type BookPurchaseUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookPurchaseUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DonationUpdateWithoutUserInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    referenceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookPurchaseCreateManyBookInput = {
    id?: number
    userId: number
    orderId: number
    purchaseDate?: Date | string
    accessGranted?: boolean
  }

  export type BookOrderItemCreateManyBookInput = {
    id?: number
    orderId: number
    price: number
  }

  export type BookPurchaseUpdateWithoutBookInput = {
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutBookPurchasesNestedInput
    order?: BookOrderUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type BookPurchaseUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookPurchaseUncheckedUpdateManyWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookOrderItemUpdateWithoutBookInput = {
    price?: FloatFieldUpdateOperationsInput | number
    order?: BookOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type BookOrderItemUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type BookOrderItemUncheckedUpdateManyWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type BookOrderCreateManyCouponInput = {
    id?: number
    userId: number
    totalAmount: number
    discountAmount?: number
    finalAmount: number
    paymentId?: string | null
    orderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookOrderUpdateWithoutCouponInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalAmount?: FloatFieldUpdateOperationsInput | number
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookOrdersNestedInput
    items?: BookOrderItemUpdateManyWithoutOrderNestedInput
    purchases?: BookPurchaseUpdateManyWithoutOrderNestedInput
  }

  export type BookOrderUncheckedUpdateWithoutCouponInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalAmount?: FloatFieldUpdateOperationsInput | number
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: BookOrderItemUncheckedUpdateManyWithoutOrderNestedInput
    purchases?: BookPurchaseUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type BookOrderUncheckedUpdateManyWithoutCouponInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    finalAmount?: FloatFieldUpdateOperationsInput | number
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookOrderItemCreateManyOrderInput = {
    id?: number
    bookId: number
    price: number
  }

  export type BookPurchaseCreateManyOrderInput = {
    id?: number
    userId: number
    bookId: number
    purchaseDate?: Date | string
    accessGranted?: boolean
  }

  export type BookOrderItemUpdateWithoutOrderInput = {
    price?: FloatFieldUpdateOperationsInput | number
    book?: BookUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type BookOrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type BookOrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type BookPurchaseUpdateWithoutOrderInput = {
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutBookPurchasesNestedInput
    book?: BookUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type BookPurchaseUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookPurchaseUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FoundationStatCreateManyFoundationInput = {
    id?: number
    label: string
    value: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationActivityCreateManyFoundationInput = {
    id?: number
    activityText: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationObjectiveCreateManyFoundationInput = {
    id?: number
    title: string
    description?: string | null
    objectiveType?: $Enums.ObjectiveType
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationMediaCreateManyFoundationInput = {
    id?: number
    fileName: string
    filePath: string
    fileType?: string | null
    fileSize?: number | null
    mediaType?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
  }

  export type FoundationStatUpdateWithoutFoundationInput = {
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationStatUncheckedUpdateWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationStatUncheckedUpdateManyWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationActivityUpdateWithoutFoundationInput = {
    activityText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationActivityUncheckedUpdateWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    activityText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationActivityUncheckedUpdateManyWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    activityText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationObjectiveUpdateWithoutFoundationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveType?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationObjectiveUncheckedUpdateWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveType?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationObjectiveUncheckedUpdateManyWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveType?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationMediaUpdateWithoutFoundationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationMediaUncheckedUpdateWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationMediaUncheckedUpdateManyWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}
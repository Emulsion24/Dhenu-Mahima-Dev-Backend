
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Donation
 * 
 */
export type Donation = $Result.DefaultSelection<Prisma.$DonationPayload>
/**
 * Model PdfBook
 * 
 */
export type PdfBook = $Result.DefaultSelection<Prisma.$PdfBookPayload>
/**
 * Model PdfOrder
 * 
 */
export type PdfOrder = $Result.DefaultSelection<Prisma.$PdfOrderPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model News
 * 
 */
export type News = $Result.DefaultSelection<Prisma.$NewsPayload>
/**
 * Model GopalPariwar
 * 
 */
export type GopalPariwar = $Result.DefaultSelection<Prisma.$GopalPariwarPayload>
/**
 * Model Gaushala
 * 
 */
export type Gaushala = $Result.DefaultSelection<Prisma.$GaushalaPayload>
/**
 * Model Card
 * 
 */
export type Card = $Result.DefaultSelection<Prisma.$CardPayload>
/**
 * Model DtaSanssthan
 * 
 */
export type DtaSanssthan = $Result.DefaultSelection<Prisma.$DtaSanssthanPayload>
/**
 * Model PrivacyPolicy
 * 
 */
export type PrivacyPolicy = $Result.DefaultSelection<Prisma.$PrivacyPolicyPayload>
/**
 * Model TermsConditions
 * 
 */
export type TermsConditions = $Result.DefaultSelection<Prisma.$TermsConditionsPayload>
/**
 * Model Banner
 * 
 */
export type Banner = $Result.DefaultSelection<Prisma.$BannerPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Foundation
 * 
 */
export type Foundation = $Result.DefaultSelection<Prisma.$FoundationPayload>
/**
 * Model FoundationStat
 * 
 */
export type FoundationStat = $Result.DefaultSelection<Prisma.$FoundationStatPayload>
/**
 * Model FoundationActivity
 * 
 */
export type FoundationActivity = $Result.DefaultSelection<Prisma.$FoundationActivityPayload>
/**
 * Model FoundationObjective
 * 
 */
export type FoundationObjective = $Result.DefaultSelection<Prisma.$FoundationObjectivePayload>
/**
 * Model FoundationContact
 * 
 */
export type FoundationContact = $Result.DefaultSelection<Prisma.$FoundationContactPayload>
/**
 * Model FoundationMedia
 * 
 */
export type FoundationMedia = $Result.DefaultSelection<Prisma.$FoundationMediaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ObjectiveType: {
  main: 'main',
  supportive: 'supportive'
};

export type ObjectiveType = (typeof ObjectiveType)[keyof typeof ObjectiveType]


export const UserRole: {
  super_admin: 'super_admin',
  admin: 'admin',
  editor: 'editor'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const MediaType: {
  logo: 'logo',
  banner: 'banner',
  gallery: 'gallery',
  document: 'document'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]

}

export type ObjectiveType = $Enums.ObjectiveType

export const ObjectiveType: typeof $Enums.ObjectiveType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.donation`: Exposes CRUD operations for the **Donation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Donations
    * const donations = await prisma.donation.findMany()
    * ```
    */
  get donation(): Prisma.DonationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pdfBook`: Exposes CRUD operations for the **PdfBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PdfBooks
    * const pdfBooks = await prisma.pdfBook.findMany()
    * ```
    */
  get pdfBook(): Prisma.PdfBookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pdfOrder`: Exposes CRUD operations for the **PdfOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PdfOrders
    * const pdfOrders = await prisma.pdfOrder.findMany()
    * ```
    */
  get pdfOrder(): Prisma.PdfOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.news`: Exposes CRUD operations for the **News** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News
    * const news = await prisma.news.findMany()
    * ```
    */
  get news(): Prisma.NewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gopalPariwar`: Exposes CRUD operations for the **GopalPariwar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GopalPariwars
    * const gopalPariwars = await prisma.gopalPariwar.findMany()
    * ```
    */
  get gopalPariwar(): Prisma.GopalPariwarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gaushala`: Exposes CRUD operations for the **Gaushala** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gaushalas
    * const gaushalas = await prisma.gaushala.findMany()
    * ```
    */
  get gaushala(): Prisma.GaushalaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.card`: Exposes CRUD operations for the **Card** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cards
    * const cards = await prisma.card.findMany()
    * ```
    */
  get card(): Prisma.CardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dtaSanssthan`: Exposes CRUD operations for the **DtaSanssthan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DtaSanssthans
    * const dtaSanssthans = await prisma.dtaSanssthan.findMany()
    * ```
    */
  get dtaSanssthan(): Prisma.DtaSanssthanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privacyPolicy`: Exposes CRUD operations for the **PrivacyPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrivacyPolicies
    * const privacyPolicies = await prisma.privacyPolicy.findMany()
    * ```
    */
  get privacyPolicy(): Prisma.PrivacyPolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.termsConditions`: Exposes CRUD operations for the **TermsConditions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TermsConditions
    * const termsConditions = await prisma.termsConditions.findMany()
    * ```
    */
  get termsConditions(): Prisma.TermsConditionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.banner`: Exposes CRUD operations for the **Banner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banner.findMany()
    * ```
    */
  get banner(): Prisma.BannerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foundation`: Exposes CRUD operations for the **Foundation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Foundations
    * const foundations = await prisma.foundation.findMany()
    * ```
    */
  get foundation(): Prisma.FoundationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foundationStat`: Exposes CRUD operations for the **FoundationStat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoundationStats
    * const foundationStats = await prisma.foundationStat.findMany()
    * ```
    */
  get foundationStat(): Prisma.FoundationStatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foundationActivity`: Exposes CRUD operations for the **FoundationActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoundationActivities
    * const foundationActivities = await prisma.foundationActivity.findMany()
    * ```
    */
  get foundationActivity(): Prisma.FoundationActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foundationObjective`: Exposes CRUD operations for the **FoundationObjective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoundationObjectives
    * const foundationObjectives = await prisma.foundationObjective.findMany()
    * ```
    */
  get foundationObjective(): Prisma.FoundationObjectiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foundationContact`: Exposes CRUD operations for the **FoundationContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoundationContacts
    * const foundationContacts = await prisma.foundationContact.findMany()
    * ```
    */
  get foundationContact(): Prisma.FoundationContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foundationMedia`: Exposes CRUD operations for the **FoundationMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoundationMedias
    * const foundationMedias = await prisma.foundationMedia.findMany()
    * ```
    */
  get foundationMedia(): Prisma.FoundationMediaDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    Donation: 'Donation',
    PdfBook: 'PdfBook',
    PdfOrder: 'PdfOrder',
    Payment: 'Payment',
    News: 'News',
    GopalPariwar: 'GopalPariwar',
    Gaushala: 'Gaushala',
    Card: 'Card',
    DtaSanssthan: 'DtaSanssthan',
    PrivacyPolicy: 'PrivacyPolicy',
    TermsConditions: 'TermsConditions',
    Banner: 'Banner',
    Message: 'Message',
    Foundation: 'Foundation',
    FoundationStat: 'FoundationStat',
    FoundationActivity: 'FoundationActivity',
    FoundationObjective: 'FoundationObjective',
    FoundationContact: 'FoundationContact',
    FoundationMedia: 'FoundationMedia'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "donation" | "pdfBook" | "pdfOrder" | "payment" | "news" | "gopalPariwar" | "gaushala" | "card" | "dtaSanssthan" | "privacyPolicy" | "termsConditions" | "banner" | "message" | "foundation" | "foundationStat" | "foundationActivity" | "foundationObjective" | "foundationContact" | "foundationMedia"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Donation: {
        payload: Prisma.$DonationPayload<ExtArgs>
        fields: Prisma.DonationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DonationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DonationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          findFirst: {
            args: Prisma.DonationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DonationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          findMany: {
            args: Prisma.DonationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>[]
          }
          create: {
            args: Prisma.DonationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          createMany: {
            args: Prisma.DonationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DonationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          update: {
            args: Prisma.DonationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          deleteMany: {
            args: Prisma.DonationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DonationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DonationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          aggregate: {
            args: Prisma.DonationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDonation>
          }
          groupBy: {
            args: Prisma.DonationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DonationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DonationCountArgs<ExtArgs>
            result: $Utils.Optional<DonationCountAggregateOutputType> | number
          }
        }
      }
      PdfBook: {
        payload: Prisma.$PdfBookPayload<ExtArgs>
        fields: Prisma.PdfBookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PdfBookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfBookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PdfBookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfBookPayload>
          }
          findFirst: {
            args: Prisma.PdfBookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfBookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PdfBookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfBookPayload>
          }
          findMany: {
            args: Prisma.PdfBookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfBookPayload>[]
          }
          create: {
            args: Prisma.PdfBookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfBookPayload>
          }
          createMany: {
            args: Prisma.PdfBookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PdfBookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfBookPayload>
          }
          update: {
            args: Prisma.PdfBookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfBookPayload>
          }
          deleteMany: {
            args: Prisma.PdfBookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PdfBookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PdfBookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfBookPayload>
          }
          aggregate: {
            args: Prisma.PdfBookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePdfBook>
          }
          groupBy: {
            args: Prisma.PdfBookGroupByArgs<ExtArgs>
            result: $Utils.Optional<PdfBookGroupByOutputType>[]
          }
          count: {
            args: Prisma.PdfBookCountArgs<ExtArgs>
            result: $Utils.Optional<PdfBookCountAggregateOutputType> | number
          }
        }
      }
      PdfOrder: {
        payload: Prisma.$PdfOrderPayload<ExtArgs>
        fields: Prisma.PdfOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PdfOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PdfOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfOrderPayload>
          }
          findFirst: {
            args: Prisma.PdfOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PdfOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfOrderPayload>
          }
          findMany: {
            args: Prisma.PdfOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfOrderPayload>[]
          }
          create: {
            args: Prisma.PdfOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfOrderPayload>
          }
          createMany: {
            args: Prisma.PdfOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PdfOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfOrderPayload>
          }
          update: {
            args: Prisma.PdfOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfOrderPayload>
          }
          deleteMany: {
            args: Prisma.PdfOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PdfOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PdfOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfOrderPayload>
          }
          aggregate: {
            args: Prisma.PdfOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePdfOrder>
          }
          groupBy: {
            args: Prisma.PdfOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PdfOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PdfOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PdfOrderCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      News: {
        payload: Prisma.$NewsPayload<ExtArgs>
        fields: Prisma.NewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findFirst: {
            args: Prisma.NewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findMany: {
            args: Prisma.NewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          create: {
            args: Prisma.NewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          createMany: {
            args: Prisma.NewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          update: {
            args: Prisma.NewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          deleteMany: {
            args: Prisma.NewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          aggregate: {
            args: Prisma.NewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNews>
          }
          groupBy: {
            args: Prisma.NewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsCountArgs<ExtArgs>
            result: $Utils.Optional<NewsCountAggregateOutputType> | number
          }
        }
      }
      GopalPariwar: {
        payload: Prisma.$GopalPariwarPayload<ExtArgs>
        fields: Prisma.GopalPariwarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GopalPariwarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GopalPariwarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload>
          }
          findFirst: {
            args: Prisma.GopalPariwarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GopalPariwarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload>
          }
          findMany: {
            args: Prisma.GopalPariwarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload>[]
          }
          create: {
            args: Prisma.GopalPariwarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload>
          }
          createMany: {
            args: Prisma.GopalPariwarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GopalPariwarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload>
          }
          update: {
            args: Prisma.GopalPariwarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload>
          }
          deleteMany: {
            args: Prisma.GopalPariwarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GopalPariwarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GopalPariwarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GopalPariwarPayload>
          }
          aggregate: {
            args: Prisma.GopalPariwarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGopalPariwar>
          }
          groupBy: {
            args: Prisma.GopalPariwarGroupByArgs<ExtArgs>
            result: $Utils.Optional<GopalPariwarGroupByOutputType>[]
          }
          count: {
            args: Prisma.GopalPariwarCountArgs<ExtArgs>
            result: $Utils.Optional<GopalPariwarCountAggregateOutputType> | number
          }
        }
      }
      Gaushala: {
        payload: Prisma.$GaushalaPayload<ExtArgs>
        fields: Prisma.GaushalaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GaushalaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GaushalaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload>
          }
          findFirst: {
            args: Prisma.GaushalaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GaushalaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload>
          }
          findMany: {
            args: Prisma.GaushalaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload>[]
          }
          create: {
            args: Prisma.GaushalaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload>
          }
          createMany: {
            args: Prisma.GaushalaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GaushalaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload>
          }
          update: {
            args: Prisma.GaushalaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload>
          }
          deleteMany: {
            args: Prisma.GaushalaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GaushalaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GaushalaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GaushalaPayload>
          }
          aggregate: {
            args: Prisma.GaushalaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGaushala>
          }
          groupBy: {
            args: Prisma.GaushalaGroupByArgs<ExtArgs>
            result: $Utils.Optional<GaushalaGroupByOutputType>[]
          }
          count: {
            args: Prisma.GaushalaCountArgs<ExtArgs>
            result: $Utils.Optional<GaushalaCountAggregateOutputType> | number
          }
        }
      }
      Card: {
        payload: Prisma.$CardPayload<ExtArgs>
        fields: Prisma.CardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          findFirst: {
            args: Prisma.CardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          findMany: {
            args: Prisma.CardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>[]
          }
          create: {
            args: Prisma.CardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          createMany: {
            args: Prisma.CardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          update: {
            args: Prisma.CardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          deleteMany: {
            args: Prisma.CardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          aggregate: {
            args: Prisma.CardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCard>
          }
          groupBy: {
            args: Prisma.CardGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardCountArgs<ExtArgs>
            result: $Utils.Optional<CardCountAggregateOutputType> | number
          }
        }
      }
      DtaSanssthan: {
        payload: Prisma.$DtaSanssthanPayload<ExtArgs>
        fields: Prisma.DtaSanssthanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DtaSanssthanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DtaSanssthanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload>
          }
          findFirst: {
            args: Prisma.DtaSanssthanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DtaSanssthanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload>
          }
          findMany: {
            args: Prisma.DtaSanssthanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload>[]
          }
          create: {
            args: Prisma.DtaSanssthanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload>
          }
          createMany: {
            args: Prisma.DtaSanssthanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DtaSanssthanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload>
          }
          update: {
            args: Prisma.DtaSanssthanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload>
          }
          deleteMany: {
            args: Prisma.DtaSanssthanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DtaSanssthanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DtaSanssthanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DtaSanssthanPayload>
          }
          aggregate: {
            args: Prisma.DtaSanssthanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDtaSanssthan>
          }
          groupBy: {
            args: Prisma.DtaSanssthanGroupByArgs<ExtArgs>
            result: $Utils.Optional<DtaSanssthanGroupByOutputType>[]
          }
          count: {
            args: Prisma.DtaSanssthanCountArgs<ExtArgs>
            result: $Utils.Optional<DtaSanssthanCountAggregateOutputType> | number
          }
        }
      }
      PrivacyPolicy: {
        payload: Prisma.$PrivacyPolicyPayload<ExtArgs>
        fields: Prisma.PrivacyPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrivacyPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrivacyPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          findFirst: {
            args: Prisma.PrivacyPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrivacyPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          findMany: {
            args: Prisma.PrivacyPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>[]
          }
          create: {
            args: Prisma.PrivacyPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          createMany: {
            args: Prisma.PrivacyPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PrivacyPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          update: {
            args: Prisma.PrivacyPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          deleteMany: {
            args: Prisma.PrivacyPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrivacyPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrivacyPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          aggregate: {
            args: Prisma.PrivacyPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivacyPolicy>
          }
          groupBy: {
            args: Prisma.PrivacyPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivacyPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrivacyPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PrivacyPolicyCountAggregateOutputType> | number
          }
        }
      }
      TermsConditions: {
        payload: Prisma.$TermsConditionsPayload<ExtArgs>
        fields: Prisma.TermsConditionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TermsConditionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TermsConditionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload>
          }
          findFirst: {
            args: Prisma.TermsConditionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TermsConditionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload>
          }
          findMany: {
            args: Prisma.TermsConditionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload>[]
          }
          create: {
            args: Prisma.TermsConditionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload>
          }
          createMany: {
            args: Prisma.TermsConditionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TermsConditionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload>
          }
          update: {
            args: Prisma.TermsConditionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload>
          }
          deleteMany: {
            args: Prisma.TermsConditionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TermsConditionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TermsConditionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsConditionsPayload>
          }
          aggregate: {
            args: Prisma.TermsConditionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTermsConditions>
          }
          groupBy: {
            args: Prisma.TermsConditionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TermsConditionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TermsConditionsCountArgs<ExtArgs>
            result: $Utils.Optional<TermsConditionsCountAggregateOutputType> | number
          }
        }
      }
      Banner: {
        payload: Prisma.$BannerPayload<ExtArgs>
        fields: Prisma.BannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findFirst: {
            args: Prisma.BannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findMany: {
            args: Prisma.BannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          create: {
            args: Prisma.BannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          createMany: {
            args: Prisma.BannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          update: {
            args: Prisma.BannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          deleteMany: {
            args: Prisma.BannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          aggregate: {
            args: Prisma.BannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanner>
          }
          groupBy: {
            args: Prisma.BannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerCountArgs<ExtArgs>
            result: $Utils.Optional<BannerCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Foundation: {
        payload: Prisma.$FoundationPayload<ExtArgs>
        fields: Prisma.FoundationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoundationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoundationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload>
          }
          findFirst: {
            args: Prisma.FoundationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoundationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload>
          }
          findMany: {
            args: Prisma.FoundationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload>[]
          }
          create: {
            args: Prisma.FoundationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload>
          }
          createMany: {
            args: Prisma.FoundationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FoundationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload>
          }
          update: {
            args: Prisma.FoundationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload>
          }
          deleteMany: {
            args: Prisma.FoundationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoundationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoundationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationPayload>
          }
          aggregate: {
            args: Prisma.FoundationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoundation>
          }
          groupBy: {
            args: Prisma.FoundationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoundationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoundationCountArgs<ExtArgs>
            result: $Utils.Optional<FoundationCountAggregateOutputType> | number
          }
        }
      }
      FoundationStat: {
        payload: Prisma.$FoundationStatPayload<ExtArgs>
        fields: Prisma.FoundationStatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoundationStatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoundationStatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload>
          }
          findFirst: {
            args: Prisma.FoundationStatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoundationStatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload>
          }
          findMany: {
            args: Prisma.FoundationStatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload>[]
          }
          create: {
            args: Prisma.FoundationStatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload>
          }
          createMany: {
            args: Prisma.FoundationStatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FoundationStatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload>
          }
          update: {
            args: Prisma.FoundationStatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload>
          }
          deleteMany: {
            args: Prisma.FoundationStatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoundationStatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoundationStatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationStatPayload>
          }
          aggregate: {
            args: Prisma.FoundationStatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoundationStat>
          }
          groupBy: {
            args: Prisma.FoundationStatGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoundationStatGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoundationStatCountArgs<ExtArgs>
            result: $Utils.Optional<FoundationStatCountAggregateOutputType> | number
          }
        }
      }
      FoundationActivity: {
        payload: Prisma.$FoundationActivityPayload<ExtArgs>
        fields: Prisma.FoundationActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoundationActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoundationActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload>
          }
          findFirst: {
            args: Prisma.FoundationActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoundationActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload>
          }
          findMany: {
            args: Prisma.FoundationActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload>[]
          }
          create: {
            args: Prisma.FoundationActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload>
          }
          createMany: {
            args: Prisma.FoundationActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FoundationActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload>
          }
          update: {
            args: Prisma.FoundationActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload>
          }
          deleteMany: {
            args: Prisma.FoundationActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoundationActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoundationActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationActivityPayload>
          }
          aggregate: {
            args: Prisma.FoundationActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoundationActivity>
          }
          groupBy: {
            args: Prisma.FoundationActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoundationActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoundationActivityCountArgs<ExtArgs>
            result: $Utils.Optional<FoundationActivityCountAggregateOutputType> | number
          }
        }
      }
      FoundationObjective: {
        payload: Prisma.$FoundationObjectivePayload<ExtArgs>
        fields: Prisma.FoundationObjectiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoundationObjectiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoundationObjectiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload>
          }
          findFirst: {
            args: Prisma.FoundationObjectiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoundationObjectiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload>
          }
          findMany: {
            args: Prisma.FoundationObjectiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload>[]
          }
          create: {
            args: Prisma.FoundationObjectiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload>
          }
          createMany: {
            args: Prisma.FoundationObjectiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FoundationObjectiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload>
          }
          update: {
            args: Prisma.FoundationObjectiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload>
          }
          deleteMany: {
            args: Prisma.FoundationObjectiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoundationObjectiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoundationObjectiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationObjectivePayload>
          }
          aggregate: {
            args: Prisma.FoundationObjectiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoundationObjective>
          }
          groupBy: {
            args: Prisma.FoundationObjectiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoundationObjectiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoundationObjectiveCountArgs<ExtArgs>
            result: $Utils.Optional<FoundationObjectiveCountAggregateOutputType> | number
          }
        }
      }
      FoundationContact: {
        payload: Prisma.$FoundationContactPayload<ExtArgs>
        fields: Prisma.FoundationContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoundationContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoundationContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload>
          }
          findFirst: {
            args: Prisma.FoundationContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoundationContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload>
          }
          findMany: {
            args: Prisma.FoundationContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload>[]
          }
          create: {
            args: Prisma.FoundationContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload>
          }
          createMany: {
            args: Prisma.FoundationContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FoundationContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload>
          }
          update: {
            args: Prisma.FoundationContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload>
          }
          deleteMany: {
            args: Prisma.FoundationContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoundationContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoundationContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationContactPayload>
          }
          aggregate: {
            args: Prisma.FoundationContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoundationContact>
          }
          groupBy: {
            args: Prisma.FoundationContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoundationContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoundationContactCountArgs<ExtArgs>
            result: $Utils.Optional<FoundationContactCountAggregateOutputType> | number
          }
        }
      }
      FoundationMedia: {
        payload: Prisma.$FoundationMediaPayload<ExtArgs>
        fields: Prisma.FoundationMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoundationMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoundationMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload>
          }
          findFirst: {
            args: Prisma.FoundationMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoundationMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload>
          }
          findMany: {
            args: Prisma.FoundationMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload>[]
          }
          create: {
            args: Prisma.FoundationMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload>
          }
          createMany: {
            args: Prisma.FoundationMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FoundationMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload>
          }
          update: {
            args: Prisma.FoundationMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload>
          }
          deleteMany: {
            args: Prisma.FoundationMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoundationMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoundationMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoundationMediaPayload>
          }
          aggregate: {
            args: Prisma.FoundationMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoundationMedia>
          }
          groupBy: {
            args: Prisma.FoundationMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoundationMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoundationMediaCountArgs<ExtArgs>
            result: $Utils.Optional<FoundationMediaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    donation?: DonationOmit
    pdfBook?: PdfBookOmit
    pdfOrder?: PdfOrderOmit
    payment?: PaymentOmit
    news?: NewsOmit
    gopalPariwar?: GopalPariwarOmit
    gaushala?: GaushalaOmit
    card?: CardOmit
    dtaSanssthan?: DtaSanssthanOmit
    privacyPolicy?: PrivacyPolicyOmit
    termsConditions?: TermsConditionsOmit
    banner?: BannerOmit
    message?: MessageOmit
    foundation?: FoundationOmit
    foundationStat?: FoundationStatOmit
    foundationActivity?: FoundationActivityOmit
    foundationObjective?: FoundationObjectiveOmit
    foundationContact?: FoundationContactOmit
    foundationMedia?: FoundationMediaOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    donations: number
    pdfOrders: number
    accounts: number
    sessions: number
    payments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    donations?: boolean | UserCountOutputTypeCountDonationsArgs
    pdfOrders?: boolean | UserCountOutputTypeCountPdfOrdersArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDonationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPdfOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PdfOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type PdfBookCountOutputType
   */

  export type PdfBookCountOutputType = {
    orders: number
  }

  export type PdfBookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | PdfBookCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * PdfBookCountOutputType without action
   */
  export type PdfBookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfBookCountOutputType
     */
    select?: PdfBookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PdfBookCountOutputType without action
   */
  export type PdfBookCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PdfOrderWhereInput
  }


  /**
   * Count Type FoundationCountOutputType
   */

  export type FoundationCountOutputType = {
    stats: number
    activities: number
    objectives: number
    media: number
  }

  export type FoundationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stats?: boolean | FoundationCountOutputTypeCountStatsArgs
    activities?: boolean | FoundationCountOutputTypeCountActivitiesArgs
    objectives?: boolean | FoundationCountOutputTypeCountObjectivesArgs
    media?: boolean | FoundationCountOutputTypeCountMediaArgs
  }

  // Custom InputTypes
  /**
   * FoundationCountOutputType without action
   */
  export type FoundationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationCountOutputType
     */
    select?: FoundationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FoundationCountOutputType without action
   */
  export type FoundationCountOutputTypeCountStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationStatWhereInput
  }

  /**
   * FoundationCountOutputType without action
   */
  export type FoundationCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationActivityWhereInput
  }

  /**
   * FoundationCountOutputType without action
   */
  export type FoundationCountOutputTypeCountObjectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationObjectiveWhereInput
  }

  /**
   * FoundationCountOutputType without action
   */
  export type FoundationCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationMediaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    image: string | null
    address: string | null
    phone: string | null
    otpCode: string | null
    otpExpires: Date | null
    resetToken: string | null
    resetTokenExpires: Date | null
    isVerified: boolean | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    image: string | null
    address: string | null
    phone: string | null
    otpCode: string | null
    otpExpires: Date | null
    resetToken: string | null
    resetTokenExpires: Date | null
    isVerified: boolean | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    image: number
    address: number
    phone: number
    otpCode: number
    otpExpires: number
    resetToken: number
    resetTokenExpires: number
    isVerified: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    image?: true
    address?: true
    phone?: true
    otpCode?: true
    otpExpires?: true
    resetToken?: true
    resetTokenExpires?: true
    isVerified?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    image?: true
    address?: true
    phone?: true
    otpCode?: true
    otpExpires?: true
    resetToken?: true
    resetTokenExpires?: true
    isVerified?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    image?: true
    address?: true
    phone?: true
    otpCode?: true
    otpExpires?: true
    resetToken?: true
    resetTokenExpires?: true
    isVerified?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string | null
    image: string | null
    address: string | null
    phone: string | null
    otpCode: string | null
    otpExpires: Date | null
    resetToken: string | null
    resetTokenExpires: Date | null
    isVerified: boolean
    role: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    image?: boolean
    address?: boolean
    phone?: boolean
    otpCode?: boolean
    otpExpires?: boolean
    resetToken?: boolean
    resetTokenExpires?: boolean
    isVerified?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    donations?: boolean | User$donationsArgs<ExtArgs>
    pdfOrders?: boolean | User$pdfOrdersArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    image?: boolean
    address?: boolean
    phone?: boolean
    otpCode?: boolean
    otpExpires?: boolean
    resetToken?: boolean
    resetTokenExpires?: boolean
    isVerified?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "image" | "address" | "phone" | "otpCode" | "otpExpires" | "resetToken" | "resetTokenExpires" | "isVerified" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    donations?: boolean | User$donationsArgs<ExtArgs>
    pdfOrders?: boolean | User$pdfOrdersArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      donations: Prisma.$DonationPayload<ExtArgs>[]
      pdfOrders: Prisma.$PdfOrderPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string | null
      image: string | null
      address: string | null
      phone: string | null
      otpCode: string | null
      otpExpires: Date | null
      resetToken: string | null
      resetTokenExpires: Date | null
      isVerified: boolean
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    donations<T extends User$donationsArgs<ExtArgs> = {}>(args?: Subset<T, User$donationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pdfOrders<T extends User$pdfOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$pdfOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PdfOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly otpCode: FieldRef<"User", 'String'>
    readonly otpExpires: FieldRef<"User", 'DateTime'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpires: FieldRef<"User", 'DateTime'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.donations
   */
  export type User$donationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    where?: DonationWhereInput
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    cursor?: DonationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * User.pdfOrders
   */
  export type User$pdfOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfOrder
     */
    select?: PdfOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfOrder
     */
    omit?: PdfOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfOrderInclude<ExtArgs> | null
    where?: PdfOrderWhereInput
    orderBy?: PdfOrderOrderByWithRelationInput | PdfOrderOrderByWithRelationInput[]
    cursor?: PdfOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PdfOrderScalarFieldEnum | PdfOrderScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    id: number | null
    userId: number | null
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: number | null
    userId: number | null
    providerType: string | null
    providerId: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    providerType: string | null
    providerId: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    providerType: number
    providerId: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    id?: true
    userId?: true
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    id?: true
    userId?: true
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    providerType?: true
    providerId?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    providerType?: true
    providerId?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    providerType?: true
    providerId?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: number
    userId: number
    providerType: string
    providerId: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    providerType?: boolean
    providerId?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>



  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    providerType?: boolean
    providerId?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "providerType" | "providerId" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      providerType: string
      providerId: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'Int'>
    readonly userId: FieldRef<"Account", 'Int'>
    readonly providerType: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: number | null
    sessionToken: string | null
    userId: number | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number | null
    sessionToken: string | null
    userId: number | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: number
    sessionToken: string
    userId: number
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionToken: string
      userId: number
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'Int'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'Int'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Donation
   */

  export type AggregateDonation = {
    _count: DonationCountAggregateOutputType | null
    _avg: DonationAvgAggregateOutputType | null
    _sum: DonationSumAggregateOutputType | null
    _min: DonationMinAggregateOutputType | null
    _max: DonationMaxAggregateOutputType | null
  }

  export type DonationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
  }

  export type DonationSumAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
  }

  export type DonationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    status: string | null
    paymentMethod: string | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DonationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    status: string | null
    paymentMethod: string | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DonationCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    status: number
    paymentMethod: number
    transactionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DonationAvgAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
  }

  export type DonationSumAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
  }

  export type DonationMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DonationMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DonationCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DonationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donation to aggregate.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Donations
    **/
    _count?: true | DonationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DonationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DonationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DonationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DonationMaxAggregateInputType
  }

  export type GetDonationAggregateType<T extends DonationAggregateArgs> = {
        [P in keyof T & keyof AggregateDonation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDonation[P]>
      : GetScalarType<T[P], AggregateDonation[P]>
  }




  export type DonationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonationWhereInput
    orderBy?: DonationOrderByWithAggregationInput | DonationOrderByWithAggregationInput[]
    by: DonationScalarFieldEnum[] | DonationScalarFieldEnum
    having?: DonationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DonationCountAggregateInputType | true
    _avg?: DonationAvgAggregateInputType
    _sum?: DonationSumAggregateInputType
    _min?: DonationMinAggregateInputType
    _max?: DonationMaxAggregateInputType
  }

  export type DonationGroupByOutputType = {
    id: number
    userId: number
    amount: number
    status: string
    paymentMethod: string | null
    transactionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DonationCountAggregateOutputType | null
    _avg: DonationAvgAggregateOutputType | null
    _sum: DonationSumAggregateOutputType | null
    _min: DonationMinAggregateOutputType | null
    _max: DonationMaxAggregateOutputType | null
  }

  type GetDonationGroupByPayload<T extends DonationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DonationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DonationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DonationGroupByOutputType[P]>
            : GetScalarType<T[P], DonationGroupByOutputType[P]>
        }
      >
    >


  export type DonationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["donation"]>



  export type DonationSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DonationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "amount" | "status" | "paymentMethod" | "transactionId" | "createdAt" | "updatedAt", ExtArgs["result"]["donation"]>
  export type DonationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DonationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Donation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      amount: number
      status: string
      paymentMethod: string | null
      transactionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["donation"]>
    composites: {}
  }

  type DonationGetPayload<S extends boolean | null | undefined | DonationDefaultArgs> = $Result.GetResult<Prisma.$DonationPayload, S>

  type DonationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DonationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DonationCountAggregateInputType | true
    }

  export interface DonationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Donation'], meta: { name: 'Donation' } }
    /**
     * Find zero or one Donation that matches the filter.
     * @param {DonationFindUniqueArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DonationFindUniqueArgs>(args: SelectSubset<T, DonationFindUniqueArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Donation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DonationFindUniqueOrThrowArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DonationFindUniqueOrThrowArgs>(args: SelectSubset<T, DonationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Donation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindFirstArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DonationFindFirstArgs>(args?: SelectSubset<T, DonationFindFirstArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Donation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindFirstOrThrowArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DonationFindFirstOrThrowArgs>(args?: SelectSubset<T, DonationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Donations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Donations
     * const donations = await prisma.donation.findMany()
     * 
     * // Get first 10 Donations
     * const donations = await prisma.donation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const donationWithIdOnly = await prisma.donation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DonationFindManyArgs>(args?: SelectSubset<T, DonationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Donation.
     * @param {DonationCreateArgs} args - Arguments to create a Donation.
     * @example
     * // Create one Donation
     * const Donation = await prisma.donation.create({
     *   data: {
     *     // ... data to create a Donation
     *   }
     * })
     * 
     */
    create<T extends DonationCreateArgs>(args: SelectSubset<T, DonationCreateArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Donations.
     * @param {DonationCreateManyArgs} args - Arguments to create many Donations.
     * @example
     * // Create many Donations
     * const donation = await prisma.donation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DonationCreateManyArgs>(args?: SelectSubset<T, DonationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Donation.
     * @param {DonationDeleteArgs} args - Arguments to delete one Donation.
     * @example
     * // Delete one Donation
     * const Donation = await prisma.donation.delete({
     *   where: {
     *     // ... filter to delete one Donation
     *   }
     * })
     * 
     */
    delete<T extends DonationDeleteArgs>(args: SelectSubset<T, DonationDeleteArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Donation.
     * @param {DonationUpdateArgs} args - Arguments to update one Donation.
     * @example
     * // Update one Donation
     * const donation = await prisma.donation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DonationUpdateArgs>(args: SelectSubset<T, DonationUpdateArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Donations.
     * @param {DonationDeleteManyArgs} args - Arguments to filter Donations to delete.
     * @example
     * // Delete a few Donations
     * const { count } = await prisma.donation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DonationDeleteManyArgs>(args?: SelectSubset<T, DonationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Donations
     * const donation = await prisma.donation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DonationUpdateManyArgs>(args: SelectSubset<T, DonationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Donation.
     * @param {DonationUpsertArgs} args - Arguments to update or create a Donation.
     * @example
     * // Update or create a Donation
     * const donation = await prisma.donation.upsert({
     *   create: {
     *     // ... data to create a Donation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Donation we want to update
     *   }
     * })
     */
    upsert<T extends DonationUpsertArgs>(args: SelectSubset<T, DonationUpsertArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationCountArgs} args - Arguments to filter Donations to count.
     * @example
     * // Count the number of Donations
     * const count = await prisma.donation.count({
     *   where: {
     *     // ... the filter for the Donations we want to count
     *   }
     * })
    **/
    count<T extends DonationCountArgs>(
      args?: Subset<T, DonationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DonationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Donation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DonationAggregateArgs>(args: Subset<T, DonationAggregateArgs>): Prisma.PrismaPromise<GetDonationAggregateType<T>>

    /**
     * Group by Donation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DonationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DonationGroupByArgs['orderBy'] }
        : { orderBy?: DonationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DonationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDonationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Donation model
   */
  readonly fields: DonationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Donation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DonationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Donation model
   */
  interface DonationFieldRefs {
    readonly id: FieldRef<"Donation", 'Int'>
    readonly userId: FieldRef<"Donation", 'Int'>
    readonly amount: FieldRef<"Donation", 'Float'>
    readonly status: FieldRef<"Donation", 'String'>
    readonly paymentMethod: FieldRef<"Donation", 'String'>
    readonly transactionId: FieldRef<"Donation", 'String'>
    readonly createdAt: FieldRef<"Donation", 'DateTime'>
    readonly updatedAt: FieldRef<"Donation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Donation findUnique
   */
  export type DonationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where: DonationWhereUniqueInput
  }

  /**
   * Donation findUniqueOrThrow
   */
  export type DonationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where: DonationWhereUniqueInput
  }

  /**
   * Donation findFirst
   */
  export type DonationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donations.
     */
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * Donation findFirstOrThrow
   */
  export type DonationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donations.
     */
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * Donation findMany
   */
  export type DonationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donations to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * Donation create
   */
  export type DonationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The data needed to create a Donation.
     */
    data: XOR<DonationCreateInput, DonationUncheckedCreateInput>
  }

  /**
   * Donation createMany
   */
  export type DonationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Donations.
     */
    data: DonationCreateManyInput | DonationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Donation update
   */
  export type DonationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The data needed to update a Donation.
     */
    data: XOR<DonationUpdateInput, DonationUncheckedUpdateInput>
    /**
     * Choose, which Donation to update.
     */
    where: DonationWhereUniqueInput
  }

  /**
   * Donation updateMany
   */
  export type DonationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Donations.
     */
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyInput>
    /**
     * Filter which Donations to update
     */
    where?: DonationWhereInput
    /**
     * Limit how many Donations to update.
     */
    limit?: number
  }

  /**
   * Donation upsert
   */
  export type DonationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The filter to search for the Donation to update in case it exists.
     */
    where: DonationWhereUniqueInput
    /**
     * In case the Donation found by the `where` argument doesn't exist, create a new Donation with this data.
     */
    create: XOR<DonationCreateInput, DonationUncheckedCreateInput>
    /**
     * In case the Donation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DonationUpdateInput, DonationUncheckedUpdateInput>
  }

  /**
   * Donation delete
   */
  export type DonationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter which Donation to delete.
     */
    where: DonationWhereUniqueInput
  }

  /**
   * Donation deleteMany
   */
  export type DonationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donations to delete
     */
    where?: DonationWhereInput
    /**
     * Limit how many Donations to delete.
     */
    limit?: number
  }

  /**
   * Donation without action
   */
  export type DonationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
  }


  /**
   * Model PdfBook
   */

  export type AggregatePdfBook = {
    _count: PdfBookCountAggregateOutputType | null
    _avg: PdfBookAvgAggregateOutputType | null
    _sum: PdfBookSumAggregateOutputType | null
    _min: PdfBookMinAggregateOutputType | null
    _max: PdfBookMaxAggregateOutputType | null
  }

  export type PdfBookAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type PdfBookSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type PdfBookMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    price: number | null
    pdfUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PdfBookMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    price: number | null
    pdfUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PdfBookCountAggregateOutputType = {
    id: number
    title: number
    description: number
    price: number
    pdfUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PdfBookAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type PdfBookSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type PdfBookMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PdfBookMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PdfBookCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PdfBookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PdfBook to aggregate.
     */
    where?: PdfBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PdfBooks to fetch.
     */
    orderBy?: PdfBookOrderByWithRelationInput | PdfBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PdfBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PdfBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PdfBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PdfBooks
    **/
    _count?: true | PdfBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PdfBookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PdfBookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PdfBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PdfBookMaxAggregateInputType
  }

  export type GetPdfBookAggregateType<T extends PdfBookAggregateArgs> = {
        [P in keyof T & keyof AggregatePdfBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePdfBook[P]>
      : GetScalarType<T[P], AggregatePdfBook[P]>
  }




  export type PdfBookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PdfBookWhereInput
    orderBy?: PdfBookOrderByWithAggregationInput | PdfBookOrderByWithAggregationInput[]
    by: PdfBookScalarFieldEnum[] | PdfBookScalarFieldEnum
    having?: PdfBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PdfBookCountAggregateInputType | true
    _avg?: PdfBookAvgAggregateInputType
    _sum?: PdfBookSumAggregateInputType
    _min?: PdfBookMinAggregateInputType
    _max?: PdfBookMaxAggregateInputType
  }

  export type PdfBookGroupByOutputType = {
    id: number
    title: string
    description: string | null
    price: number
    pdfUrl: string
    createdAt: Date
    updatedAt: Date
    _count: PdfBookCountAggregateOutputType | null
    _avg: PdfBookAvgAggregateOutputType | null
    _sum: PdfBookSumAggregateOutputType | null
    _min: PdfBookMinAggregateOutputType | null
    _max: PdfBookMaxAggregateOutputType | null
  }

  type GetPdfBookGroupByPayload<T extends PdfBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PdfBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PdfBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PdfBookGroupByOutputType[P]>
            : GetScalarType<T[P], PdfBookGroupByOutputType[P]>
        }
      >
    >


  export type PdfBookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | PdfBook$ordersArgs<ExtArgs>
    _count?: boolean | PdfBookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pdfBook"]>



  export type PdfBookSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PdfBookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "price" | "pdfUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["pdfBook"]>
  export type PdfBookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | PdfBook$ordersArgs<ExtArgs>
    _count?: boolean | PdfBookCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PdfBookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PdfBook"
    objects: {
      orders: Prisma.$PdfOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      price: number
      pdfUrl: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pdfBook"]>
    composites: {}
  }

  type PdfBookGetPayload<S extends boolean | null | undefined | PdfBookDefaultArgs> = $Result.GetResult<Prisma.$PdfBookPayload, S>

  type PdfBookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PdfBookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PdfBookCountAggregateInputType | true
    }

  export interface PdfBookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PdfBook'], meta: { name: 'PdfBook' } }
    /**
     * Find zero or one PdfBook that matches the filter.
     * @param {PdfBookFindUniqueArgs} args - Arguments to find a PdfBook
     * @example
     * // Get one PdfBook
     * const pdfBook = await prisma.pdfBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PdfBookFindUniqueArgs>(args: SelectSubset<T, PdfBookFindUniqueArgs<ExtArgs>>): Prisma__PdfBookClient<$Result.GetResult<Prisma.$PdfBookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PdfBook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PdfBookFindUniqueOrThrowArgs} args - Arguments to find a PdfBook
     * @example
     * // Get one PdfBook
     * const pdfBook = await prisma.pdfBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PdfBookFindUniqueOrThrowArgs>(args: SelectSubset<T, PdfBookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PdfBookClient<$Result.GetResult<Prisma.$PdfBookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PdfBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfBookFindFirstArgs} args - Arguments to find a PdfBook
     * @example
     * // Get one PdfBook
     * const pdfBook = await prisma.pdfBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PdfBookFindFirstArgs>(args?: SelectSubset<T, PdfBookFindFirstArgs<ExtArgs>>): Prisma__PdfBookClient<$Result.GetResult<Prisma.$PdfBookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PdfBook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfBookFindFirstOrThrowArgs} args - Arguments to find a PdfBook
     * @example
     * // Get one PdfBook
     * const pdfBook = await prisma.pdfBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PdfBookFindFirstOrThrowArgs>(args?: SelectSubset<T, PdfBookFindFirstOrThrowArgs<ExtArgs>>): Prisma__PdfBookClient<$Result.GetResult<Prisma.$PdfBookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PdfBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfBookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PdfBooks
     * const pdfBooks = await prisma.pdfBook.findMany()
     * 
     * // Get first 10 PdfBooks
     * const pdfBooks = await prisma.pdfBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pdfBookWithIdOnly = await prisma.pdfBook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PdfBookFindManyArgs>(args?: SelectSubset<T, PdfBookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PdfBookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PdfBook.
     * @param {PdfBookCreateArgs} args - Arguments to create a PdfBook.
     * @example
     * // Create one PdfBook
     * const PdfBook = await prisma.pdfBook.create({
     *   data: {
     *     // ... data to create a PdfBook
     *   }
     * })
     * 
     */
    create<T extends PdfBookCreateArgs>(args: SelectSubset<T, PdfBookCreateArgs<ExtArgs>>): Prisma__PdfBookClient<$Result.GetResult<Prisma.$PdfBookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PdfBooks.
     * @param {PdfBookCreateManyArgs} args - Arguments to create many PdfBooks.
     * @example
     * // Create many PdfBooks
     * const pdfBook = await prisma.pdfBook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PdfBookCreateManyArgs>(args?: SelectSubset<T, PdfBookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PdfBook.
     * @param {PdfBookDeleteArgs} args - Arguments to delete one PdfBook.
     * @example
     * // Delete one PdfBook
     * const PdfBook = await prisma.pdfBook.delete({
     *   where: {
     *     // ... filter to delete one PdfBook
     *   }
     * })
     * 
     */
    delete<T extends PdfBookDeleteArgs>(args: SelectSubset<T, PdfBookDeleteArgs<ExtArgs>>): Prisma__PdfBookClient<$Result.GetResult<Prisma.$PdfBookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PdfBook.
     * @param {PdfBookUpdateArgs} args - Arguments to update one PdfBook.
     * @example
     * // Update one PdfBook
     * const pdfBook = await prisma.pdfBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PdfBookUpdateArgs>(args: SelectSubset<T, PdfBookUpdateArgs<ExtArgs>>): Prisma__PdfBookClient<$Result.GetResult<Prisma.$PdfBookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PdfBooks.
     * @param {PdfBookDeleteManyArgs} args - Arguments to filter PdfBooks to delete.
     * @example
     * // Delete a few PdfBooks
     * const { count } = await prisma.pdfBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PdfBookDeleteManyArgs>(args?: SelectSubset<T, PdfBookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PdfBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PdfBooks
     * const pdfBook = await prisma.pdfBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PdfBookUpdateManyArgs>(args: SelectSubset<T, PdfBookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PdfBook.
     * @param {PdfBookUpsertArgs} args - Arguments to update or create a PdfBook.
     * @example
     * // Update or create a PdfBook
     * const pdfBook = await prisma.pdfBook.upsert({
     *   create: {
     *     // ... data to create a PdfBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PdfBook we want to update
     *   }
     * })
     */
    upsert<T extends PdfBookUpsertArgs>(args: SelectSubset<T, PdfBookUpsertArgs<ExtArgs>>): Prisma__PdfBookClient<$Result.GetResult<Prisma.$PdfBookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PdfBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfBookCountArgs} args - Arguments to filter PdfBooks to count.
     * @example
     * // Count the number of PdfBooks
     * const count = await prisma.pdfBook.count({
     *   where: {
     *     // ... the filter for the PdfBooks we want to count
     *   }
     * })
    **/
    count<T extends PdfBookCountArgs>(
      args?: Subset<T, PdfBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PdfBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PdfBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PdfBookAggregateArgs>(args: Subset<T, PdfBookAggregateArgs>): Prisma.PrismaPromise<GetPdfBookAggregateType<T>>

    /**
     * Group by PdfBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PdfBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PdfBookGroupByArgs['orderBy'] }
        : { orderBy?: PdfBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PdfBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPdfBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PdfBook model
   */
  readonly fields: PdfBookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PdfBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PdfBookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends PdfBook$ordersArgs<ExtArgs> = {}>(args?: Subset<T, PdfBook$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PdfOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PdfBook model
   */
  interface PdfBookFieldRefs {
    readonly id: FieldRef<"PdfBook", 'Int'>
    readonly title: FieldRef<"PdfBook", 'String'>
    readonly description: FieldRef<"PdfBook", 'String'>
    readonly price: FieldRef<"PdfBook", 'Float'>
    readonly pdfUrl: FieldRef<"PdfBook", 'String'>
    readonly createdAt: FieldRef<"PdfBook", 'DateTime'>
    readonly updatedAt: FieldRef<"PdfBook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PdfBook findUnique
   */
  export type PdfBookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfBook
     */
    select?: PdfBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfBook
     */
    omit?: PdfBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfBookInclude<ExtArgs> | null
    /**
     * Filter, which PdfBook to fetch.
     */
    where: PdfBookWhereUniqueInput
  }

  /**
   * PdfBook findUniqueOrThrow
   */
  export type PdfBookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfBook
     */
    select?: PdfBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfBook
     */
    omit?: PdfBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfBookInclude<ExtArgs> | null
    /**
     * Filter, which PdfBook to fetch.
     */
    where: PdfBookWhereUniqueInput
  }

  /**
   * PdfBook findFirst
   */
  export type PdfBookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfBook
     */
    select?: PdfBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfBook
     */
    omit?: PdfBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfBookInclude<ExtArgs> | null
    /**
     * Filter, which PdfBook to fetch.
     */
    where?: PdfBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PdfBooks to fetch.
     */
    orderBy?: PdfBookOrderByWithRelationInput | PdfBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PdfBooks.
     */
    cursor?: PdfBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PdfBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PdfBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PdfBooks.
     */
    distinct?: PdfBookScalarFieldEnum | PdfBookScalarFieldEnum[]
  }

  /**
   * PdfBook findFirstOrThrow
   */
  export type PdfBookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfBook
     */
    select?: PdfBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfBook
     */
    omit?: PdfBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfBookInclude<ExtArgs> | null
    /**
     * Filter, which PdfBook to fetch.
     */
    where?: PdfBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PdfBooks to fetch.
     */
    orderBy?: PdfBookOrderByWithRelationInput | PdfBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PdfBooks.
     */
    cursor?: PdfBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PdfBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PdfBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PdfBooks.
     */
    distinct?: PdfBookScalarFieldEnum | PdfBookScalarFieldEnum[]
  }

  /**
   * PdfBook findMany
   */
  export type PdfBookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfBook
     */
    select?: PdfBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfBook
     */
    omit?: PdfBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfBookInclude<ExtArgs> | null
    /**
     * Filter, which PdfBooks to fetch.
     */
    where?: PdfBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PdfBooks to fetch.
     */
    orderBy?: PdfBookOrderByWithRelationInput | PdfBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PdfBooks.
     */
    cursor?: PdfBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PdfBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PdfBooks.
     */
    skip?: number
    distinct?: PdfBookScalarFieldEnum | PdfBookScalarFieldEnum[]
  }

  /**
   * PdfBook create
   */
  export type PdfBookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfBook
     */
    select?: PdfBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfBook
     */
    omit?: PdfBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfBookInclude<ExtArgs> | null
    /**
     * The data needed to create a PdfBook.
     */
    data: XOR<PdfBookCreateInput, PdfBookUncheckedCreateInput>
  }

  /**
   * PdfBook createMany
   */
  export type PdfBookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PdfBooks.
     */
    data: PdfBookCreateManyInput | PdfBookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PdfBook update
   */
  export type PdfBookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfBook
     */
    select?: PdfBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfBook
     */
    omit?: PdfBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfBookInclude<ExtArgs> | null
    /**
     * The data needed to update a PdfBook.
     */
    data: XOR<PdfBookUpdateInput, PdfBookUncheckedUpdateInput>
    /**
     * Choose, which PdfBook to update.
     */
    where: PdfBookWhereUniqueInput
  }

  /**
   * PdfBook updateMany
   */
  export type PdfBookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PdfBooks.
     */
    data: XOR<PdfBookUpdateManyMutationInput, PdfBookUncheckedUpdateManyInput>
    /**
     * Filter which PdfBooks to update
     */
    where?: PdfBookWhereInput
    /**
     * Limit how many PdfBooks to update.
     */
    limit?: number
  }

  /**
   * PdfBook upsert
   */
  export type PdfBookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfBook
     */
    select?: PdfBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfBook
     */
    omit?: PdfBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfBookInclude<ExtArgs> | null
    /**
     * The filter to search for the PdfBook to update in case it exists.
     */
    where: PdfBookWhereUniqueInput
    /**
     * In case the PdfBook found by the `where` argument doesn't exist, create a new PdfBook with this data.
     */
    create: XOR<PdfBookCreateInput, PdfBookUncheckedCreateInput>
    /**
     * In case the PdfBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PdfBookUpdateInput, PdfBookUncheckedUpdateInput>
  }

  /**
   * PdfBook delete
   */
  export type PdfBookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfBook
     */
    select?: PdfBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfBook
     */
    omit?: PdfBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfBookInclude<ExtArgs> | null
    /**
     * Filter which PdfBook to delete.
     */
    where: PdfBookWhereUniqueInput
  }

  /**
   * PdfBook deleteMany
   */
  export type PdfBookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PdfBooks to delete
     */
    where?: PdfBookWhereInput
    /**
     * Limit how many PdfBooks to delete.
     */
    limit?: number
  }

  /**
   * PdfBook.orders
   */
  export type PdfBook$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfOrder
     */
    select?: PdfOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfOrder
     */
    omit?: PdfOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfOrderInclude<ExtArgs> | null
    where?: PdfOrderWhereInput
    orderBy?: PdfOrderOrderByWithRelationInput | PdfOrderOrderByWithRelationInput[]
    cursor?: PdfOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PdfOrderScalarFieldEnum | PdfOrderScalarFieldEnum[]
  }

  /**
   * PdfBook without action
   */
  export type PdfBookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfBook
     */
    select?: PdfBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfBook
     */
    omit?: PdfBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfBookInclude<ExtArgs> | null
  }


  /**
   * Model PdfOrder
   */

  export type AggregatePdfOrder = {
    _count: PdfOrderCountAggregateOutputType | null
    _avg: PdfOrderAvgAggregateOutputType | null
    _sum: PdfOrderSumAggregateOutputType | null
    _min: PdfOrderMinAggregateOutputType | null
    _max: PdfOrderMaxAggregateOutputType | null
  }

  export type PdfOrderAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    pdfBookId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type PdfOrderSumAggregateOutputType = {
    id: number | null
    userId: number | null
    pdfBookId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type PdfOrderMinAggregateOutputType = {
    id: number | null
    userId: number | null
    pdfBookId: number | null
    quantity: number | null
    totalPrice: number | null
    status: string | null
    paymentMethod: string | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PdfOrderMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    pdfBookId: number | null
    quantity: number | null
    totalPrice: number | null
    status: string | null
    paymentMethod: string | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PdfOrderCountAggregateOutputType = {
    id: number
    userId: number
    pdfBookId: number
    quantity: number
    totalPrice: number
    status: number
    paymentMethod: number
    transactionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PdfOrderAvgAggregateInputType = {
    id?: true
    userId?: true
    pdfBookId?: true
    quantity?: true
    totalPrice?: true
  }

  export type PdfOrderSumAggregateInputType = {
    id?: true
    userId?: true
    pdfBookId?: true
    quantity?: true
    totalPrice?: true
  }

  export type PdfOrderMinAggregateInputType = {
    id?: true
    userId?: true
    pdfBookId?: true
    quantity?: true
    totalPrice?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PdfOrderMaxAggregateInputType = {
    id?: true
    userId?: true
    pdfBookId?: true
    quantity?: true
    totalPrice?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PdfOrderCountAggregateInputType = {
    id?: true
    userId?: true
    pdfBookId?: true
    quantity?: true
    totalPrice?: true
    status?: true
    paymentMethod?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PdfOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PdfOrder to aggregate.
     */
    where?: PdfOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PdfOrders to fetch.
     */
    orderBy?: PdfOrderOrderByWithRelationInput | PdfOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PdfOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PdfOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PdfOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PdfOrders
    **/
    _count?: true | PdfOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PdfOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PdfOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PdfOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PdfOrderMaxAggregateInputType
  }

  export type GetPdfOrderAggregateType<T extends PdfOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePdfOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePdfOrder[P]>
      : GetScalarType<T[P], AggregatePdfOrder[P]>
  }




  export type PdfOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PdfOrderWhereInput
    orderBy?: PdfOrderOrderByWithAggregationInput | PdfOrderOrderByWithAggregationInput[]
    by: PdfOrderScalarFieldEnum[] | PdfOrderScalarFieldEnum
    having?: PdfOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PdfOrderCountAggregateInputType | true
    _avg?: PdfOrderAvgAggregateInputType
    _sum?: PdfOrderSumAggregateInputType
    _min?: PdfOrderMinAggregateInputType
    _max?: PdfOrderMaxAggregateInputType
  }

  export type PdfOrderGroupByOutputType = {
    id: number
    userId: number
    pdfBookId: number
    quantity: number
    totalPrice: number
    status: string
    paymentMethod: string | null
    transactionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PdfOrderCountAggregateOutputType | null
    _avg: PdfOrderAvgAggregateOutputType | null
    _sum: PdfOrderSumAggregateOutputType | null
    _min: PdfOrderMinAggregateOutputType | null
    _max: PdfOrderMaxAggregateOutputType | null
  }

  type GetPdfOrderGroupByPayload<T extends PdfOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PdfOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PdfOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PdfOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PdfOrderGroupByOutputType[P]>
        }
      >
    >


  export type PdfOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    pdfBookId?: boolean
    quantity?: boolean
    totalPrice?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    pdfBook?: boolean | PdfBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pdfOrder"]>



  export type PdfOrderSelectScalar = {
    id?: boolean
    userId?: boolean
    pdfBookId?: boolean
    quantity?: boolean
    totalPrice?: boolean
    status?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PdfOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "pdfBookId" | "quantity" | "totalPrice" | "status" | "paymentMethod" | "transactionId" | "createdAt" | "updatedAt", ExtArgs["result"]["pdfOrder"]>
  export type PdfOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    pdfBook?: boolean | PdfBookDefaultArgs<ExtArgs>
  }

  export type $PdfOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PdfOrder"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      pdfBook: Prisma.$PdfBookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      pdfBookId: number
      quantity: number
      totalPrice: number
      status: string
      paymentMethod: string | null
      transactionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pdfOrder"]>
    composites: {}
  }

  type PdfOrderGetPayload<S extends boolean | null | undefined | PdfOrderDefaultArgs> = $Result.GetResult<Prisma.$PdfOrderPayload, S>

  type PdfOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PdfOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PdfOrderCountAggregateInputType | true
    }

  export interface PdfOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PdfOrder'], meta: { name: 'PdfOrder' } }
    /**
     * Find zero or one PdfOrder that matches the filter.
     * @param {PdfOrderFindUniqueArgs} args - Arguments to find a PdfOrder
     * @example
     * // Get one PdfOrder
     * const pdfOrder = await prisma.pdfOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PdfOrderFindUniqueArgs>(args: SelectSubset<T, PdfOrderFindUniqueArgs<ExtArgs>>): Prisma__PdfOrderClient<$Result.GetResult<Prisma.$PdfOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PdfOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PdfOrderFindUniqueOrThrowArgs} args - Arguments to find a PdfOrder
     * @example
     * // Get one PdfOrder
     * const pdfOrder = await prisma.pdfOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PdfOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PdfOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PdfOrderClient<$Result.GetResult<Prisma.$PdfOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PdfOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfOrderFindFirstArgs} args - Arguments to find a PdfOrder
     * @example
     * // Get one PdfOrder
     * const pdfOrder = await prisma.pdfOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PdfOrderFindFirstArgs>(args?: SelectSubset<T, PdfOrderFindFirstArgs<ExtArgs>>): Prisma__PdfOrderClient<$Result.GetResult<Prisma.$PdfOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PdfOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfOrderFindFirstOrThrowArgs} args - Arguments to find a PdfOrder
     * @example
     * // Get one PdfOrder
     * const pdfOrder = await prisma.pdfOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PdfOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PdfOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PdfOrderClient<$Result.GetResult<Prisma.$PdfOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PdfOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PdfOrders
     * const pdfOrders = await prisma.pdfOrder.findMany()
     * 
     * // Get first 10 PdfOrders
     * const pdfOrders = await prisma.pdfOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pdfOrderWithIdOnly = await prisma.pdfOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PdfOrderFindManyArgs>(args?: SelectSubset<T, PdfOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PdfOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PdfOrder.
     * @param {PdfOrderCreateArgs} args - Arguments to create a PdfOrder.
     * @example
     * // Create one PdfOrder
     * const PdfOrder = await prisma.pdfOrder.create({
     *   data: {
     *     // ... data to create a PdfOrder
     *   }
     * })
     * 
     */
    create<T extends PdfOrderCreateArgs>(args: SelectSubset<T, PdfOrderCreateArgs<ExtArgs>>): Prisma__PdfOrderClient<$Result.GetResult<Prisma.$PdfOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PdfOrders.
     * @param {PdfOrderCreateManyArgs} args - Arguments to create many PdfOrders.
     * @example
     * // Create many PdfOrders
     * const pdfOrder = await prisma.pdfOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PdfOrderCreateManyArgs>(args?: SelectSubset<T, PdfOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PdfOrder.
     * @param {PdfOrderDeleteArgs} args - Arguments to delete one PdfOrder.
     * @example
     * // Delete one PdfOrder
     * const PdfOrder = await prisma.pdfOrder.delete({
     *   where: {
     *     // ... filter to delete one PdfOrder
     *   }
     * })
     * 
     */
    delete<T extends PdfOrderDeleteArgs>(args: SelectSubset<T, PdfOrderDeleteArgs<ExtArgs>>): Prisma__PdfOrderClient<$Result.GetResult<Prisma.$PdfOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PdfOrder.
     * @param {PdfOrderUpdateArgs} args - Arguments to update one PdfOrder.
     * @example
     * // Update one PdfOrder
     * const pdfOrder = await prisma.pdfOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PdfOrderUpdateArgs>(args: SelectSubset<T, PdfOrderUpdateArgs<ExtArgs>>): Prisma__PdfOrderClient<$Result.GetResult<Prisma.$PdfOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PdfOrders.
     * @param {PdfOrderDeleteManyArgs} args - Arguments to filter PdfOrders to delete.
     * @example
     * // Delete a few PdfOrders
     * const { count } = await prisma.pdfOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PdfOrderDeleteManyArgs>(args?: SelectSubset<T, PdfOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PdfOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PdfOrders
     * const pdfOrder = await prisma.pdfOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PdfOrderUpdateManyArgs>(args: SelectSubset<T, PdfOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PdfOrder.
     * @param {PdfOrderUpsertArgs} args - Arguments to update or create a PdfOrder.
     * @example
     * // Update or create a PdfOrder
     * const pdfOrder = await prisma.pdfOrder.upsert({
     *   create: {
     *     // ... data to create a PdfOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PdfOrder we want to update
     *   }
     * })
     */
    upsert<T extends PdfOrderUpsertArgs>(args: SelectSubset<T, PdfOrderUpsertArgs<ExtArgs>>): Prisma__PdfOrderClient<$Result.GetResult<Prisma.$PdfOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PdfOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfOrderCountArgs} args - Arguments to filter PdfOrders to count.
     * @example
     * // Count the number of PdfOrders
     * const count = await prisma.pdfOrder.count({
     *   where: {
     *     // ... the filter for the PdfOrders we want to count
     *   }
     * })
    **/
    count<T extends PdfOrderCountArgs>(
      args?: Subset<T, PdfOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PdfOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PdfOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PdfOrderAggregateArgs>(args: Subset<T, PdfOrderAggregateArgs>): Prisma.PrismaPromise<GetPdfOrderAggregateType<T>>

    /**
     * Group by PdfOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PdfOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PdfOrderGroupByArgs['orderBy'] }
        : { orderBy?: PdfOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PdfOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPdfOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PdfOrder model
   */
  readonly fields: PdfOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PdfOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PdfOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pdfBook<T extends PdfBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PdfBookDefaultArgs<ExtArgs>>): Prisma__PdfBookClient<$Result.GetResult<Prisma.$PdfBookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PdfOrder model
   */
  interface PdfOrderFieldRefs {
    readonly id: FieldRef<"PdfOrder", 'Int'>
    readonly userId: FieldRef<"PdfOrder", 'Int'>
    readonly pdfBookId: FieldRef<"PdfOrder", 'Int'>
    readonly quantity: FieldRef<"PdfOrder", 'Int'>
    readonly totalPrice: FieldRef<"PdfOrder", 'Float'>
    readonly status: FieldRef<"PdfOrder", 'String'>
    readonly paymentMethod: FieldRef<"PdfOrder", 'String'>
    readonly transactionId: FieldRef<"PdfOrder", 'String'>
    readonly createdAt: FieldRef<"PdfOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PdfOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PdfOrder findUnique
   */
  export type PdfOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfOrder
     */
    select?: PdfOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfOrder
     */
    omit?: PdfOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfOrderInclude<ExtArgs> | null
    /**
     * Filter, which PdfOrder to fetch.
     */
    where: PdfOrderWhereUniqueInput
  }

  /**
   * PdfOrder findUniqueOrThrow
   */
  export type PdfOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfOrder
     */
    select?: PdfOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfOrder
     */
    omit?: PdfOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfOrderInclude<ExtArgs> | null
    /**
     * Filter, which PdfOrder to fetch.
     */
    where: PdfOrderWhereUniqueInput
  }

  /**
   * PdfOrder findFirst
   */
  export type PdfOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfOrder
     */
    select?: PdfOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfOrder
     */
    omit?: PdfOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfOrderInclude<ExtArgs> | null
    /**
     * Filter, which PdfOrder to fetch.
     */
    where?: PdfOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PdfOrders to fetch.
     */
    orderBy?: PdfOrderOrderByWithRelationInput | PdfOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PdfOrders.
     */
    cursor?: PdfOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PdfOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PdfOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PdfOrders.
     */
    distinct?: PdfOrderScalarFieldEnum | PdfOrderScalarFieldEnum[]
  }

  /**
   * PdfOrder findFirstOrThrow
   */
  export type PdfOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfOrder
     */
    select?: PdfOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfOrder
     */
    omit?: PdfOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfOrderInclude<ExtArgs> | null
    /**
     * Filter, which PdfOrder to fetch.
     */
    where?: PdfOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PdfOrders to fetch.
     */
    orderBy?: PdfOrderOrderByWithRelationInput | PdfOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PdfOrders.
     */
    cursor?: PdfOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PdfOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PdfOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PdfOrders.
     */
    distinct?: PdfOrderScalarFieldEnum | PdfOrderScalarFieldEnum[]
  }

  /**
   * PdfOrder findMany
   */
  export type PdfOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfOrder
     */
    select?: PdfOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfOrder
     */
    omit?: PdfOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfOrderInclude<ExtArgs> | null
    /**
     * Filter, which PdfOrders to fetch.
     */
    where?: PdfOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PdfOrders to fetch.
     */
    orderBy?: PdfOrderOrderByWithRelationInput | PdfOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PdfOrders.
     */
    cursor?: PdfOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PdfOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PdfOrders.
     */
    skip?: number
    distinct?: PdfOrderScalarFieldEnum | PdfOrderScalarFieldEnum[]
  }

  /**
   * PdfOrder create
   */
  export type PdfOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfOrder
     */
    select?: PdfOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfOrder
     */
    omit?: PdfOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PdfOrder.
     */
    data: XOR<PdfOrderCreateInput, PdfOrderUncheckedCreateInput>
  }

  /**
   * PdfOrder createMany
   */
  export type PdfOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PdfOrders.
     */
    data: PdfOrderCreateManyInput | PdfOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PdfOrder update
   */
  export type PdfOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfOrder
     */
    select?: PdfOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfOrder
     */
    omit?: PdfOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PdfOrder.
     */
    data: XOR<PdfOrderUpdateInput, PdfOrderUncheckedUpdateInput>
    /**
     * Choose, which PdfOrder to update.
     */
    where: PdfOrderWhereUniqueInput
  }

  /**
   * PdfOrder updateMany
   */
  export type PdfOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PdfOrders.
     */
    data: XOR<PdfOrderUpdateManyMutationInput, PdfOrderUncheckedUpdateManyInput>
    /**
     * Filter which PdfOrders to update
     */
    where?: PdfOrderWhereInput
    /**
     * Limit how many PdfOrders to update.
     */
    limit?: number
  }

  /**
   * PdfOrder upsert
   */
  export type PdfOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfOrder
     */
    select?: PdfOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfOrder
     */
    omit?: PdfOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PdfOrder to update in case it exists.
     */
    where: PdfOrderWhereUniqueInput
    /**
     * In case the PdfOrder found by the `where` argument doesn't exist, create a new PdfOrder with this data.
     */
    create: XOR<PdfOrderCreateInput, PdfOrderUncheckedCreateInput>
    /**
     * In case the PdfOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PdfOrderUpdateInput, PdfOrderUncheckedUpdateInput>
  }

  /**
   * PdfOrder delete
   */
  export type PdfOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfOrder
     */
    select?: PdfOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfOrder
     */
    omit?: PdfOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfOrderInclude<ExtArgs> | null
    /**
     * Filter which PdfOrder to delete.
     */
    where: PdfOrderWhereUniqueInput
  }

  /**
   * PdfOrder deleteMany
   */
  export type PdfOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PdfOrders to delete
     */
    where?: PdfOrderWhereInput
    /**
     * Limit how many PdfOrders to delete.
     */
    limit?: number
  }

  /**
   * PdfOrder without action
   */
  export type PdfOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfOrder
     */
    select?: PdfOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfOrder
     */
    omit?: PdfOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfOrderInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    referenceId: string | null
    provider: string | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    referenceId: string | null
    provider: string | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    referenceId: number
    provider: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    referenceId?: true
    provider?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    referenceId?: true
    provider?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    referenceId?: true
    provider?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    userId: number
    referenceId: string
    provider: string
    amount: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    referenceId?: boolean
    provider?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>



  export type PaymentSelectScalar = {
    id?: boolean
    userId?: boolean
    referenceId?: boolean
    provider?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "referenceId" | "provider" | "amount" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      referenceId: string
      provider: string
      amount: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly userId: FieldRef<"Payment", 'Int'>
    readonly referenceId: FieldRef<"Payment", 'String'>
    readonly provider: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model News
   */

  export type AggregateNews = {
    _count: NewsCountAggregateOutputType | null
    _avg: NewsAvgAggregateOutputType | null
    _sum: NewsSumAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  export type NewsAvgAggregateOutputType = {
    id: number | null
  }

  export type NewsSumAggregateOutputType = {
    id: number | null
  }

  export type NewsMinAggregateOutputType = {
    id: number | null
    title: string | null
    titleEn: string | null
    slug: string | null
    featuredImage: string | null
    authorName: string | null
    authorAvatar: string | null
    authorRole: string | null
    publishedDate: string | null
    readTime: string | null
    views: string | null
    category: string | null
    tags: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    titleEn: string | null
    slug: string | null
    featuredImage: string | null
    authorName: string | null
    authorAvatar: string | null
    authorRole: string | null
    publishedDate: string | null
    readTime: string | null
    views: string | null
    category: string | null
    tags: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsCountAggregateOutputType = {
    id: number
    title: number
    titleEn: number
    slug: number
    featuredImage: number
    authorName: number
    authorAvatar: number
    authorRole: number
    publishedDate: number
    readTime: number
    views: number
    category: number
    tags: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NewsAvgAggregateInputType = {
    id?: true
  }

  export type NewsSumAggregateInputType = {
    id?: true
  }

  export type NewsMinAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    slug?: true
    featuredImage?: true
    authorName?: true
    authorAvatar?: true
    authorRole?: true
    publishedDate?: true
    readTime?: true
    views?: true
    category?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsMaxAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    slug?: true
    featuredImage?: true
    authorName?: true
    authorAvatar?: true
    authorRole?: true
    publishedDate?: true
    readTime?: true
    views?: true
    category?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsCountAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    slug?: true
    featuredImage?: true
    authorName?: true
    authorAvatar?: true
    authorRole?: true
    publishedDate?: true
    readTime?: true
    views?: true
    category?: true
    tags?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to aggregate.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned News
    **/
    _count?: true | NewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsMaxAggregateInputType
  }

  export type GetNewsAggregateType<T extends NewsAggregateArgs> = {
        [P in keyof T & keyof AggregateNews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews[P]>
      : GetScalarType<T[P], AggregateNews[P]>
  }




  export type NewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsWhereInput
    orderBy?: NewsOrderByWithAggregationInput | NewsOrderByWithAggregationInput[]
    by: NewsScalarFieldEnum[] | NewsScalarFieldEnum
    having?: NewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsCountAggregateInputType | true
    _avg?: NewsAvgAggregateInputType
    _sum?: NewsSumAggregateInputType
    _min?: NewsMinAggregateInputType
    _max?: NewsMaxAggregateInputType
  }

  export type NewsGroupByOutputType = {
    id: number
    title: string
    titleEn: string | null
    slug: string
    featuredImage: string | null
    authorName: string | null
    authorAvatar: string | null
    authorRole: string | null
    publishedDate: string | null
    readTime: string | null
    views: string | null
    category: string | null
    tags: string | null
    content: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: NewsCountAggregateOutputType | null
    _avg: NewsAvgAggregateOutputType | null
    _sum: NewsSumAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  type GetNewsGroupByPayload<T extends NewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsGroupByOutputType[P]>
            : GetScalarType<T[P], NewsGroupByOutputType[P]>
        }
      >
    >


  export type NewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    titleEn?: boolean
    slug?: boolean
    featuredImage?: boolean
    authorName?: boolean
    authorAvatar?: boolean
    authorRole?: boolean
    publishedDate?: boolean
    readTime?: boolean
    views?: boolean
    category?: boolean
    tags?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["news"]>



  export type NewsSelectScalar = {
    id?: boolean
    title?: boolean
    titleEn?: boolean
    slug?: boolean
    featuredImage?: boolean
    authorName?: boolean
    authorAvatar?: boolean
    authorRole?: boolean
    publishedDate?: boolean
    readTime?: boolean
    views?: boolean
    category?: boolean
    tags?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "titleEn" | "slug" | "featuredImage" | "authorName" | "authorAvatar" | "authorRole" | "publishedDate" | "readTime" | "views" | "category" | "tags" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["news"]>

  export type $NewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "News"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      titleEn: string | null
      slug: string
      featuredImage: string | null
      authorName: string | null
      authorAvatar: string | null
      authorRole: string | null
      publishedDate: string | null
      readTime: string | null
      views: string | null
      category: string | null
      tags: string | null
      content: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["news"]>
    composites: {}
  }

  type NewsGetPayload<S extends boolean | null | undefined | NewsDefaultArgs> = $Result.GetResult<Prisma.$NewsPayload, S>

  type NewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsCountAggregateInputType | true
    }

  export interface NewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['News'], meta: { name: 'News' } }
    /**
     * Find zero or one News that matches the filter.
     * @param {NewsFindUniqueArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsFindUniqueArgs>(args: SelectSubset<T, NewsFindUniqueArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one News that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsFindUniqueOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsFindFirstArgs>(args?: SelectSubset<T, NewsFindFirstArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first News that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News
     * const news = await prisma.news.findMany()
     * 
     * // Get first 10 News
     * const news = await prisma.news.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsWithIdOnly = await prisma.news.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsFindManyArgs>(args?: SelectSubset<T, NewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a News.
     * @param {NewsCreateArgs} args - Arguments to create a News.
     * @example
     * // Create one News
     * const News = await prisma.news.create({
     *   data: {
     *     // ... data to create a News
     *   }
     * })
     * 
     */
    create<T extends NewsCreateArgs>(args: SelectSubset<T, NewsCreateArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many News.
     * @param {NewsCreateManyArgs} args - Arguments to create many News.
     * @example
     * // Create many News
     * const news = await prisma.news.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsCreateManyArgs>(args?: SelectSubset<T, NewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a News.
     * @param {NewsDeleteArgs} args - Arguments to delete one News.
     * @example
     * // Delete one News
     * const News = await prisma.news.delete({
     *   where: {
     *     // ... filter to delete one News
     *   }
     * })
     * 
     */
    delete<T extends NewsDeleteArgs>(args: SelectSubset<T, NewsDeleteArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one News.
     * @param {NewsUpdateArgs} args - Arguments to update one News.
     * @example
     * // Update one News
     * const news = await prisma.news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsUpdateArgs>(args: SelectSubset<T, NewsUpdateArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more News.
     * @param {NewsDeleteManyArgs} args - Arguments to filter News to delete.
     * @example
     * // Delete a few News
     * const { count } = await prisma.news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsDeleteManyArgs>(args?: SelectSubset<T, NewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News
     * const news = await prisma.news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsUpdateManyArgs>(args: SelectSubset<T, NewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one News.
     * @param {NewsUpsertArgs} args - Arguments to update or create a News.
     * @example
     * // Update or create a News
     * const news = await prisma.news.upsert({
     *   create: {
     *     // ... data to create a News
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News we want to update
     *   }
     * })
     */
    upsert<T extends NewsUpsertArgs>(args: SelectSubset<T, NewsUpsertArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsCountArgs} args - Arguments to filter News to count.
     * @example
     * // Count the number of News
     * const count = await prisma.news.count({
     *   where: {
     *     // ... the filter for the News we want to count
     *   }
     * })
    **/
    count<T extends NewsCountArgs>(
      args?: Subset<T, NewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsAggregateArgs>(args: Subset<T, NewsAggregateArgs>): Prisma.PrismaPromise<GetNewsAggregateType<T>>

    /**
     * Group by News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsGroupByArgs['orderBy'] }
        : { orderBy?: NewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the News model
   */
  readonly fields: NewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for News.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the News model
   */
  interface NewsFieldRefs {
    readonly id: FieldRef<"News", 'Int'>
    readonly title: FieldRef<"News", 'String'>
    readonly titleEn: FieldRef<"News", 'String'>
    readonly slug: FieldRef<"News", 'String'>
    readonly featuredImage: FieldRef<"News", 'String'>
    readonly authorName: FieldRef<"News", 'String'>
    readonly authorAvatar: FieldRef<"News", 'String'>
    readonly authorRole: FieldRef<"News", 'String'>
    readonly publishedDate: FieldRef<"News", 'String'>
    readonly readTime: FieldRef<"News", 'String'>
    readonly views: FieldRef<"News", 'String'>
    readonly category: FieldRef<"News", 'String'>
    readonly tags: FieldRef<"News", 'String'>
    readonly content: FieldRef<"News", 'Json'>
    readonly createdAt: FieldRef<"News", 'DateTime'>
    readonly updatedAt: FieldRef<"News", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * News findUnique
   */
  export type NewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News findUniqueOrThrow
   */
  export type NewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News findFirst
   */
  export type NewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News findFirstOrThrow
   */
  export type NewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News findMany
   */
  export type NewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News create
   */
  export type NewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The data needed to create a News.
     */
    data: XOR<NewsCreateInput, NewsUncheckedCreateInput>
  }

  /**
   * News createMany
   */
  export type NewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many News.
     */
    data: NewsCreateManyInput | NewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * News update
   */
  export type NewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The data needed to update a News.
     */
    data: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
    /**
     * Choose, which News to update.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News updateMany
   */
  export type NewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update News.
     */
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyInput>
    /**
     * Filter which News to update
     */
    where?: NewsWhereInput
    /**
     * Limit how many News to update.
     */
    limit?: number
  }

  /**
   * News upsert
   */
  export type NewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The filter to search for the News to update in case it exists.
     */
    where: NewsWhereUniqueInput
    /**
     * In case the News found by the `where` argument doesn't exist, create a new News with this data.
     */
    create: XOR<NewsCreateInput, NewsUncheckedCreateInput>
    /**
     * In case the News was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
  }

  /**
   * News delete
   */
  export type NewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter which News to delete.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News deleteMany
   */
  export type NewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to delete
     */
    where?: NewsWhereInput
    /**
     * Limit how many News to delete.
     */
    limit?: number
  }

  /**
   * News without action
   */
  export type NewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
  }


  /**
   * Model GopalPariwar
   */

  export type AggregateGopalPariwar = {
    _count: GopalPariwarCountAggregateOutputType | null
    _avg: GopalPariwarAvgAggregateOutputType | null
    _sum: GopalPariwarSumAggregateOutputType | null
    _min: GopalPariwarMinAggregateOutputType | null
    _max: GopalPariwarMaxAggregateOutputType | null
  }

  export type GopalPariwarAvgAggregateOutputType = {
    id: number | null
  }

  export type GopalPariwarSumAggregateOutputType = {
    id: number | null
  }

  export type GopalPariwarMinAggregateOutputType = {
    id: number | null
    heroImage: string | null
    heroTitle: string | null
    heroSubtitle: string | null
    spiritualEducation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GopalPariwarMaxAggregateOutputType = {
    id: number | null
    heroImage: string | null
    heroTitle: string | null
    heroSubtitle: string | null
    spiritualEducation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GopalPariwarCountAggregateOutputType = {
    id: number
    heroImage: number
    heroTitle: number
    heroSubtitle: number
    personalInfo: number
    spiritualEducation: number
    lifeJourney: number
    responsibilities: number
    pledges: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GopalPariwarAvgAggregateInputType = {
    id?: true
  }

  export type GopalPariwarSumAggregateInputType = {
    id?: true
  }

  export type GopalPariwarMinAggregateInputType = {
    id?: true
    heroImage?: true
    heroTitle?: true
    heroSubtitle?: true
    spiritualEducation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GopalPariwarMaxAggregateInputType = {
    id?: true
    heroImage?: true
    heroTitle?: true
    heroSubtitle?: true
    spiritualEducation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GopalPariwarCountAggregateInputType = {
    id?: true
    heroImage?: true
    heroTitle?: true
    heroSubtitle?: true
    personalInfo?: true
    spiritualEducation?: true
    lifeJourney?: true
    responsibilities?: true
    pledges?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GopalPariwarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GopalPariwar to aggregate.
     */
    where?: GopalPariwarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GopalPariwars to fetch.
     */
    orderBy?: GopalPariwarOrderByWithRelationInput | GopalPariwarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GopalPariwarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GopalPariwars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GopalPariwars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GopalPariwars
    **/
    _count?: true | GopalPariwarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GopalPariwarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GopalPariwarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GopalPariwarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GopalPariwarMaxAggregateInputType
  }

  export type GetGopalPariwarAggregateType<T extends GopalPariwarAggregateArgs> = {
        [P in keyof T & keyof AggregateGopalPariwar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGopalPariwar[P]>
      : GetScalarType<T[P], AggregateGopalPariwar[P]>
  }




  export type GopalPariwarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GopalPariwarWhereInput
    orderBy?: GopalPariwarOrderByWithAggregationInput | GopalPariwarOrderByWithAggregationInput[]
    by: GopalPariwarScalarFieldEnum[] | GopalPariwarScalarFieldEnum
    having?: GopalPariwarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GopalPariwarCountAggregateInputType | true
    _avg?: GopalPariwarAvgAggregateInputType
    _sum?: GopalPariwarSumAggregateInputType
    _min?: GopalPariwarMinAggregateInputType
    _max?: GopalPariwarMaxAggregateInputType
  }

  export type GopalPariwarGroupByOutputType = {
    id: number
    heroImage: string
    heroTitle: string
    heroSubtitle: string
    personalInfo: JsonValue
    spiritualEducation: string | null
    lifeJourney: JsonValue
    responsibilities: JsonValue
    pledges: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: GopalPariwarCountAggregateOutputType | null
    _avg: GopalPariwarAvgAggregateOutputType | null
    _sum: GopalPariwarSumAggregateOutputType | null
    _min: GopalPariwarMinAggregateOutputType | null
    _max: GopalPariwarMaxAggregateOutputType | null
  }

  type GetGopalPariwarGroupByPayload<T extends GopalPariwarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GopalPariwarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GopalPariwarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GopalPariwarGroupByOutputType[P]>
            : GetScalarType<T[P], GopalPariwarGroupByOutputType[P]>
        }
      >
    >


  export type GopalPariwarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    heroImage?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    personalInfo?: boolean
    spiritualEducation?: boolean
    lifeJourney?: boolean
    responsibilities?: boolean
    pledges?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gopalPariwar"]>



  export type GopalPariwarSelectScalar = {
    id?: boolean
    heroImage?: boolean
    heroTitle?: boolean
    heroSubtitle?: boolean
    personalInfo?: boolean
    spiritualEducation?: boolean
    lifeJourney?: boolean
    responsibilities?: boolean
    pledges?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GopalPariwarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "heroImage" | "heroTitle" | "heroSubtitle" | "personalInfo" | "spiritualEducation" | "lifeJourney" | "responsibilities" | "pledges" | "createdAt" | "updatedAt", ExtArgs["result"]["gopalPariwar"]>

  export type $GopalPariwarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GopalPariwar"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      heroImage: string
      heroTitle: string
      heroSubtitle: string
      personalInfo: Prisma.JsonValue
      spiritualEducation: string | null
      lifeJourney: Prisma.JsonValue
      responsibilities: Prisma.JsonValue
      pledges: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gopalPariwar"]>
    composites: {}
  }

  type GopalPariwarGetPayload<S extends boolean | null | undefined | GopalPariwarDefaultArgs> = $Result.GetResult<Prisma.$GopalPariwarPayload, S>

  type GopalPariwarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GopalPariwarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GopalPariwarCountAggregateInputType | true
    }

  export interface GopalPariwarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GopalPariwar'], meta: { name: 'GopalPariwar' } }
    /**
     * Find zero or one GopalPariwar that matches the filter.
     * @param {GopalPariwarFindUniqueArgs} args - Arguments to find a GopalPariwar
     * @example
     * // Get one GopalPariwar
     * const gopalPariwar = await prisma.gopalPariwar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GopalPariwarFindUniqueArgs>(args: SelectSubset<T, GopalPariwarFindUniqueArgs<ExtArgs>>): Prisma__GopalPariwarClient<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GopalPariwar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GopalPariwarFindUniqueOrThrowArgs} args - Arguments to find a GopalPariwar
     * @example
     * // Get one GopalPariwar
     * const gopalPariwar = await prisma.gopalPariwar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GopalPariwarFindUniqueOrThrowArgs>(args: SelectSubset<T, GopalPariwarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GopalPariwarClient<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GopalPariwar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GopalPariwarFindFirstArgs} args - Arguments to find a GopalPariwar
     * @example
     * // Get one GopalPariwar
     * const gopalPariwar = await prisma.gopalPariwar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GopalPariwarFindFirstArgs>(args?: SelectSubset<T, GopalPariwarFindFirstArgs<ExtArgs>>): Prisma__GopalPariwarClient<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GopalPariwar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GopalPariwarFindFirstOrThrowArgs} args - Arguments to find a GopalPariwar
     * @example
     * // Get one GopalPariwar
     * const gopalPariwar = await prisma.gopalPariwar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GopalPariwarFindFirstOrThrowArgs>(args?: SelectSubset<T, GopalPariwarFindFirstOrThrowArgs<ExtArgs>>): Prisma__GopalPariwarClient<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GopalPariwars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GopalPariwarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GopalPariwars
     * const gopalPariwars = await prisma.gopalPariwar.findMany()
     * 
     * // Get first 10 GopalPariwars
     * const gopalPariwars = await prisma.gopalPariwar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gopalPariwarWithIdOnly = await prisma.gopalPariwar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GopalPariwarFindManyArgs>(args?: SelectSubset<T, GopalPariwarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GopalPariwar.
     * @param {GopalPariwarCreateArgs} args - Arguments to create a GopalPariwar.
     * @example
     * // Create one GopalPariwar
     * const GopalPariwar = await prisma.gopalPariwar.create({
     *   data: {
     *     // ... data to create a GopalPariwar
     *   }
     * })
     * 
     */
    create<T extends GopalPariwarCreateArgs>(args: SelectSubset<T, GopalPariwarCreateArgs<ExtArgs>>): Prisma__GopalPariwarClient<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GopalPariwars.
     * @param {GopalPariwarCreateManyArgs} args - Arguments to create many GopalPariwars.
     * @example
     * // Create many GopalPariwars
     * const gopalPariwar = await prisma.gopalPariwar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GopalPariwarCreateManyArgs>(args?: SelectSubset<T, GopalPariwarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GopalPariwar.
     * @param {GopalPariwarDeleteArgs} args - Arguments to delete one GopalPariwar.
     * @example
     * // Delete one GopalPariwar
     * const GopalPariwar = await prisma.gopalPariwar.delete({
     *   where: {
     *     // ... filter to delete one GopalPariwar
     *   }
     * })
     * 
     */
    delete<T extends GopalPariwarDeleteArgs>(args: SelectSubset<T, GopalPariwarDeleteArgs<ExtArgs>>): Prisma__GopalPariwarClient<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GopalPariwar.
     * @param {GopalPariwarUpdateArgs} args - Arguments to update one GopalPariwar.
     * @example
     * // Update one GopalPariwar
     * const gopalPariwar = await prisma.gopalPariwar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GopalPariwarUpdateArgs>(args: SelectSubset<T, GopalPariwarUpdateArgs<ExtArgs>>): Prisma__GopalPariwarClient<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GopalPariwars.
     * @param {GopalPariwarDeleteManyArgs} args - Arguments to filter GopalPariwars to delete.
     * @example
     * // Delete a few GopalPariwars
     * const { count } = await prisma.gopalPariwar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GopalPariwarDeleteManyArgs>(args?: SelectSubset<T, GopalPariwarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GopalPariwars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GopalPariwarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GopalPariwars
     * const gopalPariwar = await prisma.gopalPariwar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GopalPariwarUpdateManyArgs>(args: SelectSubset<T, GopalPariwarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GopalPariwar.
     * @param {GopalPariwarUpsertArgs} args - Arguments to update or create a GopalPariwar.
     * @example
     * // Update or create a GopalPariwar
     * const gopalPariwar = await prisma.gopalPariwar.upsert({
     *   create: {
     *     // ... data to create a GopalPariwar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GopalPariwar we want to update
     *   }
     * })
     */
    upsert<T extends GopalPariwarUpsertArgs>(args: SelectSubset<T, GopalPariwarUpsertArgs<ExtArgs>>): Prisma__GopalPariwarClient<$Result.GetResult<Prisma.$GopalPariwarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GopalPariwars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GopalPariwarCountArgs} args - Arguments to filter GopalPariwars to count.
     * @example
     * // Count the number of GopalPariwars
     * const count = await prisma.gopalPariwar.count({
     *   where: {
     *     // ... the filter for the GopalPariwars we want to count
     *   }
     * })
    **/
    count<T extends GopalPariwarCountArgs>(
      args?: Subset<T, GopalPariwarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GopalPariwarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GopalPariwar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GopalPariwarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GopalPariwarAggregateArgs>(args: Subset<T, GopalPariwarAggregateArgs>): Prisma.PrismaPromise<GetGopalPariwarAggregateType<T>>

    /**
     * Group by GopalPariwar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GopalPariwarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GopalPariwarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GopalPariwarGroupByArgs['orderBy'] }
        : { orderBy?: GopalPariwarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GopalPariwarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGopalPariwarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GopalPariwar model
   */
  readonly fields: GopalPariwarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GopalPariwar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GopalPariwarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GopalPariwar model
   */
  interface GopalPariwarFieldRefs {
    readonly id: FieldRef<"GopalPariwar", 'Int'>
    readonly heroImage: FieldRef<"GopalPariwar", 'String'>
    readonly heroTitle: FieldRef<"GopalPariwar", 'String'>
    readonly heroSubtitle: FieldRef<"GopalPariwar", 'String'>
    readonly personalInfo: FieldRef<"GopalPariwar", 'Json'>
    readonly spiritualEducation: FieldRef<"GopalPariwar", 'String'>
    readonly lifeJourney: FieldRef<"GopalPariwar", 'Json'>
    readonly responsibilities: FieldRef<"GopalPariwar", 'Json'>
    readonly pledges: FieldRef<"GopalPariwar", 'Json'>
    readonly createdAt: FieldRef<"GopalPariwar", 'DateTime'>
    readonly updatedAt: FieldRef<"GopalPariwar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GopalPariwar findUnique
   */
  export type GopalPariwarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * Filter, which GopalPariwar to fetch.
     */
    where: GopalPariwarWhereUniqueInput
  }

  /**
   * GopalPariwar findUniqueOrThrow
   */
  export type GopalPariwarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * Filter, which GopalPariwar to fetch.
     */
    where: GopalPariwarWhereUniqueInput
  }

  /**
   * GopalPariwar findFirst
   */
  export type GopalPariwarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * Filter, which GopalPariwar to fetch.
     */
    where?: GopalPariwarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GopalPariwars to fetch.
     */
    orderBy?: GopalPariwarOrderByWithRelationInput | GopalPariwarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GopalPariwars.
     */
    cursor?: GopalPariwarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GopalPariwars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GopalPariwars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GopalPariwars.
     */
    distinct?: GopalPariwarScalarFieldEnum | GopalPariwarScalarFieldEnum[]
  }

  /**
   * GopalPariwar findFirstOrThrow
   */
  export type GopalPariwarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * Filter, which GopalPariwar to fetch.
     */
    where?: GopalPariwarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GopalPariwars to fetch.
     */
    orderBy?: GopalPariwarOrderByWithRelationInput | GopalPariwarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GopalPariwars.
     */
    cursor?: GopalPariwarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GopalPariwars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GopalPariwars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GopalPariwars.
     */
    distinct?: GopalPariwarScalarFieldEnum | GopalPariwarScalarFieldEnum[]
  }

  /**
   * GopalPariwar findMany
   */
  export type GopalPariwarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * Filter, which GopalPariwars to fetch.
     */
    where?: GopalPariwarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GopalPariwars to fetch.
     */
    orderBy?: GopalPariwarOrderByWithRelationInput | GopalPariwarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GopalPariwars.
     */
    cursor?: GopalPariwarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GopalPariwars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GopalPariwars.
     */
    skip?: number
    distinct?: GopalPariwarScalarFieldEnum | GopalPariwarScalarFieldEnum[]
  }

  /**
   * GopalPariwar create
   */
  export type GopalPariwarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * The data needed to create a GopalPariwar.
     */
    data: XOR<GopalPariwarCreateInput, GopalPariwarUncheckedCreateInput>
  }

  /**
   * GopalPariwar createMany
   */
  export type GopalPariwarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GopalPariwars.
     */
    data: GopalPariwarCreateManyInput | GopalPariwarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GopalPariwar update
   */
  export type GopalPariwarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * The data needed to update a GopalPariwar.
     */
    data: XOR<GopalPariwarUpdateInput, GopalPariwarUncheckedUpdateInput>
    /**
     * Choose, which GopalPariwar to update.
     */
    where: GopalPariwarWhereUniqueInput
  }

  /**
   * GopalPariwar updateMany
   */
  export type GopalPariwarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GopalPariwars.
     */
    data: XOR<GopalPariwarUpdateManyMutationInput, GopalPariwarUncheckedUpdateManyInput>
    /**
     * Filter which GopalPariwars to update
     */
    where?: GopalPariwarWhereInput
    /**
     * Limit how many GopalPariwars to update.
     */
    limit?: number
  }

  /**
   * GopalPariwar upsert
   */
  export type GopalPariwarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * The filter to search for the GopalPariwar to update in case it exists.
     */
    where: GopalPariwarWhereUniqueInput
    /**
     * In case the GopalPariwar found by the `where` argument doesn't exist, create a new GopalPariwar with this data.
     */
    create: XOR<GopalPariwarCreateInput, GopalPariwarUncheckedCreateInput>
    /**
     * In case the GopalPariwar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GopalPariwarUpdateInput, GopalPariwarUncheckedUpdateInput>
  }

  /**
   * GopalPariwar delete
   */
  export type GopalPariwarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
    /**
     * Filter which GopalPariwar to delete.
     */
    where: GopalPariwarWhereUniqueInput
  }

  /**
   * GopalPariwar deleteMany
   */
  export type GopalPariwarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GopalPariwars to delete
     */
    where?: GopalPariwarWhereInput
    /**
     * Limit how many GopalPariwars to delete.
     */
    limit?: number
  }

  /**
   * GopalPariwar without action
   */
  export type GopalPariwarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GopalPariwar
     */
    select?: GopalPariwarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GopalPariwar
     */
    omit?: GopalPariwarOmit<ExtArgs> | null
  }


  /**
   * Model Gaushala
   */

  export type AggregateGaushala = {
    _count: GaushalaCountAggregateOutputType | null
    _avg: GaushalaAvgAggregateOutputType | null
    _sum: GaushalaSumAggregateOutputType | null
    _min: GaushalaMinAggregateOutputType | null
    _max: GaushalaMaxAggregateOutputType | null
  }

  export type GaushalaAvgAggregateOutputType = {
    id: number | null
    establishmentYear: number | null
    totalCows: number | null
    capacity: number | null
  }

  export type GaushalaSumAggregateOutputType = {
    id: number | null
    establishmentYear: number | null
    totalCows: number | null
    capacity: number | null
  }

  export type GaushalaMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    establishmentYear: number | null
    contactDetails: string | null
    totalCows: number | null
    capacity: number | null
    description: string | null
    city: string | null
    state: string | null
    pincode: string | null
    contactPerson: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaushalaMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    establishmentYear: number | null
    contactDetails: string | null
    totalCows: number | null
    capacity: number | null
    description: string | null
    city: string | null
    state: string | null
    pincode: string | null
    contactPerson: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GaushalaCountAggregateOutputType = {
    id: number
    name: number
    address: number
    establishmentYear: number
    contactDetails: number
    totalCows: number
    capacity: number
    description: number
    city: number
    state: number
    pincode: number
    contactPerson: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GaushalaAvgAggregateInputType = {
    id?: true
    establishmentYear?: true
    totalCows?: true
    capacity?: true
  }

  export type GaushalaSumAggregateInputType = {
    id?: true
    establishmentYear?: true
    totalCows?: true
    capacity?: true
  }

  export type GaushalaMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    establishmentYear?: true
    contactDetails?: true
    totalCows?: true
    capacity?: true
    description?: true
    city?: true
    state?: true
    pincode?: true
    contactPerson?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaushalaMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    establishmentYear?: true
    contactDetails?: true
    totalCows?: true
    capacity?: true
    description?: true
    city?: true
    state?: true
    pincode?: true
    contactPerson?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GaushalaCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    establishmentYear?: true
    contactDetails?: true
    totalCows?: true
    capacity?: true
    description?: true
    city?: true
    state?: true
    pincode?: true
    contactPerson?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GaushalaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gaushala to aggregate.
     */
    where?: GaushalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gaushalas to fetch.
     */
    orderBy?: GaushalaOrderByWithRelationInput | GaushalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GaushalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gaushalas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gaushalas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gaushalas
    **/
    _count?: true | GaushalaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GaushalaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GaushalaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GaushalaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GaushalaMaxAggregateInputType
  }

  export type GetGaushalaAggregateType<T extends GaushalaAggregateArgs> = {
        [P in keyof T & keyof AggregateGaushala]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGaushala[P]>
      : GetScalarType<T[P], AggregateGaushala[P]>
  }




  export type GaushalaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GaushalaWhereInput
    orderBy?: GaushalaOrderByWithAggregationInput | GaushalaOrderByWithAggregationInput[]
    by: GaushalaScalarFieldEnum[] | GaushalaScalarFieldEnum
    having?: GaushalaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GaushalaCountAggregateInputType | true
    _avg?: GaushalaAvgAggregateInputType
    _sum?: GaushalaSumAggregateInputType
    _min?: GaushalaMinAggregateInputType
    _max?: GaushalaMaxAggregateInputType
  }

  export type GaushalaGroupByOutputType = {
    id: number
    name: string
    address: string
    establishmentYear: number
    contactDetails: string
    totalCows: number
    capacity: number
    description: string | null
    city: string
    state: string
    pincode: string
    contactPerson: string
    createdAt: Date
    updatedAt: Date
    _count: GaushalaCountAggregateOutputType | null
    _avg: GaushalaAvgAggregateOutputType | null
    _sum: GaushalaSumAggregateOutputType | null
    _min: GaushalaMinAggregateOutputType | null
    _max: GaushalaMaxAggregateOutputType | null
  }

  type GetGaushalaGroupByPayload<T extends GaushalaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GaushalaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GaushalaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GaushalaGroupByOutputType[P]>
            : GetScalarType<T[P], GaushalaGroupByOutputType[P]>
        }
      >
    >


  export type GaushalaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    establishmentYear?: boolean
    contactDetails?: boolean
    totalCows?: boolean
    capacity?: boolean
    description?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    contactPerson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gaushala"]>



  export type GaushalaSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    establishmentYear?: boolean
    contactDetails?: boolean
    totalCows?: boolean
    capacity?: boolean
    description?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    contactPerson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GaushalaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "establishmentYear" | "contactDetails" | "totalCows" | "capacity" | "description" | "city" | "state" | "pincode" | "contactPerson" | "createdAt" | "updatedAt", ExtArgs["result"]["gaushala"]>

  export type $GaushalaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gaushala"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string
      establishmentYear: number
      contactDetails: string
      totalCows: number
      capacity: number
      description: string | null
      city: string
      state: string
      pincode: string
      contactPerson: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gaushala"]>
    composites: {}
  }

  type GaushalaGetPayload<S extends boolean | null | undefined | GaushalaDefaultArgs> = $Result.GetResult<Prisma.$GaushalaPayload, S>

  type GaushalaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GaushalaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GaushalaCountAggregateInputType | true
    }

  export interface GaushalaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gaushala'], meta: { name: 'Gaushala' } }
    /**
     * Find zero or one Gaushala that matches the filter.
     * @param {GaushalaFindUniqueArgs} args - Arguments to find a Gaushala
     * @example
     * // Get one Gaushala
     * const gaushala = await prisma.gaushala.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GaushalaFindUniqueArgs>(args: SelectSubset<T, GaushalaFindUniqueArgs<ExtArgs>>): Prisma__GaushalaClient<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gaushala that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GaushalaFindUniqueOrThrowArgs} args - Arguments to find a Gaushala
     * @example
     * // Get one Gaushala
     * const gaushala = await prisma.gaushala.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GaushalaFindUniqueOrThrowArgs>(args: SelectSubset<T, GaushalaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GaushalaClient<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gaushala that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaushalaFindFirstArgs} args - Arguments to find a Gaushala
     * @example
     * // Get one Gaushala
     * const gaushala = await prisma.gaushala.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GaushalaFindFirstArgs>(args?: SelectSubset<T, GaushalaFindFirstArgs<ExtArgs>>): Prisma__GaushalaClient<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gaushala that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaushalaFindFirstOrThrowArgs} args - Arguments to find a Gaushala
     * @example
     * // Get one Gaushala
     * const gaushala = await prisma.gaushala.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GaushalaFindFirstOrThrowArgs>(args?: SelectSubset<T, GaushalaFindFirstOrThrowArgs<ExtArgs>>): Prisma__GaushalaClient<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gaushalas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaushalaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gaushalas
     * const gaushalas = await prisma.gaushala.findMany()
     * 
     * // Get first 10 Gaushalas
     * const gaushalas = await prisma.gaushala.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gaushalaWithIdOnly = await prisma.gaushala.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GaushalaFindManyArgs>(args?: SelectSubset<T, GaushalaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gaushala.
     * @param {GaushalaCreateArgs} args - Arguments to create a Gaushala.
     * @example
     * // Create one Gaushala
     * const Gaushala = await prisma.gaushala.create({
     *   data: {
     *     // ... data to create a Gaushala
     *   }
     * })
     * 
     */
    create<T extends GaushalaCreateArgs>(args: SelectSubset<T, GaushalaCreateArgs<ExtArgs>>): Prisma__GaushalaClient<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gaushalas.
     * @param {GaushalaCreateManyArgs} args - Arguments to create many Gaushalas.
     * @example
     * // Create many Gaushalas
     * const gaushala = await prisma.gaushala.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GaushalaCreateManyArgs>(args?: SelectSubset<T, GaushalaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gaushala.
     * @param {GaushalaDeleteArgs} args - Arguments to delete one Gaushala.
     * @example
     * // Delete one Gaushala
     * const Gaushala = await prisma.gaushala.delete({
     *   where: {
     *     // ... filter to delete one Gaushala
     *   }
     * })
     * 
     */
    delete<T extends GaushalaDeleteArgs>(args: SelectSubset<T, GaushalaDeleteArgs<ExtArgs>>): Prisma__GaushalaClient<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gaushala.
     * @param {GaushalaUpdateArgs} args - Arguments to update one Gaushala.
     * @example
     * // Update one Gaushala
     * const gaushala = await prisma.gaushala.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GaushalaUpdateArgs>(args: SelectSubset<T, GaushalaUpdateArgs<ExtArgs>>): Prisma__GaushalaClient<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gaushalas.
     * @param {GaushalaDeleteManyArgs} args - Arguments to filter Gaushalas to delete.
     * @example
     * // Delete a few Gaushalas
     * const { count } = await prisma.gaushala.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GaushalaDeleteManyArgs>(args?: SelectSubset<T, GaushalaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gaushalas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaushalaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gaushalas
     * const gaushala = await prisma.gaushala.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GaushalaUpdateManyArgs>(args: SelectSubset<T, GaushalaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gaushala.
     * @param {GaushalaUpsertArgs} args - Arguments to update or create a Gaushala.
     * @example
     * // Update or create a Gaushala
     * const gaushala = await prisma.gaushala.upsert({
     *   create: {
     *     // ... data to create a Gaushala
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gaushala we want to update
     *   }
     * })
     */
    upsert<T extends GaushalaUpsertArgs>(args: SelectSubset<T, GaushalaUpsertArgs<ExtArgs>>): Prisma__GaushalaClient<$Result.GetResult<Prisma.$GaushalaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gaushalas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaushalaCountArgs} args - Arguments to filter Gaushalas to count.
     * @example
     * // Count the number of Gaushalas
     * const count = await prisma.gaushala.count({
     *   where: {
     *     // ... the filter for the Gaushalas we want to count
     *   }
     * })
    **/
    count<T extends GaushalaCountArgs>(
      args?: Subset<T, GaushalaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GaushalaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gaushala.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaushalaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GaushalaAggregateArgs>(args: Subset<T, GaushalaAggregateArgs>): Prisma.PrismaPromise<GetGaushalaAggregateType<T>>

    /**
     * Group by Gaushala.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GaushalaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GaushalaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GaushalaGroupByArgs['orderBy'] }
        : { orderBy?: GaushalaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GaushalaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGaushalaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gaushala model
   */
  readonly fields: GaushalaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gaushala.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GaushalaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gaushala model
   */
  interface GaushalaFieldRefs {
    readonly id: FieldRef<"Gaushala", 'Int'>
    readonly name: FieldRef<"Gaushala", 'String'>
    readonly address: FieldRef<"Gaushala", 'String'>
    readonly establishmentYear: FieldRef<"Gaushala", 'Int'>
    readonly contactDetails: FieldRef<"Gaushala", 'String'>
    readonly totalCows: FieldRef<"Gaushala", 'Int'>
    readonly capacity: FieldRef<"Gaushala", 'Int'>
    readonly description: FieldRef<"Gaushala", 'String'>
    readonly city: FieldRef<"Gaushala", 'String'>
    readonly state: FieldRef<"Gaushala", 'String'>
    readonly pincode: FieldRef<"Gaushala", 'String'>
    readonly contactPerson: FieldRef<"Gaushala", 'String'>
    readonly createdAt: FieldRef<"Gaushala", 'DateTime'>
    readonly updatedAt: FieldRef<"Gaushala", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Gaushala findUnique
   */
  export type GaushalaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * Filter, which Gaushala to fetch.
     */
    where: GaushalaWhereUniqueInput
  }

  /**
   * Gaushala findUniqueOrThrow
   */
  export type GaushalaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * Filter, which Gaushala to fetch.
     */
    where: GaushalaWhereUniqueInput
  }

  /**
   * Gaushala findFirst
   */
  export type GaushalaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * Filter, which Gaushala to fetch.
     */
    where?: GaushalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gaushalas to fetch.
     */
    orderBy?: GaushalaOrderByWithRelationInput | GaushalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gaushalas.
     */
    cursor?: GaushalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gaushalas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gaushalas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gaushalas.
     */
    distinct?: GaushalaScalarFieldEnum | GaushalaScalarFieldEnum[]
  }

  /**
   * Gaushala findFirstOrThrow
   */
  export type GaushalaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * Filter, which Gaushala to fetch.
     */
    where?: GaushalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gaushalas to fetch.
     */
    orderBy?: GaushalaOrderByWithRelationInput | GaushalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gaushalas.
     */
    cursor?: GaushalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gaushalas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gaushalas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gaushalas.
     */
    distinct?: GaushalaScalarFieldEnum | GaushalaScalarFieldEnum[]
  }

  /**
   * Gaushala findMany
   */
  export type GaushalaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * Filter, which Gaushalas to fetch.
     */
    where?: GaushalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gaushalas to fetch.
     */
    orderBy?: GaushalaOrderByWithRelationInput | GaushalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gaushalas.
     */
    cursor?: GaushalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gaushalas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gaushalas.
     */
    skip?: number
    distinct?: GaushalaScalarFieldEnum | GaushalaScalarFieldEnum[]
  }

  /**
   * Gaushala create
   */
  export type GaushalaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * The data needed to create a Gaushala.
     */
    data: XOR<GaushalaCreateInput, GaushalaUncheckedCreateInput>
  }

  /**
   * Gaushala createMany
   */
  export type GaushalaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gaushalas.
     */
    data: GaushalaCreateManyInput | GaushalaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gaushala update
   */
  export type GaushalaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * The data needed to update a Gaushala.
     */
    data: XOR<GaushalaUpdateInput, GaushalaUncheckedUpdateInput>
    /**
     * Choose, which Gaushala to update.
     */
    where: GaushalaWhereUniqueInput
  }

  /**
   * Gaushala updateMany
   */
  export type GaushalaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gaushalas.
     */
    data: XOR<GaushalaUpdateManyMutationInput, GaushalaUncheckedUpdateManyInput>
    /**
     * Filter which Gaushalas to update
     */
    where?: GaushalaWhereInput
    /**
     * Limit how many Gaushalas to update.
     */
    limit?: number
  }

  /**
   * Gaushala upsert
   */
  export type GaushalaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * The filter to search for the Gaushala to update in case it exists.
     */
    where: GaushalaWhereUniqueInput
    /**
     * In case the Gaushala found by the `where` argument doesn't exist, create a new Gaushala with this data.
     */
    create: XOR<GaushalaCreateInput, GaushalaUncheckedCreateInput>
    /**
     * In case the Gaushala was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GaushalaUpdateInput, GaushalaUncheckedUpdateInput>
  }

  /**
   * Gaushala delete
   */
  export type GaushalaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
    /**
     * Filter which Gaushala to delete.
     */
    where: GaushalaWhereUniqueInput
  }

  /**
   * Gaushala deleteMany
   */
  export type GaushalaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gaushalas to delete
     */
    where?: GaushalaWhereInput
    /**
     * Limit how many Gaushalas to delete.
     */
    limit?: number
  }

  /**
   * Gaushala without action
   */
  export type GaushalaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gaushala
     */
    select?: GaushalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gaushala
     */
    omit?: GaushalaOmit<ExtArgs> | null
  }


  /**
   * Model Card
   */

  export type AggregateCard = {
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  export type CardAvgAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type CardSumAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type CardMinAggregateOutputType = {
    id: number | null
    title: string | null
    titleEn: string | null
    link: string | null
    image: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CardMaxAggregateOutputType = {
    id: number | null
    title: string | null
    titleEn: string | null
    link: string | null
    image: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CardCountAggregateOutputType = {
    id: number
    title: number
    titleEn: number
    link: number
    image: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CardAvgAggregateInputType = {
    id?: true
    order?: true
  }

  export type CardSumAggregateInputType = {
    id?: true
    order?: true
  }

  export type CardMinAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    link?: true
    image?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CardMaxAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    link?: true
    image?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CardCountAggregateInputType = {
    id?: true
    title?: true
    titleEn?: true
    link?: true
    image?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Card to aggregate.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cards
    **/
    _count?: true | CardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardMaxAggregateInputType
  }

  export type GetCardAggregateType<T extends CardAggregateArgs> = {
        [P in keyof T & keyof AggregateCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCard[P]>
      : GetScalarType<T[P], AggregateCard[P]>
  }




  export type CardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardWhereInput
    orderBy?: CardOrderByWithAggregationInput | CardOrderByWithAggregationInput[]
    by: CardScalarFieldEnum[] | CardScalarFieldEnum
    having?: CardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardCountAggregateInputType | true
    _avg?: CardAvgAggregateInputType
    _sum?: CardSumAggregateInputType
    _min?: CardMinAggregateInputType
    _max?: CardMaxAggregateInputType
  }

  export type CardGroupByOutputType = {
    id: number
    title: string
    titleEn: string | null
    link: string
    image: string | null
    order: number | null
    createdAt: Date
    updatedAt: Date
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  type GetCardGroupByPayload<T extends CardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardGroupByOutputType[P]>
            : GetScalarType<T[P], CardGroupByOutputType[P]>
        }
      >
    >


  export type CardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    titleEn?: boolean
    link?: boolean
    image?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["card"]>



  export type CardSelectScalar = {
    id?: boolean
    title?: boolean
    titleEn?: boolean
    link?: boolean
    image?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "titleEn" | "link" | "image" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["card"]>

  export type $CardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Card"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      titleEn: string | null
      link: string
      image: string | null
      order: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["card"]>
    composites: {}
  }

  type CardGetPayload<S extends boolean | null | undefined | CardDefaultArgs> = $Result.GetResult<Prisma.$CardPayload, S>

  type CardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardCountAggregateInputType | true
    }

  export interface CardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Card'], meta: { name: 'Card' } }
    /**
     * Find zero or one Card that matches the filter.
     * @param {CardFindUniqueArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardFindUniqueArgs>(args: SelectSubset<T, CardFindUniqueArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Card that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardFindUniqueOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardFindUniqueOrThrowArgs>(args: SelectSubset<T, CardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Card that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindFirstArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardFindFirstArgs>(args?: SelectSubset<T, CardFindFirstArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Card that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindFirstOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardFindFirstOrThrowArgs>(args?: SelectSubset<T, CardFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cards
     * const cards = await prisma.card.findMany()
     * 
     * // Get first 10 Cards
     * const cards = await prisma.card.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardWithIdOnly = await prisma.card.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardFindManyArgs>(args?: SelectSubset<T, CardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Card.
     * @param {CardCreateArgs} args - Arguments to create a Card.
     * @example
     * // Create one Card
     * const Card = await prisma.card.create({
     *   data: {
     *     // ... data to create a Card
     *   }
     * })
     * 
     */
    create<T extends CardCreateArgs>(args: SelectSubset<T, CardCreateArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cards.
     * @param {CardCreateManyArgs} args - Arguments to create many Cards.
     * @example
     * // Create many Cards
     * const card = await prisma.card.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardCreateManyArgs>(args?: SelectSubset<T, CardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Card.
     * @param {CardDeleteArgs} args - Arguments to delete one Card.
     * @example
     * // Delete one Card
     * const Card = await prisma.card.delete({
     *   where: {
     *     // ... filter to delete one Card
     *   }
     * })
     * 
     */
    delete<T extends CardDeleteArgs>(args: SelectSubset<T, CardDeleteArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Card.
     * @param {CardUpdateArgs} args - Arguments to update one Card.
     * @example
     * // Update one Card
     * const card = await prisma.card.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardUpdateArgs>(args: SelectSubset<T, CardUpdateArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cards.
     * @param {CardDeleteManyArgs} args - Arguments to filter Cards to delete.
     * @example
     * // Delete a few Cards
     * const { count } = await prisma.card.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardDeleteManyArgs>(args?: SelectSubset<T, CardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cards
     * const card = await prisma.card.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardUpdateManyArgs>(args: SelectSubset<T, CardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Card.
     * @param {CardUpsertArgs} args - Arguments to update or create a Card.
     * @example
     * // Update or create a Card
     * const card = await prisma.card.upsert({
     *   create: {
     *     // ... data to create a Card
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Card we want to update
     *   }
     * })
     */
    upsert<T extends CardUpsertArgs>(args: SelectSubset<T, CardUpsertArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardCountArgs} args - Arguments to filter Cards to count.
     * @example
     * // Count the number of Cards
     * const count = await prisma.card.count({
     *   where: {
     *     // ... the filter for the Cards we want to count
     *   }
     * })
    **/
    count<T extends CardCountArgs>(
      args?: Subset<T, CardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardAggregateArgs>(args: Subset<T, CardAggregateArgs>): Prisma.PrismaPromise<GetCardAggregateType<T>>

    /**
     * Group by Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardGroupByArgs['orderBy'] }
        : { orderBy?: CardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Card model
   */
  readonly fields: CardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Card.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Card model
   */
  interface CardFieldRefs {
    readonly id: FieldRef<"Card", 'Int'>
    readonly title: FieldRef<"Card", 'String'>
    readonly titleEn: FieldRef<"Card", 'String'>
    readonly link: FieldRef<"Card", 'String'>
    readonly image: FieldRef<"Card", 'String'>
    readonly order: FieldRef<"Card", 'Int'>
    readonly createdAt: FieldRef<"Card", 'DateTime'>
    readonly updatedAt: FieldRef<"Card", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Card findUnique
   */
  export type CardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card findUniqueOrThrow
   */
  export type CardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card findFirst
   */
  export type CardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cards.
     */
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card findFirstOrThrow
   */
  export type CardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cards.
     */
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card findMany
   */
  export type CardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Filter, which Cards to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card create
   */
  export type CardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * The data needed to create a Card.
     */
    data: XOR<CardCreateInput, CardUncheckedCreateInput>
  }

  /**
   * Card createMany
   */
  export type CardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cards.
     */
    data: CardCreateManyInput | CardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Card update
   */
  export type CardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * The data needed to update a Card.
     */
    data: XOR<CardUpdateInput, CardUncheckedUpdateInput>
    /**
     * Choose, which Card to update.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card updateMany
   */
  export type CardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cards.
     */
    data: XOR<CardUpdateManyMutationInput, CardUncheckedUpdateManyInput>
    /**
     * Filter which Cards to update
     */
    where?: CardWhereInput
    /**
     * Limit how many Cards to update.
     */
    limit?: number
  }

  /**
   * Card upsert
   */
  export type CardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * The filter to search for the Card to update in case it exists.
     */
    where: CardWhereUniqueInput
    /**
     * In case the Card found by the `where` argument doesn't exist, create a new Card with this data.
     */
    create: XOR<CardCreateInput, CardUncheckedCreateInput>
    /**
     * In case the Card was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardUpdateInput, CardUncheckedUpdateInput>
  }

  /**
   * Card delete
   */
  export type CardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
    /**
     * Filter which Card to delete.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card deleteMany
   */
  export type CardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cards to delete
     */
    where?: CardWhereInput
    /**
     * Limit how many Cards to delete.
     */
    limit?: number
  }

  /**
   * Card without action
   */
  export type CardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Card
     */
    omit?: CardOmit<ExtArgs> | null
  }


  /**
   * Model DtaSanssthan
   */

  export type AggregateDtaSanssthan = {
    _count: DtaSanssthanCountAggregateOutputType | null
    _avg: DtaSanssthanAvgAggregateOutputType | null
    _sum: DtaSanssthanSumAggregateOutputType | null
    _min: DtaSanssthanMinAggregateOutputType | null
    _max: DtaSanssthanMaxAggregateOutputType | null
  }

  export type DtaSanssthanAvgAggregateOutputType = {
    id: number | null
  }

  export type DtaSanssthanSumAggregateOutputType = {
    id: number | null
  }

  export type DtaSanssthanMinAggregateOutputType = {
    id: number | null
    name: string | null
    person: string | null
    image: string | null
    description: string | null
    email: string | null
    phone: string | null
    altPhone: string | null
    website: string | null
    timing: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DtaSanssthanMaxAggregateOutputType = {
    id: number | null
    name: string | null
    person: string | null
    image: string | null
    description: string | null
    email: string | null
    phone: string | null
    altPhone: string | null
    website: string | null
    timing: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DtaSanssthanCountAggregateOutputType = {
    id: number
    name: number
    person: number
    image: number
    description: number
    email: number
    phone: number
    altPhone: number
    website: number
    timing: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DtaSanssthanAvgAggregateInputType = {
    id?: true
  }

  export type DtaSanssthanSumAggregateInputType = {
    id?: true
  }

  export type DtaSanssthanMinAggregateInputType = {
    id?: true
    name?: true
    person?: true
    image?: true
    description?: true
    email?: true
    phone?: true
    altPhone?: true
    website?: true
    timing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DtaSanssthanMaxAggregateInputType = {
    id?: true
    name?: true
    person?: true
    image?: true
    description?: true
    email?: true
    phone?: true
    altPhone?: true
    website?: true
    timing?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DtaSanssthanCountAggregateInputType = {
    id?: true
    name?: true
    person?: true
    image?: true
    description?: true
    email?: true
    phone?: true
    altPhone?: true
    website?: true
    timing?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DtaSanssthanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DtaSanssthan to aggregate.
     */
    where?: DtaSanssthanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DtaSanssthans to fetch.
     */
    orderBy?: DtaSanssthanOrderByWithRelationInput | DtaSanssthanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DtaSanssthanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DtaSanssthans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DtaSanssthans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DtaSanssthans
    **/
    _count?: true | DtaSanssthanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DtaSanssthanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DtaSanssthanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DtaSanssthanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DtaSanssthanMaxAggregateInputType
  }

  export type GetDtaSanssthanAggregateType<T extends DtaSanssthanAggregateArgs> = {
        [P in keyof T & keyof AggregateDtaSanssthan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDtaSanssthan[P]>
      : GetScalarType<T[P], AggregateDtaSanssthan[P]>
  }




  export type DtaSanssthanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DtaSanssthanWhereInput
    orderBy?: DtaSanssthanOrderByWithAggregationInput | DtaSanssthanOrderByWithAggregationInput[]
    by: DtaSanssthanScalarFieldEnum[] | DtaSanssthanScalarFieldEnum
    having?: DtaSanssthanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DtaSanssthanCountAggregateInputType | true
    _avg?: DtaSanssthanAvgAggregateInputType
    _sum?: DtaSanssthanSumAggregateInputType
    _min?: DtaSanssthanMinAggregateInputType
    _max?: DtaSanssthanMaxAggregateInputType
  }

  export type DtaSanssthanGroupByOutputType = {
    id: number
    name: string
    person: string | null
    image: string | null
    description: string | null
    email: string | null
    phone: string | null
    altPhone: string | null
    website: string | null
    timing: string | null
    createdAt: Date
    updatedAt: Date
    _count: DtaSanssthanCountAggregateOutputType | null
    _avg: DtaSanssthanAvgAggregateOutputType | null
    _sum: DtaSanssthanSumAggregateOutputType | null
    _min: DtaSanssthanMinAggregateOutputType | null
    _max: DtaSanssthanMaxAggregateOutputType | null
  }

  type GetDtaSanssthanGroupByPayload<T extends DtaSanssthanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DtaSanssthanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DtaSanssthanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DtaSanssthanGroupByOutputType[P]>
            : GetScalarType<T[P], DtaSanssthanGroupByOutputType[P]>
        }
      >
    >


  export type DtaSanssthanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    person?: boolean
    image?: boolean
    description?: boolean
    email?: boolean
    phone?: boolean
    altPhone?: boolean
    website?: boolean
    timing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dtaSanssthan"]>



  export type DtaSanssthanSelectScalar = {
    id?: boolean
    name?: boolean
    person?: boolean
    image?: boolean
    description?: boolean
    email?: boolean
    phone?: boolean
    altPhone?: boolean
    website?: boolean
    timing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DtaSanssthanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "person" | "image" | "description" | "email" | "phone" | "altPhone" | "website" | "timing" | "createdAt" | "updatedAt", ExtArgs["result"]["dtaSanssthan"]>

  export type $DtaSanssthanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DtaSanssthan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      person: string | null
      image: string | null
      description: string | null
      email: string | null
      phone: string | null
      altPhone: string | null
      website: string | null
      timing: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dtaSanssthan"]>
    composites: {}
  }

  type DtaSanssthanGetPayload<S extends boolean | null | undefined | DtaSanssthanDefaultArgs> = $Result.GetResult<Prisma.$DtaSanssthanPayload, S>

  type DtaSanssthanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DtaSanssthanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DtaSanssthanCountAggregateInputType | true
    }

  export interface DtaSanssthanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DtaSanssthan'], meta: { name: 'DtaSanssthan' } }
    /**
     * Find zero or one DtaSanssthan that matches the filter.
     * @param {DtaSanssthanFindUniqueArgs} args - Arguments to find a DtaSanssthan
     * @example
     * // Get one DtaSanssthan
     * const dtaSanssthan = await prisma.dtaSanssthan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DtaSanssthanFindUniqueArgs>(args: SelectSubset<T, DtaSanssthanFindUniqueArgs<ExtArgs>>): Prisma__DtaSanssthanClient<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DtaSanssthan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DtaSanssthanFindUniqueOrThrowArgs} args - Arguments to find a DtaSanssthan
     * @example
     * // Get one DtaSanssthan
     * const dtaSanssthan = await prisma.dtaSanssthan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DtaSanssthanFindUniqueOrThrowArgs>(args: SelectSubset<T, DtaSanssthanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DtaSanssthanClient<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DtaSanssthan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DtaSanssthanFindFirstArgs} args - Arguments to find a DtaSanssthan
     * @example
     * // Get one DtaSanssthan
     * const dtaSanssthan = await prisma.dtaSanssthan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DtaSanssthanFindFirstArgs>(args?: SelectSubset<T, DtaSanssthanFindFirstArgs<ExtArgs>>): Prisma__DtaSanssthanClient<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DtaSanssthan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DtaSanssthanFindFirstOrThrowArgs} args - Arguments to find a DtaSanssthan
     * @example
     * // Get one DtaSanssthan
     * const dtaSanssthan = await prisma.dtaSanssthan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DtaSanssthanFindFirstOrThrowArgs>(args?: SelectSubset<T, DtaSanssthanFindFirstOrThrowArgs<ExtArgs>>): Prisma__DtaSanssthanClient<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DtaSanssthans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DtaSanssthanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DtaSanssthans
     * const dtaSanssthans = await prisma.dtaSanssthan.findMany()
     * 
     * // Get first 10 DtaSanssthans
     * const dtaSanssthans = await prisma.dtaSanssthan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dtaSanssthanWithIdOnly = await prisma.dtaSanssthan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DtaSanssthanFindManyArgs>(args?: SelectSubset<T, DtaSanssthanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DtaSanssthan.
     * @param {DtaSanssthanCreateArgs} args - Arguments to create a DtaSanssthan.
     * @example
     * // Create one DtaSanssthan
     * const DtaSanssthan = await prisma.dtaSanssthan.create({
     *   data: {
     *     // ... data to create a DtaSanssthan
     *   }
     * })
     * 
     */
    create<T extends DtaSanssthanCreateArgs>(args: SelectSubset<T, DtaSanssthanCreateArgs<ExtArgs>>): Prisma__DtaSanssthanClient<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DtaSanssthans.
     * @param {DtaSanssthanCreateManyArgs} args - Arguments to create many DtaSanssthans.
     * @example
     * // Create many DtaSanssthans
     * const dtaSanssthan = await prisma.dtaSanssthan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DtaSanssthanCreateManyArgs>(args?: SelectSubset<T, DtaSanssthanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DtaSanssthan.
     * @param {DtaSanssthanDeleteArgs} args - Arguments to delete one DtaSanssthan.
     * @example
     * // Delete one DtaSanssthan
     * const DtaSanssthan = await prisma.dtaSanssthan.delete({
     *   where: {
     *     // ... filter to delete one DtaSanssthan
     *   }
     * })
     * 
     */
    delete<T extends DtaSanssthanDeleteArgs>(args: SelectSubset<T, DtaSanssthanDeleteArgs<ExtArgs>>): Prisma__DtaSanssthanClient<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DtaSanssthan.
     * @param {DtaSanssthanUpdateArgs} args - Arguments to update one DtaSanssthan.
     * @example
     * // Update one DtaSanssthan
     * const dtaSanssthan = await prisma.dtaSanssthan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DtaSanssthanUpdateArgs>(args: SelectSubset<T, DtaSanssthanUpdateArgs<ExtArgs>>): Prisma__DtaSanssthanClient<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DtaSanssthans.
     * @param {DtaSanssthanDeleteManyArgs} args - Arguments to filter DtaSanssthans to delete.
     * @example
     * // Delete a few DtaSanssthans
     * const { count } = await prisma.dtaSanssthan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DtaSanssthanDeleteManyArgs>(args?: SelectSubset<T, DtaSanssthanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DtaSanssthans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DtaSanssthanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DtaSanssthans
     * const dtaSanssthan = await prisma.dtaSanssthan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DtaSanssthanUpdateManyArgs>(args: SelectSubset<T, DtaSanssthanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DtaSanssthan.
     * @param {DtaSanssthanUpsertArgs} args - Arguments to update or create a DtaSanssthan.
     * @example
     * // Update or create a DtaSanssthan
     * const dtaSanssthan = await prisma.dtaSanssthan.upsert({
     *   create: {
     *     // ... data to create a DtaSanssthan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DtaSanssthan we want to update
     *   }
     * })
     */
    upsert<T extends DtaSanssthanUpsertArgs>(args: SelectSubset<T, DtaSanssthanUpsertArgs<ExtArgs>>): Prisma__DtaSanssthanClient<$Result.GetResult<Prisma.$DtaSanssthanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DtaSanssthans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DtaSanssthanCountArgs} args - Arguments to filter DtaSanssthans to count.
     * @example
     * // Count the number of DtaSanssthans
     * const count = await prisma.dtaSanssthan.count({
     *   where: {
     *     // ... the filter for the DtaSanssthans we want to count
     *   }
     * })
    **/
    count<T extends DtaSanssthanCountArgs>(
      args?: Subset<T, DtaSanssthanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DtaSanssthanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DtaSanssthan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DtaSanssthanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DtaSanssthanAggregateArgs>(args: Subset<T, DtaSanssthanAggregateArgs>): Prisma.PrismaPromise<GetDtaSanssthanAggregateType<T>>

    /**
     * Group by DtaSanssthan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DtaSanssthanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DtaSanssthanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DtaSanssthanGroupByArgs['orderBy'] }
        : { orderBy?: DtaSanssthanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DtaSanssthanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDtaSanssthanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DtaSanssthan model
   */
  readonly fields: DtaSanssthanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DtaSanssthan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DtaSanssthanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DtaSanssthan model
   */
  interface DtaSanssthanFieldRefs {
    readonly id: FieldRef<"DtaSanssthan", 'Int'>
    readonly name: FieldRef<"DtaSanssthan", 'String'>
    readonly person: FieldRef<"DtaSanssthan", 'String'>
    readonly image: FieldRef<"DtaSanssthan", 'String'>
    readonly description: FieldRef<"DtaSanssthan", 'String'>
    readonly email: FieldRef<"DtaSanssthan", 'String'>
    readonly phone: FieldRef<"DtaSanssthan", 'String'>
    readonly altPhone: FieldRef<"DtaSanssthan", 'String'>
    readonly website: FieldRef<"DtaSanssthan", 'String'>
    readonly timing: FieldRef<"DtaSanssthan", 'String'>
    readonly createdAt: FieldRef<"DtaSanssthan", 'DateTime'>
    readonly updatedAt: FieldRef<"DtaSanssthan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DtaSanssthan findUnique
   */
  export type DtaSanssthanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * Filter, which DtaSanssthan to fetch.
     */
    where: DtaSanssthanWhereUniqueInput
  }

  /**
   * DtaSanssthan findUniqueOrThrow
   */
  export type DtaSanssthanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * Filter, which DtaSanssthan to fetch.
     */
    where: DtaSanssthanWhereUniqueInput
  }

  /**
   * DtaSanssthan findFirst
   */
  export type DtaSanssthanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * Filter, which DtaSanssthan to fetch.
     */
    where?: DtaSanssthanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DtaSanssthans to fetch.
     */
    orderBy?: DtaSanssthanOrderByWithRelationInput | DtaSanssthanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DtaSanssthans.
     */
    cursor?: DtaSanssthanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DtaSanssthans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DtaSanssthans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DtaSanssthans.
     */
    distinct?: DtaSanssthanScalarFieldEnum | DtaSanssthanScalarFieldEnum[]
  }

  /**
   * DtaSanssthan findFirstOrThrow
   */
  export type DtaSanssthanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * Filter, which DtaSanssthan to fetch.
     */
    where?: DtaSanssthanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DtaSanssthans to fetch.
     */
    orderBy?: DtaSanssthanOrderByWithRelationInput | DtaSanssthanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DtaSanssthans.
     */
    cursor?: DtaSanssthanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DtaSanssthans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DtaSanssthans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DtaSanssthans.
     */
    distinct?: DtaSanssthanScalarFieldEnum | DtaSanssthanScalarFieldEnum[]
  }

  /**
   * DtaSanssthan findMany
   */
  export type DtaSanssthanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * Filter, which DtaSanssthans to fetch.
     */
    where?: DtaSanssthanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DtaSanssthans to fetch.
     */
    orderBy?: DtaSanssthanOrderByWithRelationInput | DtaSanssthanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DtaSanssthans.
     */
    cursor?: DtaSanssthanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DtaSanssthans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DtaSanssthans.
     */
    skip?: number
    distinct?: DtaSanssthanScalarFieldEnum | DtaSanssthanScalarFieldEnum[]
  }

  /**
   * DtaSanssthan create
   */
  export type DtaSanssthanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * The data needed to create a DtaSanssthan.
     */
    data: XOR<DtaSanssthanCreateInput, DtaSanssthanUncheckedCreateInput>
  }

  /**
   * DtaSanssthan createMany
   */
  export type DtaSanssthanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DtaSanssthans.
     */
    data: DtaSanssthanCreateManyInput | DtaSanssthanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DtaSanssthan update
   */
  export type DtaSanssthanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * The data needed to update a DtaSanssthan.
     */
    data: XOR<DtaSanssthanUpdateInput, DtaSanssthanUncheckedUpdateInput>
    /**
     * Choose, which DtaSanssthan to update.
     */
    where: DtaSanssthanWhereUniqueInput
  }

  /**
   * DtaSanssthan updateMany
   */
  export type DtaSanssthanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DtaSanssthans.
     */
    data: XOR<DtaSanssthanUpdateManyMutationInput, DtaSanssthanUncheckedUpdateManyInput>
    /**
     * Filter which DtaSanssthans to update
     */
    where?: DtaSanssthanWhereInput
    /**
     * Limit how many DtaSanssthans to update.
     */
    limit?: number
  }

  /**
   * DtaSanssthan upsert
   */
  export type DtaSanssthanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * The filter to search for the DtaSanssthan to update in case it exists.
     */
    where: DtaSanssthanWhereUniqueInput
    /**
     * In case the DtaSanssthan found by the `where` argument doesn't exist, create a new DtaSanssthan with this data.
     */
    create: XOR<DtaSanssthanCreateInput, DtaSanssthanUncheckedCreateInput>
    /**
     * In case the DtaSanssthan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DtaSanssthanUpdateInput, DtaSanssthanUncheckedUpdateInput>
  }

  /**
   * DtaSanssthan delete
   */
  export type DtaSanssthanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
    /**
     * Filter which DtaSanssthan to delete.
     */
    where: DtaSanssthanWhereUniqueInput
  }

  /**
   * DtaSanssthan deleteMany
   */
  export type DtaSanssthanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DtaSanssthans to delete
     */
    where?: DtaSanssthanWhereInput
    /**
     * Limit how many DtaSanssthans to delete.
     */
    limit?: number
  }

  /**
   * DtaSanssthan without action
   */
  export type DtaSanssthanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DtaSanssthan
     */
    select?: DtaSanssthanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DtaSanssthan
     */
    omit?: DtaSanssthanOmit<ExtArgs> | null
  }


  /**
   * Model PrivacyPolicy
   */

  export type AggregatePrivacyPolicy = {
    _count: PrivacyPolicyCountAggregateOutputType | null
    _avg: PrivacyPolicyAvgAggregateOutputType | null
    _sum: PrivacyPolicySumAggregateOutputType | null
    _min: PrivacyPolicyMinAggregateOutputType | null
    _max: PrivacyPolicyMaxAggregateOutputType | null
  }

  export type PrivacyPolicyAvgAggregateOutputType = {
    id: number | null
  }

  export type PrivacyPolicySumAggregateOutputType = {
    id: number | null
  }

  export type PrivacyPolicyMinAggregateOutputType = {
    id: number | null
    title: string | null
    subtitle: string | null
    email: string | null
    phone: string | null
    callingHours: string | null
    mailingAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivacyPolicyMaxAggregateOutputType = {
    id: number | null
    title: string | null
    subtitle: string | null
    email: string | null
    phone: string | null
    callingHours: string | null
    mailingAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivacyPolicyCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    sections: number
    email: number
    phone: number
    callingHours: number
    mailingAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PrivacyPolicyAvgAggregateInputType = {
    id?: true
  }

  export type PrivacyPolicySumAggregateInputType = {
    id?: true
  }

  export type PrivacyPolicyMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    email?: true
    phone?: true
    callingHours?: true
    mailingAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivacyPolicyMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    email?: true
    phone?: true
    callingHours?: true
    mailingAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivacyPolicyCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    sections?: true
    email?: true
    phone?: true
    callingHours?: true
    mailingAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PrivacyPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivacyPolicy to aggregate.
     */
    where?: PrivacyPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyPolicies to fetch.
     */
    orderBy?: PrivacyPolicyOrderByWithRelationInput | PrivacyPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrivacyPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrivacyPolicies
    **/
    _count?: true | PrivacyPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrivacyPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrivacyPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivacyPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivacyPolicyMaxAggregateInputType
  }

  export type GetPrivacyPolicyAggregateType<T extends PrivacyPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivacyPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivacyPolicy[P]>
      : GetScalarType<T[P], AggregatePrivacyPolicy[P]>
  }




  export type PrivacyPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivacyPolicyWhereInput
    orderBy?: PrivacyPolicyOrderByWithAggregationInput | PrivacyPolicyOrderByWithAggregationInput[]
    by: PrivacyPolicyScalarFieldEnum[] | PrivacyPolicyScalarFieldEnum
    having?: PrivacyPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivacyPolicyCountAggregateInputType | true
    _avg?: PrivacyPolicyAvgAggregateInputType
    _sum?: PrivacyPolicySumAggregateInputType
    _min?: PrivacyPolicyMinAggregateInputType
    _max?: PrivacyPolicyMaxAggregateInputType
  }

  export type PrivacyPolicyGroupByOutputType = {
    id: number
    title: string
    subtitle: string | null
    sections: JsonValue
    email: string | null
    phone: string | null
    callingHours: string | null
    mailingAddress: string | null
    createdAt: Date
    updatedAt: Date
    _count: PrivacyPolicyCountAggregateOutputType | null
    _avg: PrivacyPolicyAvgAggregateOutputType | null
    _sum: PrivacyPolicySumAggregateOutputType | null
    _min: PrivacyPolicyMinAggregateOutputType | null
    _max: PrivacyPolicyMaxAggregateOutputType | null
  }

  type GetPrivacyPolicyGroupByPayload<T extends PrivacyPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivacyPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivacyPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivacyPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PrivacyPolicyGroupByOutputType[P]>
        }
      >
    >


  export type PrivacyPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    sections?: boolean
    email?: boolean
    phone?: boolean
    callingHours?: boolean
    mailingAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["privacyPolicy"]>



  export type PrivacyPolicySelectScalar = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    sections?: boolean
    email?: boolean
    phone?: boolean
    callingHours?: boolean
    mailingAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PrivacyPolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "subtitle" | "sections" | "email" | "phone" | "callingHours" | "mailingAddress" | "createdAt" | "updatedAt", ExtArgs["result"]["privacyPolicy"]>

  export type $PrivacyPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrivacyPolicy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      subtitle: string | null
      sections: Prisma.JsonValue
      email: string | null
      phone: string | null
      callingHours: string | null
      mailingAddress: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["privacyPolicy"]>
    composites: {}
  }

  type PrivacyPolicyGetPayload<S extends boolean | null | undefined | PrivacyPolicyDefaultArgs> = $Result.GetResult<Prisma.$PrivacyPolicyPayload, S>

  type PrivacyPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrivacyPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrivacyPolicyCountAggregateInputType | true
    }

  export interface PrivacyPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrivacyPolicy'], meta: { name: 'PrivacyPolicy' } }
    /**
     * Find zero or one PrivacyPolicy that matches the filter.
     * @param {PrivacyPolicyFindUniqueArgs} args - Arguments to find a PrivacyPolicy
     * @example
     * // Get one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrivacyPolicyFindUniqueArgs>(args: SelectSubset<T, PrivacyPolicyFindUniqueArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrivacyPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrivacyPolicyFindUniqueOrThrowArgs} args - Arguments to find a PrivacyPolicy
     * @example
     * // Get one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrivacyPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, PrivacyPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivacyPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyFindFirstArgs} args - Arguments to find a PrivacyPolicy
     * @example
     * // Get one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrivacyPolicyFindFirstArgs>(args?: SelectSubset<T, PrivacyPolicyFindFirstArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivacyPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyFindFirstOrThrowArgs} args - Arguments to find a PrivacyPolicy
     * @example
     * // Get one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrivacyPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, PrivacyPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrivacyPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrivacyPolicies
     * const privacyPolicies = await prisma.privacyPolicy.findMany()
     * 
     * // Get first 10 PrivacyPolicies
     * const privacyPolicies = await prisma.privacyPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privacyPolicyWithIdOnly = await prisma.privacyPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrivacyPolicyFindManyArgs>(args?: SelectSubset<T, PrivacyPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrivacyPolicy.
     * @param {PrivacyPolicyCreateArgs} args - Arguments to create a PrivacyPolicy.
     * @example
     * // Create one PrivacyPolicy
     * const PrivacyPolicy = await prisma.privacyPolicy.create({
     *   data: {
     *     // ... data to create a PrivacyPolicy
     *   }
     * })
     * 
     */
    create<T extends PrivacyPolicyCreateArgs>(args: SelectSubset<T, PrivacyPolicyCreateArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrivacyPolicies.
     * @param {PrivacyPolicyCreateManyArgs} args - Arguments to create many PrivacyPolicies.
     * @example
     * // Create many PrivacyPolicies
     * const privacyPolicy = await prisma.privacyPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrivacyPolicyCreateManyArgs>(args?: SelectSubset<T, PrivacyPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PrivacyPolicy.
     * @param {PrivacyPolicyDeleteArgs} args - Arguments to delete one PrivacyPolicy.
     * @example
     * // Delete one PrivacyPolicy
     * const PrivacyPolicy = await prisma.privacyPolicy.delete({
     *   where: {
     *     // ... filter to delete one PrivacyPolicy
     *   }
     * })
     * 
     */
    delete<T extends PrivacyPolicyDeleteArgs>(args: SelectSubset<T, PrivacyPolicyDeleteArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrivacyPolicy.
     * @param {PrivacyPolicyUpdateArgs} args - Arguments to update one PrivacyPolicy.
     * @example
     * // Update one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrivacyPolicyUpdateArgs>(args: SelectSubset<T, PrivacyPolicyUpdateArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrivacyPolicies.
     * @param {PrivacyPolicyDeleteManyArgs} args - Arguments to filter PrivacyPolicies to delete.
     * @example
     * // Delete a few PrivacyPolicies
     * const { count } = await prisma.privacyPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrivacyPolicyDeleteManyArgs>(args?: SelectSubset<T, PrivacyPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivacyPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrivacyPolicies
     * const privacyPolicy = await prisma.privacyPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrivacyPolicyUpdateManyArgs>(args: SelectSubset<T, PrivacyPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrivacyPolicy.
     * @param {PrivacyPolicyUpsertArgs} args - Arguments to update or create a PrivacyPolicy.
     * @example
     * // Update or create a PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.upsert({
     *   create: {
     *     // ... data to create a PrivacyPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrivacyPolicy we want to update
     *   }
     * })
     */
    upsert<T extends PrivacyPolicyUpsertArgs>(args: SelectSubset<T, PrivacyPolicyUpsertArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrivacyPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyCountArgs} args - Arguments to filter PrivacyPolicies to count.
     * @example
     * // Count the number of PrivacyPolicies
     * const count = await prisma.privacyPolicy.count({
     *   where: {
     *     // ... the filter for the PrivacyPolicies we want to count
     *   }
     * })
    **/
    count<T extends PrivacyPolicyCountArgs>(
      args?: Subset<T, PrivacyPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivacyPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrivacyPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivacyPolicyAggregateArgs>(args: Subset<T, PrivacyPolicyAggregateArgs>): Prisma.PrismaPromise<GetPrivacyPolicyAggregateType<T>>

    /**
     * Group by PrivacyPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrivacyPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrivacyPolicyGroupByArgs['orderBy'] }
        : { orderBy?: PrivacyPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrivacyPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivacyPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrivacyPolicy model
   */
  readonly fields: PrivacyPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrivacyPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrivacyPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrivacyPolicy model
   */
  interface PrivacyPolicyFieldRefs {
    readonly id: FieldRef<"PrivacyPolicy", 'Int'>
    readonly title: FieldRef<"PrivacyPolicy", 'String'>
    readonly subtitle: FieldRef<"PrivacyPolicy", 'String'>
    readonly sections: FieldRef<"PrivacyPolicy", 'Json'>
    readonly email: FieldRef<"PrivacyPolicy", 'String'>
    readonly phone: FieldRef<"PrivacyPolicy", 'String'>
    readonly callingHours: FieldRef<"PrivacyPolicy", 'String'>
    readonly mailingAddress: FieldRef<"PrivacyPolicy", 'String'>
    readonly createdAt: FieldRef<"PrivacyPolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"PrivacyPolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrivacyPolicy findUnique
   */
  export type PrivacyPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicy to fetch.
     */
    where: PrivacyPolicyWhereUniqueInput
  }

  /**
   * PrivacyPolicy findUniqueOrThrow
   */
  export type PrivacyPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicy to fetch.
     */
    where: PrivacyPolicyWhereUniqueInput
  }

  /**
   * PrivacyPolicy findFirst
   */
  export type PrivacyPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicy to fetch.
     */
    where?: PrivacyPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyPolicies to fetch.
     */
    orderBy?: PrivacyPolicyOrderByWithRelationInput | PrivacyPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivacyPolicies.
     */
    cursor?: PrivacyPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivacyPolicies.
     */
    distinct?: PrivacyPolicyScalarFieldEnum | PrivacyPolicyScalarFieldEnum[]
  }

  /**
   * PrivacyPolicy findFirstOrThrow
   */
  export type PrivacyPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicy to fetch.
     */
    where?: PrivacyPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyPolicies to fetch.
     */
    orderBy?: PrivacyPolicyOrderByWithRelationInput | PrivacyPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivacyPolicies.
     */
    cursor?: PrivacyPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivacyPolicies.
     */
    distinct?: PrivacyPolicyScalarFieldEnum | PrivacyPolicyScalarFieldEnum[]
  }

  /**
   * PrivacyPolicy findMany
   */
  export type PrivacyPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicies to fetch.
     */
    where?: PrivacyPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyPolicies to fetch.
     */
    orderBy?: PrivacyPolicyOrderByWithRelationInput | PrivacyPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrivacyPolicies.
     */
    cursor?: PrivacyPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyPolicies.
     */
    skip?: number
    distinct?: PrivacyPolicyScalarFieldEnum | PrivacyPolicyScalarFieldEnum[]
  }

  /**
   * PrivacyPolicy create
   */
  export type PrivacyPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * The data needed to create a PrivacyPolicy.
     */
    data: XOR<PrivacyPolicyCreateInput, PrivacyPolicyUncheckedCreateInput>
  }

  /**
   * PrivacyPolicy createMany
   */
  export type PrivacyPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrivacyPolicies.
     */
    data: PrivacyPolicyCreateManyInput | PrivacyPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrivacyPolicy update
   */
  export type PrivacyPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * The data needed to update a PrivacyPolicy.
     */
    data: XOR<PrivacyPolicyUpdateInput, PrivacyPolicyUncheckedUpdateInput>
    /**
     * Choose, which PrivacyPolicy to update.
     */
    where: PrivacyPolicyWhereUniqueInput
  }

  /**
   * PrivacyPolicy updateMany
   */
  export type PrivacyPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrivacyPolicies.
     */
    data: XOR<PrivacyPolicyUpdateManyMutationInput, PrivacyPolicyUncheckedUpdateManyInput>
    /**
     * Filter which PrivacyPolicies to update
     */
    where?: PrivacyPolicyWhereInput
    /**
     * Limit how many PrivacyPolicies to update.
     */
    limit?: number
  }

  /**
   * PrivacyPolicy upsert
   */
  export type PrivacyPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * The filter to search for the PrivacyPolicy to update in case it exists.
     */
    where: PrivacyPolicyWhereUniqueInput
    /**
     * In case the PrivacyPolicy found by the `where` argument doesn't exist, create a new PrivacyPolicy with this data.
     */
    create: XOR<PrivacyPolicyCreateInput, PrivacyPolicyUncheckedCreateInput>
    /**
     * In case the PrivacyPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrivacyPolicyUpdateInput, PrivacyPolicyUncheckedUpdateInput>
  }

  /**
   * PrivacyPolicy delete
   */
  export type PrivacyPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter which PrivacyPolicy to delete.
     */
    where: PrivacyPolicyWhereUniqueInput
  }

  /**
   * PrivacyPolicy deleteMany
   */
  export type PrivacyPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivacyPolicies to delete
     */
    where?: PrivacyPolicyWhereInput
    /**
     * Limit how many PrivacyPolicies to delete.
     */
    limit?: number
  }

  /**
   * PrivacyPolicy without action
   */
  export type PrivacyPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
  }


  /**
   * Model TermsConditions
   */

  export type AggregateTermsConditions = {
    _count: TermsConditionsCountAggregateOutputType | null
    _avg: TermsConditionsAvgAggregateOutputType | null
    _sum: TermsConditionsSumAggregateOutputType | null
    _min: TermsConditionsMinAggregateOutputType | null
    _max: TermsConditionsMaxAggregateOutputType | null
  }

  export type TermsConditionsAvgAggregateOutputType = {
    id: number | null
  }

  export type TermsConditionsSumAggregateOutputType = {
    id: number | null
  }

  export type TermsConditionsMinAggregateOutputType = {
    id: number | null
    title: string | null
    subtitle: string | null
    email: string | null
    phone: string | null
    callingHours: string | null
    mailingAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TermsConditionsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    subtitle: string | null
    email: string | null
    phone: string | null
    callingHours: string | null
    mailingAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TermsConditionsCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    sections: number
    email: number
    phone: number
    callingHours: number
    mailingAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TermsConditionsAvgAggregateInputType = {
    id?: true
  }

  export type TermsConditionsSumAggregateInputType = {
    id?: true
  }

  export type TermsConditionsMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    email?: true
    phone?: true
    callingHours?: true
    mailingAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TermsConditionsMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    email?: true
    phone?: true
    callingHours?: true
    mailingAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TermsConditionsCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    sections?: true
    email?: true
    phone?: true
    callingHours?: true
    mailingAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TermsConditionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TermsConditions to aggregate.
     */
    where?: TermsConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermsConditions to fetch.
     */
    orderBy?: TermsConditionsOrderByWithRelationInput | TermsConditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TermsConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermsConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermsConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TermsConditions
    **/
    _count?: true | TermsConditionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TermsConditionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TermsConditionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TermsConditionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TermsConditionsMaxAggregateInputType
  }

  export type GetTermsConditionsAggregateType<T extends TermsConditionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTermsConditions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTermsConditions[P]>
      : GetScalarType<T[P], AggregateTermsConditions[P]>
  }




  export type TermsConditionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TermsConditionsWhereInput
    orderBy?: TermsConditionsOrderByWithAggregationInput | TermsConditionsOrderByWithAggregationInput[]
    by: TermsConditionsScalarFieldEnum[] | TermsConditionsScalarFieldEnum
    having?: TermsConditionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TermsConditionsCountAggregateInputType | true
    _avg?: TermsConditionsAvgAggregateInputType
    _sum?: TermsConditionsSumAggregateInputType
    _min?: TermsConditionsMinAggregateInputType
    _max?: TermsConditionsMaxAggregateInputType
  }

  export type TermsConditionsGroupByOutputType = {
    id: number
    title: string
    subtitle: string | null
    sections: JsonValue
    email: string | null
    phone: string | null
    callingHours: string | null
    mailingAddress: string | null
    createdAt: Date
    updatedAt: Date
    _count: TermsConditionsCountAggregateOutputType | null
    _avg: TermsConditionsAvgAggregateOutputType | null
    _sum: TermsConditionsSumAggregateOutputType | null
    _min: TermsConditionsMinAggregateOutputType | null
    _max: TermsConditionsMaxAggregateOutputType | null
  }

  type GetTermsConditionsGroupByPayload<T extends TermsConditionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TermsConditionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TermsConditionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TermsConditionsGroupByOutputType[P]>
            : GetScalarType<T[P], TermsConditionsGroupByOutputType[P]>
        }
      >
    >


  export type TermsConditionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    sections?: boolean
    email?: boolean
    phone?: boolean
    callingHours?: boolean
    mailingAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["termsConditions"]>



  export type TermsConditionsSelectScalar = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    sections?: boolean
    email?: boolean
    phone?: boolean
    callingHours?: boolean
    mailingAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TermsConditionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "subtitle" | "sections" | "email" | "phone" | "callingHours" | "mailingAddress" | "createdAt" | "updatedAt", ExtArgs["result"]["termsConditions"]>

  export type $TermsConditionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TermsConditions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      subtitle: string | null
      sections: Prisma.JsonValue
      email: string | null
      phone: string | null
      callingHours: string | null
      mailingAddress: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["termsConditions"]>
    composites: {}
  }

  type TermsConditionsGetPayload<S extends boolean | null | undefined | TermsConditionsDefaultArgs> = $Result.GetResult<Prisma.$TermsConditionsPayload, S>

  type TermsConditionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TermsConditionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TermsConditionsCountAggregateInputType | true
    }

  export interface TermsConditionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TermsConditions'], meta: { name: 'TermsConditions' } }
    /**
     * Find zero or one TermsConditions that matches the filter.
     * @param {TermsConditionsFindUniqueArgs} args - Arguments to find a TermsConditions
     * @example
     * // Get one TermsConditions
     * const termsConditions = await prisma.termsConditions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TermsConditionsFindUniqueArgs>(args: SelectSubset<T, TermsConditionsFindUniqueArgs<ExtArgs>>): Prisma__TermsConditionsClient<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TermsConditions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TermsConditionsFindUniqueOrThrowArgs} args - Arguments to find a TermsConditions
     * @example
     * // Get one TermsConditions
     * const termsConditions = await prisma.termsConditions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TermsConditionsFindUniqueOrThrowArgs>(args: SelectSubset<T, TermsConditionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TermsConditionsClient<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TermsConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionsFindFirstArgs} args - Arguments to find a TermsConditions
     * @example
     * // Get one TermsConditions
     * const termsConditions = await prisma.termsConditions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TermsConditionsFindFirstArgs>(args?: SelectSubset<T, TermsConditionsFindFirstArgs<ExtArgs>>): Prisma__TermsConditionsClient<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TermsConditions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionsFindFirstOrThrowArgs} args - Arguments to find a TermsConditions
     * @example
     * // Get one TermsConditions
     * const termsConditions = await prisma.termsConditions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TermsConditionsFindFirstOrThrowArgs>(args?: SelectSubset<T, TermsConditionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TermsConditionsClient<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TermsConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TermsConditions
     * const termsConditions = await prisma.termsConditions.findMany()
     * 
     * // Get first 10 TermsConditions
     * const termsConditions = await prisma.termsConditions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const termsConditionsWithIdOnly = await prisma.termsConditions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TermsConditionsFindManyArgs>(args?: SelectSubset<T, TermsConditionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TermsConditions.
     * @param {TermsConditionsCreateArgs} args - Arguments to create a TermsConditions.
     * @example
     * // Create one TermsConditions
     * const TermsConditions = await prisma.termsConditions.create({
     *   data: {
     *     // ... data to create a TermsConditions
     *   }
     * })
     * 
     */
    create<T extends TermsConditionsCreateArgs>(args: SelectSubset<T, TermsConditionsCreateArgs<ExtArgs>>): Prisma__TermsConditionsClient<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TermsConditions.
     * @param {TermsConditionsCreateManyArgs} args - Arguments to create many TermsConditions.
     * @example
     * // Create many TermsConditions
     * const termsConditions = await prisma.termsConditions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TermsConditionsCreateManyArgs>(args?: SelectSubset<T, TermsConditionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TermsConditions.
     * @param {TermsConditionsDeleteArgs} args - Arguments to delete one TermsConditions.
     * @example
     * // Delete one TermsConditions
     * const TermsConditions = await prisma.termsConditions.delete({
     *   where: {
     *     // ... filter to delete one TermsConditions
     *   }
     * })
     * 
     */
    delete<T extends TermsConditionsDeleteArgs>(args: SelectSubset<T, TermsConditionsDeleteArgs<ExtArgs>>): Prisma__TermsConditionsClient<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TermsConditions.
     * @param {TermsConditionsUpdateArgs} args - Arguments to update one TermsConditions.
     * @example
     * // Update one TermsConditions
     * const termsConditions = await prisma.termsConditions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TermsConditionsUpdateArgs>(args: SelectSubset<T, TermsConditionsUpdateArgs<ExtArgs>>): Prisma__TermsConditionsClient<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TermsConditions.
     * @param {TermsConditionsDeleteManyArgs} args - Arguments to filter TermsConditions to delete.
     * @example
     * // Delete a few TermsConditions
     * const { count } = await prisma.termsConditions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TermsConditionsDeleteManyArgs>(args?: SelectSubset<T, TermsConditionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TermsConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TermsConditions
     * const termsConditions = await prisma.termsConditions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TermsConditionsUpdateManyArgs>(args: SelectSubset<T, TermsConditionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TermsConditions.
     * @param {TermsConditionsUpsertArgs} args - Arguments to update or create a TermsConditions.
     * @example
     * // Update or create a TermsConditions
     * const termsConditions = await prisma.termsConditions.upsert({
     *   create: {
     *     // ... data to create a TermsConditions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TermsConditions we want to update
     *   }
     * })
     */
    upsert<T extends TermsConditionsUpsertArgs>(args: SelectSubset<T, TermsConditionsUpsertArgs<ExtArgs>>): Prisma__TermsConditionsClient<$Result.GetResult<Prisma.$TermsConditionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TermsConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionsCountArgs} args - Arguments to filter TermsConditions to count.
     * @example
     * // Count the number of TermsConditions
     * const count = await prisma.termsConditions.count({
     *   where: {
     *     // ... the filter for the TermsConditions we want to count
     *   }
     * })
    **/
    count<T extends TermsConditionsCountArgs>(
      args?: Subset<T, TermsConditionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TermsConditionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TermsConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TermsConditionsAggregateArgs>(args: Subset<T, TermsConditionsAggregateArgs>): Prisma.PrismaPromise<GetTermsConditionsAggregateType<T>>

    /**
     * Group by TermsConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsConditionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TermsConditionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TermsConditionsGroupByArgs['orderBy'] }
        : { orderBy?: TermsConditionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TermsConditionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTermsConditionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TermsConditions model
   */
  readonly fields: TermsConditionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TermsConditions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TermsConditionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TermsConditions model
   */
  interface TermsConditionsFieldRefs {
    readonly id: FieldRef<"TermsConditions", 'Int'>
    readonly title: FieldRef<"TermsConditions", 'String'>
    readonly subtitle: FieldRef<"TermsConditions", 'String'>
    readonly sections: FieldRef<"TermsConditions", 'Json'>
    readonly email: FieldRef<"TermsConditions", 'String'>
    readonly phone: FieldRef<"TermsConditions", 'String'>
    readonly callingHours: FieldRef<"TermsConditions", 'String'>
    readonly mailingAddress: FieldRef<"TermsConditions", 'String'>
    readonly createdAt: FieldRef<"TermsConditions", 'DateTime'>
    readonly updatedAt: FieldRef<"TermsConditions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TermsConditions findUnique
   */
  export type TermsConditionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * Filter, which TermsConditions to fetch.
     */
    where: TermsConditionsWhereUniqueInput
  }

  /**
   * TermsConditions findUniqueOrThrow
   */
  export type TermsConditionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * Filter, which TermsConditions to fetch.
     */
    where: TermsConditionsWhereUniqueInput
  }

  /**
   * TermsConditions findFirst
   */
  export type TermsConditionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * Filter, which TermsConditions to fetch.
     */
    where?: TermsConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermsConditions to fetch.
     */
    orderBy?: TermsConditionsOrderByWithRelationInput | TermsConditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TermsConditions.
     */
    cursor?: TermsConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermsConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermsConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TermsConditions.
     */
    distinct?: TermsConditionsScalarFieldEnum | TermsConditionsScalarFieldEnum[]
  }

  /**
   * TermsConditions findFirstOrThrow
   */
  export type TermsConditionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * Filter, which TermsConditions to fetch.
     */
    where?: TermsConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermsConditions to fetch.
     */
    orderBy?: TermsConditionsOrderByWithRelationInput | TermsConditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TermsConditions.
     */
    cursor?: TermsConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermsConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermsConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TermsConditions.
     */
    distinct?: TermsConditionsScalarFieldEnum | TermsConditionsScalarFieldEnum[]
  }

  /**
   * TermsConditions findMany
   */
  export type TermsConditionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * Filter, which TermsConditions to fetch.
     */
    where?: TermsConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermsConditions to fetch.
     */
    orderBy?: TermsConditionsOrderByWithRelationInput | TermsConditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TermsConditions.
     */
    cursor?: TermsConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermsConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermsConditions.
     */
    skip?: number
    distinct?: TermsConditionsScalarFieldEnum | TermsConditionsScalarFieldEnum[]
  }

  /**
   * TermsConditions create
   */
  export type TermsConditionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * The data needed to create a TermsConditions.
     */
    data: XOR<TermsConditionsCreateInput, TermsConditionsUncheckedCreateInput>
  }

  /**
   * TermsConditions createMany
   */
  export type TermsConditionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TermsConditions.
     */
    data: TermsConditionsCreateManyInput | TermsConditionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TermsConditions update
   */
  export type TermsConditionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * The data needed to update a TermsConditions.
     */
    data: XOR<TermsConditionsUpdateInput, TermsConditionsUncheckedUpdateInput>
    /**
     * Choose, which TermsConditions to update.
     */
    where: TermsConditionsWhereUniqueInput
  }

  /**
   * TermsConditions updateMany
   */
  export type TermsConditionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TermsConditions.
     */
    data: XOR<TermsConditionsUpdateManyMutationInput, TermsConditionsUncheckedUpdateManyInput>
    /**
     * Filter which TermsConditions to update
     */
    where?: TermsConditionsWhereInput
    /**
     * Limit how many TermsConditions to update.
     */
    limit?: number
  }

  /**
   * TermsConditions upsert
   */
  export type TermsConditionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * The filter to search for the TermsConditions to update in case it exists.
     */
    where: TermsConditionsWhereUniqueInput
    /**
     * In case the TermsConditions found by the `where` argument doesn't exist, create a new TermsConditions with this data.
     */
    create: XOR<TermsConditionsCreateInput, TermsConditionsUncheckedCreateInput>
    /**
     * In case the TermsConditions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TermsConditionsUpdateInput, TermsConditionsUncheckedUpdateInput>
  }

  /**
   * TermsConditions delete
   */
  export type TermsConditionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
    /**
     * Filter which TermsConditions to delete.
     */
    where: TermsConditionsWhereUniqueInput
  }

  /**
   * TermsConditions deleteMany
   */
  export type TermsConditionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TermsConditions to delete
     */
    where?: TermsConditionsWhereInput
    /**
     * Limit how many TermsConditions to delete.
     */
    limit?: number
  }

  /**
   * TermsConditions without action
   */
  export type TermsConditionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsConditions
     */
    select?: TermsConditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsConditions
     */
    omit?: TermsConditionsOmit<ExtArgs> | null
  }


  /**
   * Model Banner
   */

  export type AggregateBanner = {
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  export type BannerAvgAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type BannerSumAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type BannerMinAggregateOutputType = {
    id: number | null
    title: string | null
    image: string | null
    active: boolean | null
    order: number | null
    publicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerMaxAggregateOutputType = {
    id: number | null
    title: string | null
    image: string | null
    active: boolean | null
    order: number | null
    publicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerCountAggregateOutputType = {
    id: number
    title: number
    image: number
    active: number
    order: number
    publicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BannerAvgAggregateInputType = {
    id?: true
    order?: true
  }

  export type BannerSumAggregateInputType = {
    id?: true
    order?: true
  }

  export type BannerMinAggregateInputType = {
    id?: true
    title?: true
    image?: true
    active?: true
    order?: true
    publicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerMaxAggregateInputType = {
    id?: true
    title?: true
    image?: true
    active?: true
    order?: true
    publicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerCountAggregateInputType = {
    id?: true
    title?: true
    image?: true
    active?: true
    order?: true
    publicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banner to aggregate.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banners
    **/
    _count?: true | BannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerMaxAggregateInputType
  }

  export type GetBannerAggregateType<T extends BannerAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner[P]>
      : GetScalarType<T[P], AggregateBanner[P]>
  }




  export type BannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithAggregationInput | BannerOrderByWithAggregationInput[]
    by: BannerScalarFieldEnum[] | BannerScalarFieldEnum
    having?: BannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerCountAggregateInputType | true
    _avg?: BannerAvgAggregateInputType
    _sum?: BannerSumAggregateInputType
    _min?: BannerMinAggregateInputType
    _max?: BannerMaxAggregateInputType
  }

  export type BannerGroupByOutputType = {
    id: number
    title: string
    image: string
    active: boolean
    order: number
    publicId: string
    createdAt: Date
    updatedAt: Date
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  type GetBannerGroupByPayload<T extends BannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerGroupByOutputType[P]>
            : GetScalarType<T[P], BannerGroupByOutputType[P]>
        }
      >
    >


  export type BannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    image?: boolean
    active?: boolean
    order?: boolean
    publicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["banner"]>



  export type BannerSelectScalar = {
    id?: boolean
    title?: boolean
    image?: boolean
    active?: boolean
    order?: boolean
    publicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BannerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "image" | "active" | "order" | "publicId" | "createdAt" | "updatedAt", ExtArgs["result"]["banner"]>

  export type $BannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Banner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      image: string
      active: boolean
      order: number
      publicId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["banner"]>
    composites: {}
  }

  type BannerGetPayload<S extends boolean | null | undefined | BannerDefaultArgs> = $Result.GetResult<Prisma.$BannerPayload, S>

  type BannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BannerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerCountAggregateInputType | true
    }

  export interface BannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Banner'], meta: { name: 'Banner' } }
    /**
     * Find zero or one Banner that matches the filter.
     * @param {BannerFindUniqueArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerFindUniqueArgs>(args: SelectSubset<T, BannerFindUniqueArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Banner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerFindUniqueOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerFindFirstArgs>(args?: SelectSubset<T, BannerFindFirstArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banner.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerWithIdOnly = await prisma.banner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerFindManyArgs>(args?: SelectSubset<T, BannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Banner.
     * @param {BannerCreateArgs} args - Arguments to create a Banner.
     * @example
     * // Create one Banner
     * const Banner = await prisma.banner.create({
     *   data: {
     *     // ... data to create a Banner
     *   }
     * })
     * 
     */
    create<T extends BannerCreateArgs>(args: SelectSubset<T, BannerCreateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Banners.
     * @param {BannerCreateManyArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerCreateManyArgs>(args?: SelectSubset<T, BannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Banner.
     * @param {BannerDeleteArgs} args - Arguments to delete one Banner.
     * @example
     * // Delete one Banner
     * const Banner = await prisma.banner.delete({
     *   where: {
     *     // ... filter to delete one Banner
     *   }
     * })
     * 
     */
    delete<T extends BannerDeleteArgs>(args: SelectSubset<T, BannerDeleteArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Banner.
     * @param {BannerUpdateArgs} args - Arguments to update one Banner.
     * @example
     * // Update one Banner
     * const banner = await prisma.banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerUpdateArgs>(args: SelectSubset<T, BannerUpdateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Banners.
     * @param {BannerDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerDeleteManyArgs>(args?: SelectSubset<T, BannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerUpdateManyArgs>(args: SelectSubset<T, BannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banner.
     * @param {BannerUpsertArgs} args - Arguments to update or create a Banner.
     * @example
     * // Update or create a Banner
     * const banner = await prisma.banner.upsert({
     *   create: {
     *     // ... data to create a Banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner we want to update
     *   }
     * })
     */
    upsert<T extends BannerUpsertArgs>(args: SelectSubset<T, BannerUpsertArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banner.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends BannerCountArgs>(
      args?: Subset<T, BannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerAggregateArgs>(args: Subset<T, BannerAggregateArgs>): Prisma.PrismaPromise<GetBannerAggregateType<T>>

    /**
     * Group by Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerGroupByArgs['orderBy'] }
        : { orderBy?: BannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Banner model
   */
  readonly fields: BannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Banner model
   */
  interface BannerFieldRefs {
    readonly id: FieldRef<"Banner", 'Int'>
    readonly title: FieldRef<"Banner", 'String'>
    readonly image: FieldRef<"Banner", 'String'>
    readonly active: FieldRef<"Banner", 'Boolean'>
    readonly order: FieldRef<"Banner", 'Int'>
    readonly publicId: FieldRef<"Banner", 'String'>
    readonly createdAt: FieldRef<"Banner", 'DateTime'>
    readonly updatedAt: FieldRef<"Banner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Banner findUnique
   */
  export type BannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findUniqueOrThrow
   */
  export type BannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findFirst
   */
  export type BannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findFirstOrThrow
   */
  export type BannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findMany
   */
  export type BannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banners to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner create
   */
  export type BannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data needed to create a Banner.
     */
    data: XOR<BannerCreateInput, BannerUncheckedCreateInput>
  }

  /**
   * Banner createMany
   */
  export type BannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banner update
   */
  export type BannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data needed to update a Banner.
     */
    data: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
    /**
     * Choose, which Banner to update.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner updateMany
   */
  export type BannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to update.
     */
    limit?: number
  }

  /**
   * Banner upsert
   */
  export type BannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The filter to search for the Banner to update in case it exists.
     */
    where: BannerWhereUniqueInput
    /**
     * In case the Banner found by the `where` argument doesn't exist, create a new Banner with this data.
     */
    create: XOR<BannerCreateInput, BannerUncheckedCreateInput>
    /**
     * In case the Banner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
  }

  /**
   * Banner delete
   */
  export type BannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter which Banner to delete.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner deleteMany
   */
  export type BannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banners to delete
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to delete.
     */
    limit?: number
  }

  /**
   * Banner without action
   */
  export type BannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    info: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    info: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    info: number
    createdAt: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    info?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    info?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    info?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: number
    info: string
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    info?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["message"]>



  export type MessageSelectScalar = {
    id?: boolean
    info?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "info" | "createdAt", ExtArgs["result"]["message"]>

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      info: string
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'Int'>
    readonly info: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
  }


  /**
   * Model Foundation
   */

  export type AggregateFoundation = {
    _count: FoundationCountAggregateOutputType | null
    _avg: FoundationAvgAggregateOutputType | null
    _sum: FoundationSumAggregateOutputType | null
    _min: FoundationMinAggregateOutputType | null
    _max: FoundationMaxAggregateOutputType | null
  }

  export type FoundationAvgAggregateOutputType = {
    id: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type FoundationSumAggregateOutputType = {
    id: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type FoundationMinAggregateOutputType = {
    id: number | null
    name: string | null
    tagline: string | null
    logoUrl: string | null
    description: string | null
    establishedYear: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
    updatedById: number | null
  }

  export type FoundationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    tagline: string | null
    logoUrl: string | null
    description: string | null
    establishedYear: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
    updatedById: number | null
  }

  export type FoundationCountAggregateOutputType = {
    id: number
    name: number
    tagline: number
    logoUrl: number
    description: number
    establishedYear: number
    isActive: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    _all: number
  }


  export type FoundationAvgAggregateInputType = {
    id?: true
    createdById?: true
    updatedById?: true
  }

  export type FoundationSumAggregateInputType = {
    id?: true
    createdById?: true
    updatedById?: true
  }

  export type FoundationMinAggregateInputType = {
    id?: true
    name?: true
    tagline?: true
    logoUrl?: true
    description?: true
    establishedYear?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type FoundationMaxAggregateInputType = {
    id?: true
    name?: true
    tagline?: true
    logoUrl?: true
    description?: true
    establishedYear?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type FoundationCountAggregateInputType = {
    id?: true
    name?: true
    tagline?: true
    logoUrl?: true
    description?: true
    establishedYear?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    _all?: true
  }

  export type FoundationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Foundation to aggregate.
     */
    where?: FoundationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foundations to fetch.
     */
    orderBy?: FoundationOrderByWithRelationInput | FoundationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoundationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foundations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foundations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Foundations
    **/
    _count?: true | FoundationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoundationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoundationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoundationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoundationMaxAggregateInputType
  }

  export type GetFoundationAggregateType<T extends FoundationAggregateArgs> = {
        [P in keyof T & keyof AggregateFoundation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoundation[P]>
      : GetScalarType<T[P], AggregateFoundation[P]>
  }




  export type FoundationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationWhereInput
    orderBy?: FoundationOrderByWithAggregationInput | FoundationOrderByWithAggregationInput[]
    by: FoundationScalarFieldEnum[] | FoundationScalarFieldEnum
    having?: FoundationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoundationCountAggregateInputType | true
    _avg?: FoundationAvgAggregateInputType
    _sum?: FoundationSumAggregateInputType
    _min?: FoundationMinAggregateInputType
    _max?: FoundationMaxAggregateInputType
  }

  export type FoundationGroupByOutputType = {
    id: number
    name: string
    tagline: string | null
    logoUrl: string | null
    description: string | null
    establishedYear: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    createdById: number | null
    updatedById: number | null
    _count: FoundationCountAggregateOutputType | null
    _avg: FoundationAvgAggregateOutputType | null
    _sum: FoundationSumAggregateOutputType | null
    _min: FoundationMinAggregateOutputType | null
    _max: FoundationMaxAggregateOutputType | null
  }

  type GetFoundationGroupByPayload<T extends FoundationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoundationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoundationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoundationGroupByOutputType[P]>
            : GetScalarType<T[P], FoundationGroupByOutputType[P]>
        }
      >
    >


  export type FoundationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tagline?: boolean
    logoUrl?: boolean
    description?: boolean
    establishedYear?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    stats?: boolean | Foundation$statsArgs<ExtArgs>
    activities?: boolean | Foundation$activitiesArgs<ExtArgs>
    objectives?: boolean | Foundation$objectivesArgs<ExtArgs>
    contact?: boolean | Foundation$contactArgs<ExtArgs>
    media?: boolean | Foundation$mediaArgs<ExtArgs>
    _count?: boolean | FoundationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foundation"]>



  export type FoundationSelectScalar = {
    id?: boolean
    name?: boolean
    tagline?: boolean
    logoUrl?: boolean
    description?: boolean
    establishedYear?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
  }

  export type FoundationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "tagline" | "logoUrl" | "description" | "establishedYear" | "isActive" | "createdAt" | "updatedAt" | "createdById" | "updatedById", ExtArgs["result"]["foundation"]>
  export type FoundationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stats?: boolean | Foundation$statsArgs<ExtArgs>
    activities?: boolean | Foundation$activitiesArgs<ExtArgs>
    objectives?: boolean | Foundation$objectivesArgs<ExtArgs>
    contact?: boolean | Foundation$contactArgs<ExtArgs>
    media?: boolean | Foundation$mediaArgs<ExtArgs>
    _count?: boolean | FoundationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FoundationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Foundation"
    objects: {
      stats: Prisma.$FoundationStatPayload<ExtArgs>[]
      activities: Prisma.$FoundationActivityPayload<ExtArgs>[]
      objectives: Prisma.$FoundationObjectivePayload<ExtArgs>[]
      contact: Prisma.$FoundationContactPayload<ExtArgs> | null
      media: Prisma.$FoundationMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      tagline: string | null
      logoUrl: string | null
      description: string | null
      establishedYear: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      createdById: number | null
      updatedById: number | null
    }, ExtArgs["result"]["foundation"]>
    composites: {}
  }

  type FoundationGetPayload<S extends boolean | null | undefined | FoundationDefaultArgs> = $Result.GetResult<Prisma.$FoundationPayload, S>

  type FoundationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoundationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoundationCountAggregateInputType | true
    }

  export interface FoundationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Foundation'], meta: { name: 'Foundation' } }
    /**
     * Find zero or one Foundation that matches the filter.
     * @param {FoundationFindUniqueArgs} args - Arguments to find a Foundation
     * @example
     * // Get one Foundation
     * const foundation = await prisma.foundation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoundationFindUniqueArgs>(args: SelectSubset<T, FoundationFindUniqueArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Foundation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoundationFindUniqueOrThrowArgs} args - Arguments to find a Foundation
     * @example
     * // Get one Foundation
     * const foundation = await prisma.foundation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoundationFindUniqueOrThrowArgs>(args: SelectSubset<T, FoundationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Foundation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationFindFirstArgs} args - Arguments to find a Foundation
     * @example
     * // Get one Foundation
     * const foundation = await prisma.foundation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoundationFindFirstArgs>(args?: SelectSubset<T, FoundationFindFirstArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Foundation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationFindFirstOrThrowArgs} args - Arguments to find a Foundation
     * @example
     * // Get one Foundation
     * const foundation = await prisma.foundation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoundationFindFirstOrThrowArgs>(args?: SelectSubset<T, FoundationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Foundations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Foundations
     * const foundations = await prisma.foundation.findMany()
     * 
     * // Get first 10 Foundations
     * const foundations = await prisma.foundation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foundationWithIdOnly = await prisma.foundation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoundationFindManyArgs>(args?: SelectSubset<T, FoundationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Foundation.
     * @param {FoundationCreateArgs} args - Arguments to create a Foundation.
     * @example
     * // Create one Foundation
     * const Foundation = await prisma.foundation.create({
     *   data: {
     *     // ... data to create a Foundation
     *   }
     * })
     * 
     */
    create<T extends FoundationCreateArgs>(args: SelectSubset<T, FoundationCreateArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Foundations.
     * @param {FoundationCreateManyArgs} args - Arguments to create many Foundations.
     * @example
     * // Create many Foundations
     * const foundation = await prisma.foundation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoundationCreateManyArgs>(args?: SelectSubset<T, FoundationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Foundation.
     * @param {FoundationDeleteArgs} args - Arguments to delete one Foundation.
     * @example
     * // Delete one Foundation
     * const Foundation = await prisma.foundation.delete({
     *   where: {
     *     // ... filter to delete one Foundation
     *   }
     * })
     * 
     */
    delete<T extends FoundationDeleteArgs>(args: SelectSubset<T, FoundationDeleteArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Foundation.
     * @param {FoundationUpdateArgs} args - Arguments to update one Foundation.
     * @example
     * // Update one Foundation
     * const foundation = await prisma.foundation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoundationUpdateArgs>(args: SelectSubset<T, FoundationUpdateArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Foundations.
     * @param {FoundationDeleteManyArgs} args - Arguments to filter Foundations to delete.
     * @example
     * // Delete a few Foundations
     * const { count } = await prisma.foundation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoundationDeleteManyArgs>(args?: SelectSubset<T, FoundationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Foundations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Foundations
     * const foundation = await prisma.foundation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoundationUpdateManyArgs>(args: SelectSubset<T, FoundationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Foundation.
     * @param {FoundationUpsertArgs} args - Arguments to update or create a Foundation.
     * @example
     * // Update or create a Foundation
     * const foundation = await prisma.foundation.upsert({
     *   create: {
     *     // ... data to create a Foundation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Foundation we want to update
     *   }
     * })
     */
    upsert<T extends FoundationUpsertArgs>(args: SelectSubset<T, FoundationUpsertArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Foundations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationCountArgs} args - Arguments to filter Foundations to count.
     * @example
     * // Count the number of Foundations
     * const count = await prisma.foundation.count({
     *   where: {
     *     // ... the filter for the Foundations we want to count
     *   }
     * })
    **/
    count<T extends FoundationCountArgs>(
      args?: Subset<T, FoundationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoundationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Foundation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoundationAggregateArgs>(args: Subset<T, FoundationAggregateArgs>): Prisma.PrismaPromise<GetFoundationAggregateType<T>>

    /**
     * Group by Foundation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoundationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoundationGroupByArgs['orderBy'] }
        : { orderBy?: FoundationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoundationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoundationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Foundation model
   */
  readonly fields: FoundationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Foundation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoundationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stats<T extends Foundation$statsArgs<ExtArgs> = {}>(args?: Subset<T, Foundation$statsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends Foundation$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Foundation$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    objectives<T extends Foundation$objectivesArgs<ExtArgs> = {}>(args?: Subset<T, Foundation$objectivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contact<T extends Foundation$contactArgs<ExtArgs> = {}>(args?: Subset<T, Foundation$contactArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    media<T extends Foundation$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Foundation$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Foundation model
   */
  interface FoundationFieldRefs {
    readonly id: FieldRef<"Foundation", 'Int'>
    readonly name: FieldRef<"Foundation", 'String'>
    readonly tagline: FieldRef<"Foundation", 'String'>
    readonly logoUrl: FieldRef<"Foundation", 'String'>
    readonly description: FieldRef<"Foundation", 'String'>
    readonly establishedYear: FieldRef<"Foundation", 'String'>
    readonly isActive: FieldRef<"Foundation", 'Boolean'>
    readonly createdAt: FieldRef<"Foundation", 'DateTime'>
    readonly updatedAt: FieldRef<"Foundation", 'DateTime'>
    readonly createdById: FieldRef<"Foundation", 'Int'>
    readonly updatedById: FieldRef<"Foundation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Foundation findUnique
   */
  export type FoundationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * Filter, which Foundation to fetch.
     */
    where: FoundationWhereUniqueInput
  }

  /**
   * Foundation findUniqueOrThrow
   */
  export type FoundationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * Filter, which Foundation to fetch.
     */
    where: FoundationWhereUniqueInput
  }

  /**
   * Foundation findFirst
   */
  export type FoundationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * Filter, which Foundation to fetch.
     */
    where?: FoundationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foundations to fetch.
     */
    orderBy?: FoundationOrderByWithRelationInput | FoundationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foundations.
     */
    cursor?: FoundationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foundations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foundations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Foundations.
     */
    distinct?: FoundationScalarFieldEnum | FoundationScalarFieldEnum[]
  }

  /**
   * Foundation findFirstOrThrow
   */
  export type FoundationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * Filter, which Foundation to fetch.
     */
    where?: FoundationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foundations to fetch.
     */
    orderBy?: FoundationOrderByWithRelationInput | FoundationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foundations.
     */
    cursor?: FoundationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foundations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foundations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Foundations.
     */
    distinct?: FoundationScalarFieldEnum | FoundationScalarFieldEnum[]
  }

  /**
   * Foundation findMany
   */
  export type FoundationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * Filter, which Foundations to fetch.
     */
    where?: FoundationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foundations to fetch.
     */
    orderBy?: FoundationOrderByWithRelationInput | FoundationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Foundations.
     */
    cursor?: FoundationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foundations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foundations.
     */
    skip?: number
    distinct?: FoundationScalarFieldEnum | FoundationScalarFieldEnum[]
  }

  /**
   * Foundation create
   */
  export type FoundationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * The data needed to create a Foundation.
     */
    data: XOR<FoundationCreateInput, FoundationUncheckedCreateInput>
  }

  /**
   * Foundation createMany
   */
  export type FoundationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Foundations.
     */
    data: FoundationCreateManyInput | FoundationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Foundation update
   */
  export type FoundationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * The data needed to update a Foundation.
     */
    data: XOR<FoundationUpdateInput, FoundationUncheckedUpdateInput>
    /**
     * Choose, which Foundation to update.
     */
    where: FoundationWhereUniqueInput
  }

  /**
   * Foundation updateMany
   */
  export type FoundationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Foundations.
     */
    data: XOR<FoundationUpdateManyMutationInput, FoundationUncheckedUpdateManyInput>
    /**
     * Filter which Foundations to update
     */
    where?: FoundationWhereInput
    /**
     * Limit how many Foundations to update.
     */
    limit?: number
  }

  /**
   * Foundation upsert
   */
  export type FoundationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * The filter to search for the Foundation to update in case it exists.
     */
    where: FoundationWhereUniqueInput
    /**
     * In case the Foundation found by the `where` argument doesn't exist, create a new Foundation with this data.
     */
    create: XOR<FoundationCreateInput, FoundationUncheckedCreateInput>
    /**
     * In case the Foundation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoundationUpdateInput, FoundationUncheckedUpdateInput>
  }

  /**
   * Foundation delete
   */
  export type FoundationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    /**
     * Filter which Foundation to delete.
     */
    where: FoundationWhereUniqueInput
  }

  /**
   * Foundation deleteMany
   */
  export type FoundationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Foundations to delete
     */
    where?: FoundationWhereInput
    /**
     * Limit how many Foundations to delete.
     */
    limit?: number
  }

  /**
   * Foundation.stats
   */
  export type Foundation$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    where?: FoundationStatWhereInput
    orderBy?: FoundationStatOrderByWithRelationInput | FoundationStatOrderByWithRelationInput[]
    cursor?: FoundationStatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoundationStatScalarFieldEnum | FoundationStatScalarFieldEnum[]
  }

  /**
   * Foundation.activities
   */
  export type Foundation$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    where?: FoundationActivityWhereInput
    orderBy?: FoundationActivityOrderByWithRelationInput | FoundationActivityOrderByWithRelationInput[]
    cursor?: FoundationActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoundationActivityScalarFieldEnum | FoundationActivityScalarFieldEnum[]
  }

  /**
   * Foundation.objectives
   */
  export type Foundation$objectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    where?: FoundationObjectiveWhereInput
    orderBy?: FoundationObjectiveOrderByWithRelationInput | FoundationObjectiveOrderByWithRelationInput[]
    cursor?: FoundationObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoundationObjectiveScalarFieldEnum | FoundationObjectiveScalarFieldEnum[]
  }

  /**
   * Foundation.contact
   */
  export type Foundation$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    where?: FoundationContactWhereInput
  }

  /**
   * Foundation.media
   */
  export type Foundation$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    where?: FoundationMediaWhereInput
    orderBy?: FoundationMediaOrderByWithRelationInput | FoundationMediaOrderByWithRelationInput[]
    cursor?: FoundationMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoundationMediaScalarFieldEnum | FoundationMediaScalarFieldEnum[]
  }

  /**
   * Foundation without action
   */
  export type FoundationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
  }


  /**
   * Model FoundationStat
   */

  export type AggregateFoundationStat = {
    _count: FoundationStatCountAggregateOutputType | null
    _avg: FoundationStatAvgAggregateOutputType | null
    _sum: FoundationStatSumAggregateOutputType | null
    _min: FoundationStatMinAggregateOutputType | null
    _max: FoundationStatMaxAggregateOutputType | null
  }

  export type FoundationStatAvgAggregateOutputType = {
    id: number | null
    foundationId: number | null
    displayOrder: number | null
  }

  export type FoundationStatSumAggregateOutputType = {
    id: number | null
    foundationId: number | null
    displayOrder: number | null
  }

  export type FoundationStatMinAggregateOutputType = {
    id: number | null
    foundationId: number | null
    label: string | null
    value: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoundationStatMaxAggregateOutputType = {
    id: number | null
    foundationId: number | null
    label: string | null
    value: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoundationStatCountAggregateOutputType = {
    id: number
    foundationId: number
    label: number
    value: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoundationStatAvgAggregateInputType = {
    id?: true
    foundationId?: true
    displayOrder?: true
  }

  export type FoundationStatSumAggregateInputType = {
    id?: true
    foundationId?: true
    displayOrder?: true
  }

  export type FoundationStatMinAggregateInputType = {
    id?: true
    foundationId?: true
    label?: true
    value?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoundationStatMaxAggregateInputType = {
    id?: true
    foundationId?: true
    label?: true
    value?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoundationStatCountAggregateInputType = {
    id?: true
    foundationId?: true
    label?: true
    value?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoundationStatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationStat to aggregate.
     */
    where?: FoundationStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationStats to fetch.
     */
    orderBy?: FoundationStatOrderByWithRelationInput | FoundationStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoundationStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoundationStats
    **/
    _count?: true | FoundationStatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoundationStatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoundationStatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoundationStatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoundationStatMaxAggregateInputType
  }

  export type GetFoundationStatAggregateType<T extends FoundationStatAggregateArgs> = {
        [P in keyof T & keyof AggregateFoundationStat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoundationStat[P]>
      : GetScalarType<T[P], AggregateFoundationStat[P]>
  }




  export type FoundationStatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationStatWhereInput
    orderBy?: FoundationStatOrderByWithAggregationInput | FoundationStatOrderByWithAggregationInput[]
    by: FoundationStatScalarFieldEnum[] | FoundationStatScalarFieldEnum
    having?: FoundationStatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoundationStatCountAggregateInputType | true
    _avg?: FoundationStatAvgAggregateInputType
    _sum?: FoundationStatSumAggregateInputType
    _min?: FoundationStatMinAggregateInputType
    _max?: FoundationStatMaxAggregateInputType
  }

  export type FoundationStatGroupByOutputType = {
    id: number
    foundationId: number
    label: string
    value: string
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: FoundationStatCountAggregateOutputType | null
    _avg: FoundationStatAvgAggregateOutputType | null
    _sum: FoundationStatSumAggregateOutputType | null
    _min: FoundationStatMinAggregateOutputType | null
    _max: FoundationStatMaxAggregateOutputType | null
  }

  type GetFoundationStatGroupByPayload<T extends FoundationStatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoundationStatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoundationStatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoundationStatGroupByOutputType[P]>
            : GetScalarType<T[P], FoundationStatGroupByOutputType[P]>
        }
      >
    >


  export type FoundationStatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foundationId?: boolean
    label?: boolean
    value?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    foundation?: boolean | FoundationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foundationStat"]>



  export type FoundationStatSelectScalar = {
    id?: boolean
    foundationId?: boolean
    label?: boolean
    value?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoundationStatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "foundationId" | "label" | "value" | "displayOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["foundationStat"]>
  export type FoundationStatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foundation?: boolean | FoundationDefaultArgs<ExtArgs>
  }

  export type $FoundationStatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoundationStat"
    objects: {
      foundation: Prisma.$FoundationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      foundationId: number
      label: string
      value: string
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foundationStat"]>
    composites: {}
  }

  type FoundationStatGetPayload<S extends boolean | null | undefined | FoundationStatDefaultArgs> = $Result.GetResult<Prisma.$FoundationStatPayload, S>

  type FoundationStatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoundationStatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoundationStatCountAggregateInputType | true
    }

  export interface FoundationStatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoundationStat'], meta: { name: 'FoundationStat' } }
    /**
     * Find zero or one FoundationStat that matches the filter.
     * @param {FoundationStatFindUniqueArgs} args - Arguments to find a FoundationStat
     * @example
     * // Get one FoundationStat
     * const foundationStat = await prisma.foundationStat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoundationStatFindUniqueArgs>(args: SelectSubset<T, FoundationStatFindUniqueArgs<ExtArgs>>): Prisma__FoundationStatClient<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoundationStat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoundationStatFindUniqueOrThrowArgs} args - Arguments to find a FoundationStat
     * @example
     * // Get one FoundationStat
     * const foundationStat = await prisma.foundationStat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoundationStatFindUniqueOrThrowArgs>(args: SelectSubset<T, FoundationStatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoundationStatClient<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationStat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationStatFindFirstArgs} args - Arguments to find a FoundationStat
     * @example
     * // Get one FoundationStat
     * const foundationStat = await prisma.foundationStat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoundationStatFindFirstArgs>(args?: SelectSubset<T, FoundationStatFindFirstArgs<ExtArgs>>): Prisma__FoundationStatClient<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationStat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationStatFindFirstOrThrowArgs} args - Arguments to find a FoundationStat
     * @example
     * // Get one FoundationStat
     * const foundationStat = await prisma.foundationStat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoundationStatFindFirstOrThrowArgs>(args?: SelectSubset<T, FoundationStatFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoundationStatClient<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoundationStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationStatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoundationStats
     * const foundationStats = await prisma.foundationStat.findMany()
     * 
     * // Get first 10 FoundationStats
     * const foundationStats = await prisma.foundationStat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foundationStatWithIdOnly = await prisma.foundationStat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoundationStatFindManyArgs>(args?: SelectSubset<T, FoundationStatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoundationStat.
     * @param {FoundationStatCreateArgs} args - Arguments to create a FoundationStat.
     * @example
     * // Create one FoundationStat
     * const FoundationStat = await prisma.foundationStat.create({
     *   data: {
     *     // ... data to create a FoundationStat
     *   }
     * })
     * 
     */
    create<T extends FoundationStatCreateArgs>(args: SelectSubset<T, FoundationStatCreateArgs<ExtArgs>>): Prisma__FoundationStatClient<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoundationStats.
     * @param {FoundationStatCreateManyArgs} args - Arguments to create many FoundationStats.
     * @example
     * // Create many FoundationStats
     * const foundationStat = await prisma.foundationStat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoundationStatCreateManyArgs>(args?: SelectSubset<T, FoundationStatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FoundationStat.
     * @param {FoundationStatDeleteArgs} args - Arguments to delete one FoundationStat.
     * @example
     * // Delete one FoundationStat
     * const FoundationStat = await prisma.foundationStat.delete({
     *   where: {
     *     // ... filter to delete one FoundationStat
     *   }
     * })
     * 
     */
    delete<T extends FoundationStatDeleteArgs>(args: SelectSubset<T, FoundationStatDeleteArgs<ExtArgs>>): Prisma__FoundationStatClient<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoundationStat.
     * @param {FoundationStatUpdateArgs} args - Arguments to update one FoundationStat.
     * @example
     * // Update one FoundationStat
     * const foundationStat = await prisma.foundationStat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoundationStatUpdateArgs>(args: SelectSubset<T, FoundationStatUpdateArgs<ExtArgs>>): Prisma__FoundationStatClient<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoundationStats.
     * @param {FoundationStatDeleteManyArgs} args - Arguments to filter FoundationStats to delete.
     * @example
     * // Delete a few FoundationStats
     * const { count } = await prisma.foundationStat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoundationStatDeleteManyArgs>(args?: SelectSubset<T, FoundationStatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoundationStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationStatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoundationStats
     * const foundationStat = await prisma.foundationStat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoundationStatUpdateManyArgs>(args: SelectSubset<T, FoundationStatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoundationStat.
     * @param {FoundationStatUpsertArgs} args - Arguments to update or create a FoundationStat.
     * @example
     * // Update or create a FoundationStat
     * const foundationStat = await prisma.foundationStat.upsert({
     *   create: {
     *     // ... data to create a FoundationStat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoundationStat we want to update
     *   }
     * })
     */
    upsert<T extends FoundationStatUpsertArgs>(args: SelectSubset<T, FoundationStatUpsertArgs<ExtArgs>>): Prisma__FoundationStatClient<$Result.GetResult<Prisma.$FoundationStatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoundationStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationStatCountArgs} args - Arguments to filter FoundationStats to count.
     * @example
     * // Count the number of FoundationStats
     * const count = await prisma.foundationStat.count({
     *   where: {
     *     // ... the filter for the FoundationStats we want to count
     *   }
     * })
    **/
    count<T extends FoundationStatCountArgs>(
      args?: Subset<T, FoundationStatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoundationStatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoundationStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationStatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoundationStatAggregateArgs>(args: Subset<T, FoundationStatAggregateArgs>): Prisma.PrismaPromise<GetFoundationStatAggregateType<T>>

    /**
     * Group by FoundationStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationStatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoundationStatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoundationStatGroupByArgs['orderBy'] }
        : { orderBy?: FoundationStatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoundationStatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoundationStatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoundationStat model
   */
  readonly fields: FoundationStatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoundationStat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoundationStatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    foundation<T extends FoundationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoundationDefaultArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoundationStat model
   */
  interface FoundationStatFieldRefs {
    readonly id: FieldRef<"FoundationStat", 'Int'>
    readonly foundationId: FieldRef<"FoundationStat", 'Int'>
    readonly label: FieldRef<"FoundationStat", 'String'>
    readonly value: FieldRef<"FoundationStat", 'String'>
    readonly displayOrder: FieldRef<"FoundationStat", 'Int'>
    readonly createdAt: FieldRef<"FoundationStat", 'DateTime'>
    readonly updatedAt: FieldRef<"FoundationStat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoundationStat findUnique
   */
  export type FoundationStatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * Filter, which FoundationStat to fetch.
     */
    where: FoundationStatWhereUniqueInput
  }

  /**
   * FoundationStat findUniqueOrThrow
   */
  export type FoundationStatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * Filter, which FoundationStat to fetch.
     */
    where: FoundationStatWhereUniqueInput
  }

  /**
   * FoundationStat findFirst
   */
  export type FoundationStatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * Filter, which FoundationStat to fetch.
     */
    where?: FoundationStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationStats to fetch.
     */
    orderBy?: FoundationStatOrderByWithRelationInput | FoundationStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationStats.
     */
    cursor?: FoundationStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationStats.
     */
    distinct?: FoundationStatScalarFieldEnum | FoundationStatScalarFieldEnum[]
  }

  /**
   * FoundationStat findFirstOrThrow
   */
  export type FoundationStatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * Filter, which FoundationStat to fetch.
     */
    where?: FoundationStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationStats to fetch.
     */
    orderBy?: FoundationStatOrderByWithRelationInput | FoundationStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationStats.
     */
    cursor?: FoundationStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationStats.
     */
    distinct?: FoundationStatScalarFieldEnum | FoundationStatScalarFieldEnum[]
  }

  /**
   * FoundationStat findMany
   */
  export type FoundationStatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * Filter, which FoundationStats to fetch.
     */
    where?: FoundationStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationStats to fetch.
     */
    orderBy?: FoundationStatOrderByWithRelationInput | FoundationStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoundationStats.
     */
    cursor?: FoundationStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationStats.
     */
    skip?: number
    distinct?: FoundationStatScalarFieldEnum | FoundationStatScalarFieldEnum[]
  }

  /**
   * FoundationStat create
   */
  export type FoundationStatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * The data needed to create a FoundationStat.
     */
    data: XOR<FoundationStatCreateInput, FoundationStatUncheckedCreateInput>
  }

  /**
   * FoundationStat createMany
   */
  export type FoundationStatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoundationStats.
     */
    data: FoundationStatCreateManyInput | FoundationStatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoundationStat update
   */
  export type FoundationStatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * The data needed to update a FoundationStat.
     */
    data: XOR<FoundationStatUpdateInput, FoundationStatUncheckedUpdateInput>
    /**
     * Choose, which FoundationStat to update.
     */
    where: FoundationStatWhereUniqueInput
  }

  /**
   * FoundationStat updateMany
   */
  export type FoundationStatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoundationStats.
     */
    data: XOR<FoundationStatUpdateManyMutationInput, FoundationStatUncheckedUpdateManyInput>
    /**
     * Filter which FoundationStats to update
     */
    where?: FoundationStatWhereInput
    /**
     * Limit how many FoundationStats to update.
     */
    limit?: number
  }

  /**
   * FoundationStat upsert
   */
  export type FoundationStatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * The filter to search for the FoundationStat to update in case it exists.
     */
    where: FoundationStatWhereUniqueInput
    /**
     * In case the FoundationStat found by the `where` argument doesn't exist, create a new FoundationStat with this data.
     */
    create: XOR<FoundationStatCreateInput, FoundationStatUncheckedCreateInput>
    /**
     * In case the FoundationStat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoundationStatUpdateInput, FoundationStatUncheckedUpdateInput>
  }

  /**
   * FoundationStat delete
   */
  export type FoundationStatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
    /**
     * Filter which FoundationStat to delete.
     */
    where: FoundationStatWhereUniqueInput
  }

  /**
   * FoundationStat deleteMany
   */
  export type FoundationStatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationStats to delete
     */
    where?: FoundationStatWhereInput
    /**
     * Limit how many FoundationStats to delete.
     */
    limit?: number
  }

  /**
   * FoundationStat without action
   */
  export type FoundationStatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationStat
     */
    select?: FoundationStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationStat
     */
    omit?: FoundationStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationStatInclude<ExtArgs> | null
  }


  /**
   * Model FoundationActivity
   */

  export type AggregateFoundationActivity = {
    _count: FoundationActivityCountAggregateOutputType | null
    _avg: FoundationActivityAvgAggregateOutputType | null
    _sum: FoundationActivitySumAggregateOutputType | null
    _min: FoundationActivityMinAggregateOutputType | null
    _max: FoundationActivityMaxAggregateOutputType | null
  }

  export type FoundationActivityAvgAggregateOutputType = {
    id: number | null
    foundationId: number | null
    displayOrder: number | null
  }

  export type FoundationActivitySumAggregateOutputType = {
    id: number | null
    foundationId: number | null
    displayOrder: number | null
  }

  export type FoundationActivityMinAggregateOutputType = {
    id: number | null
    foundationId: number | null
    activityText: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoundationActivityMaxAggregateOutputType = {
    id: number | null
    foundationId: number | null
    activityText: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoundationActivityCountAggregateOutputType = {
    id: number
    foundationId: number
    activityText: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoundationActivityAvgAggregateInputType = {
    id?: true
    foundationId?: true
    displayOrder?: true
  }

  export type FoundationActivitySumAggregateInputType = {
    id?: true
    foundationId?: true
    displayOrder?: true
  }

  export type FoundationActivityMinAggregateInputType = {
    id?: true
    foundationId?: true
    activityText?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoundationActivityMaxAggregateInputType = {
    id?: true
    foundationId?: true
    activityText?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoundationActivityCountAggregateInputType = {
    id?: true
    foundationId?: true
    activityText?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoundationActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationActivity to aggregate.
     */
    where?: FoundationActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationActivities to fetch.
     */
    orderBy?: FoundationActivityOrderByWithRelationInput | FoundationActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoundationActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoundationActivities
    **/
    _count?: true | FoundationActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoundationActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoundationActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoundationActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoundationActivityMaxAggregateInputType
  }

  export type GetFoundationActivityAggregateType<T extends FoundationActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateFoundationActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoundationActivity[P]>
      : GetScalarType<T[P], AggregateFoundationActivity[P]>
  }




  export type FoundationActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationActivityWhereInput
    orderBy?: FoundationActivityOrderByWithAggregationInput | FoundationActivityOrderByWithAggregationInput[]
    by: FoundationActivityScalarFieldEnum[] | FoundationActivityScalarFieldEnum
    having?: FoundationActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoundationActivityCountAggregateInputType | true
    _avg?: FoundationActivityAvgAggregateInputType
    _sum?: FoundationActivitySumAggregateInputType
    _min?: FoundationActivityMinAggregateInputType
    _max?: FoundationActivityMaxAggregateInputType
  }

  export type FoundationActivityGroupByOutputType = {
    id: number
    foundationId: number
    activityText: string
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: FoundationActivityCountAggregateOutputType | null
    _avg: FoundationActivityAvgAggregateOutputType | null
    _sum: FoundationActivitySumAggregateOutputType | null
    _min: FoundationActivityMinAggregateOutputType | null
    _max: FoundationActivityMaxAggregateOutputType | null
  }

  type GetFoundationActivityGroupByPayload<T extends FoundationActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoundationActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoundationActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoundationActivityGroupByOutputType[P]>
            : GetScalarType<T[P], FoundationActivityGroupByOutputType[P]>
        }
      >
    >


  export type FoundationActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foundationId?: boolean
    activityText?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    foundation?: boolean | FoundationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foundationActivity"]>



  export type FoundationActivitySelectScalar = {
    id?: boolean
    foundationId?: boolean
    activityText?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoundationActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "foundationId" | "activityText" | "displayOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["foundationActivity"]>
  export type FoundationActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foundation?: boolean | FoundationDefaultArgs<ExtArgs>
  }

  export type $FoundationActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoundationActivity"
    objects: {
      foundation: Prisma.$FoundationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      foundationId: number
      activityText: string
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foundationActivity"]>
    composites: {}
  }

  type FoundationActivityGetPayload<S extends boolean | null | undefined | FoundationActivityDefaultArgs> = $Result.GetResult<Prisma.$FoundationActivityPayload, S>

  type FoundationActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoundationActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoundationActivityCountAggregateInputType | true
    }

  export interface FoundationActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoundationActivity'], meta: { name: 'FoundationActivity' } }
    /**
     * Find zero or one FoundationActivity that matches the filter.
     * @param {FoundationActivityFindUniqueArgs} args - Arguments to find a FoundationActivity
     * @example
     * // Get one FoundationActivity
     * const foundationActivity = await prisma.foundationActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoundationActivityFindUniqueArgs>(args: SelectSubset<T, FoundationActivityFindUniqueArgs<ExtArgs>>): Prisma__FoundationActivityClient<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoundationActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoundationActivityFindUniqueOrThrowArgs} args - Arguments to find a FoundationActivity
     * @example
     * // Get one FoundationActivity
     * const foundationActivity = await prisma.foundationActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoundationActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, FoundationActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoundationActivityClient<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationActivityFindFirstArgs} args - Arguments to find a FoundationActivity
     * @example
     * // Get one FoundationActivity
     * const foundationActivity = await prisma.foundationActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoundationActivityFindFirstArgs>(args?: SelectSubset<T, FoundationActivityFindFirstArgs<ExtArgs>>): Prisma__FoundationActivityClient<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationActivityFindFirstOrThrowArgs} args - Arguments to find a FoundationActivity
     * @example
     * // Get one FoundationActivity
     * const foundationActivity = await prisma.foundationActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoundationActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, FoundationActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoundationActivityClient<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoundationActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoundationActivities
     * const foundationActivities = await prisma.foundationActivity.findMany()
     * 
     * // Get first 10 FoundationActivities
     * const foundationActivities = await prisma.foundationActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foundationActivityWithIdOnly = await prisma.foundationActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoundationActivityFindManyArgs>(args?: SelectSubset<T, FoundationActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoundationActivity.
     * @param {FoundationActivityCreateArgs} args - Arguments to create a FoundationActivity.
     * @example
     * // Create one FoundationActivity
     * const FoundationActivity = await prisma.foundationActivity.create({
     *   data: {
     *     // ... data to create a FoundationActivity
     *   }
     * })
     * 
     */
    create<T extends FoundationActivityCreateArgs>(args: SelectSubset<T, FoundationActivityCreateArgs<ExtArgs>>): Prisma__FoundationActivityClient<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoundationActivities.
     * @param {FoundationActivityCreateManyArgs} args - Arguments to create many FoundationActivities.
     * @example
     * // Create many FoundationActivities
     * const foundationActivity = await prisma.foundationActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoundationActivityCreateManyArgs>(args?: SelectSubset<T, FoundationActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FoundationActivity.
     * @param {FoundationActivityDeleteArgs} args - Arguments to delete one FoundationActivity.
     * @example
     * // Delete one FoundationActivity
     * const FoundationActivity = await prisma.foundationActivity.delete({
     *   where: {
     *     // ... filter to delete one FoundationActivity
     *   }
     * })
     * 
     */
    delete<T extends FoundationActivityDeleteArgs>(args: SelectSubset<T, FoundationActivityDeleteArgs<ExtArgs>>): Prisma__FoundationActivityClient<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoundationActivity.
     * @param {FoundationActivityUpdateArgs} args - Arguments to update one FoundationActivity.
     * @example
     * // Update one FoundationActivity
     * const foundationActivity = await prisma.foundationActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoundationActivityUpdateArgs>(args: SelectSubset<T, FoundationActivityUpdateArgs<ExtArgs>>): Prisma__FoundationActivityClient<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoundationActivities.
     * @param {FoundationActivityDeleteManyArgs} args - Arguments to filter FoundationActivities to delete.
     * @example
     * // Delete a few FoundationActivities
     * const { count } = await prisma.foundationActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoundationActivityDeleteManyArgs>(args?: SelectSubset<T, FoundationActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoundationActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoundationActivities
     * const foundationActivity = await prisma.foundationActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoundationActivityUpdateManyArgs>(args: SelectSubset<T, FoundationActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoundationActivity.
     * @param {FoundationActivityUpsertArgs} args - Arguments to update or create a FoundationActivity.
     * @example
     * // Update or create a FoundationActivity
     * const foundationActivity = await prisma.foundationActivity.upsert({
     *   create: {
     *     // ... data to create a FoundationActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoundationActivity we want to update
     *   }
     * })
     */
    upsert<T extends FoundationActivityUpsertArgs>(args: SelectSubset<T, FoundationActivityUpsertArgs<ExtArgs>>): Prisma__FoundationActivityClient<$Result.GetResult<Prisma.$FoundationActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoundationActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationActivityCountArgs} args - Arguments to filter FoundationActivities to count.
     * @example
     * // Count the number of FoundationActivities
     * const count = await prisma.foundationActivity.count({
     *   where: {
     *     // ... the filter for the FoundationActivities we want to count
     *   }
     * })
    **/
    count<T extends FoundationActivityCountArgs>(
      args?: Subset<T, FoundationActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoundationActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoundationActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoundationActivityAggregateArgs>(args: Subset<T, FoundationActivityAggregateArgs>): Prisma.PrismaPromise<GetFoundationActivityAggregateType<T>>

    /**
     * Group by FoundationActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoundationActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoundationActivityGroupByArgs['orderBy'] }
        : { orderBy?: FoundationActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoundationActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoundationActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoundationActivity model
   */
  readonly fields: FoundationActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoundationActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoundationActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    foundation<T extends FoundationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoundationDefaultArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoundationActivity model
   */
  interface FoundationActivityFieldRefs {
    readonly id: FieldRef<"FoundationActivity", 'Int'>
    readonly foundationId: FieldRef<"FoundationActivity", 'Int'>
    readonly activityText: FieldRef<"FoundationActivity", 'String'>
    readonly displayOrder: FieldRef<"FoundationActivity", 'Int'>
    readonly createdAt: FieldRef<"FoundationActivity", 'DateTime'>
    readonly updatedAt: FieldRef<"FoundationActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoundationActivity findUnique
   */
  export type FoundationActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * Filter, which FoundationActivity to fetch.
     */
    where: FoundationActivityWhereUniqueInput
  }

  /**
   * FoundationActivity findUniqueOrThrow
   */
  export type FoundationActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * Filter, which FoundationActivity to fetch.
     */
    where: FoundationActivityWhereUniqueInput
  }

  /**
   * FoundationActivity findFirst
   */
  export type FoundationActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * Filter, which FoundationActivity to fetch.
     */
    where?: FoundationActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationActivities to fetch.
     */
    orderBy?: FoundationActivityOrderByWithRelationInput | FoundationActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationActivities.
     */
    cursor?: FoundationActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationActivities.
     */
    distinct?: FoundationActivityScalarFieldEnum | FoundationActivityScalarFieldEnum[]
  }

  /**
   * FoundationActivity findFirstOrThrow
   */
  export type FoundationActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * Filter, which FoundationActivity to fetch.
     */
    where?: FoundationActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationActivities to fetch.
     */
    orderBy?: FoundationActivityOrderByWithRelationInput | FoundationActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationActivities.
     */
    cursor?: FoundationActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationActivities.
     */
    distinct?: FoundationActivityScalarFieldEnum | FoundationActivityScalarFieldEnum[]
  }

  /**
   * FoundationActivity findMany
   */
  export type FoundationActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * Filter, which FoundationActivities to fetch.
     */
    where?: FoundationActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationActivities to fetch.
     */
    orderBy?: FoundationActivityOrderByWithRelationInput | FoundationActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoundationActivities.
     */
    cursor?: FoundationActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationActivities.
     */
    skip?: number
    distinct?: FoundationActivityScalarFieldEnum | FoundationActivityScalarFieldEnum[]
  }

  /**
   * FoundationActivity create
   */
  export type FoundationActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a FoundationActivity.
     */
    data: XOR<FoundationActivityCreateInput, FoundationActivityUncheckedCreateInput>
  }

  /**
   * FoundationActivity createMany
   */
  export type FoundationActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoundationActivities.
     */
    data: FoundationActivityCreateManyInput | FoundationActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoundationActivity update
   */
  export type FoundationActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a FoundationActivity.
     */
    data: XOR<FoundationActivityUpdateInput, FoundationActivityUncheckedUpdateInput>
    /**
     * Choose, which FoundationActivity to update.
     */
    where: FoundationActivityWhereUniqueInput
  }

  /**
   * FoundationActivity updateMany
   */
  export type FoundationActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoundationActivities.
     */
    data: XOR<FoundationActivityUpdateManyMutationInput, FoundationActivityUncheckedUpdateManyInput>
    /**
     * Filter which FoundationActivities to update
     */
    where?: FoundationActivityWhereInput
    /**
     * Limit how many FoundationActivities to update.
     */
    limit?: number
  }

  /**
   * FoundationActivity upsert
   */
  export type FoundationActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the FoundationActivity to update in case it exists.
     */
    where: FoundationActivityWhereUniqueInput
    /**
     * In case the FoundationActivity found by the `where` argument doesn't exist, create a new FoundationActivity with this data.
     */
    create: XOR<FoundationActivityCreateInput, FoundationActivityUncheckedCreateInput>
    /**
     * In case the FoundationActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoundationActivityUpdateInput, FoundationActivityUncheckedUpdateInput>
  }

  /**
   * FoundationActivity delete
   */
  export type FoundationActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
    /**
     * Filter which FoundationActivity to delete.
     */
    where: FoundationActivityWhereUniqueInput
  }

  /**
   * FoundationActivity deleteMany
   */
  export type FoundationActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationActivities to delete
     */
    where?: FoundationActivityWhereInput
    /**
     * Limit how many FoundationActivities to delete.
     */
    limit?: number
  }

  /**
   * FoundationActivity without action
   */
  export type FoundationActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationActivity
     */
    select?: FoundationActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationActivity
     */
    omit?: FoundationActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationActivityInclude<ExtArgs> | null
  }


  /**
   * Model FoundationObjective
   */

  export type AggregateFoundationObjective = {
    _count: FoundationObjectiveCountAggregateOutputType | null
    _avg: FoundationObjectiveAvgAggregateOutputType | null
    _sum: FoundationObjectiveSumAggregateOutputType | null
    _min: FoundationObjectiveMinAggregateOutputType | null
    _max: FoundationObjectiveMaxAggregateOutputType | null
  }

  export type FoundationObjectiveAvgAggregateOutputType = {
    id: number | null
    foundationId: number | null
    displayOrder: number | null
  }

  export type FoundationObjectiveSumAggregateOutputType = {
    id: number | null
    foundationId: number | null
    displayOrder: number | null
  }

  export type FoundationObjectiveMinAggregateOutputType = {
    id: number | null
    foundationId: number | null
    title: string | null
    description: string | null
    objectiveType: $Enums.ObjectiveType | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoundationObjectiveMaxAggregateOutputType = {
    id: number | null
    foundationId: number | null
    title: string | null
    description: string | null
    objectiveType: $Enums.ObjectiveType | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoundationObjectiveCountAggregateOutputType = {
    id: number
    foundationId: number
    title: number
    description: number
    objectiveType: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoundationObjectiveAvgAggregateInputType = {
    id?: true
    foundationId?: true
    displayOrder?: true
  }

  export type FoundationObjectiveSumAggregateInputType = {
    id?: true
    foundationId?: true
    displayOrder?: true
  }

  export type FoundationObjectiveMinAggregateInputType = {
    id?: true
    foundationId?: true
    title?: true
    description?: true
    objectiveType?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoundationObjectiveMaxAggregateInputType = {
    id?: true
    foundationId?: true
    title?: true
    description?: true
    objectiveType?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoundationObjectiveCountAggregateInputType = {
    id?: true
    foundationId?: true
    title?: true
    description?: true
    objectiveType?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoundationObjectiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationObjective to aggregate.
     */
    where?: FoundationObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationObjectives to fetch.
     */
    orderBy?: FoundationObjectiveOrderByWithRelationInput | FoundationObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoundationObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoundationObjectives
    **/
    _count?: true | FoundationObjectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoundationObjectiveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoundationObjectiveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoundationObjectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoundationObjectiveMaxAggregateInputType
  }

  export type GetFoundationObjectiveAggregateType<T extends FoundationObjectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateFoundationObjective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoundationObjective[P]>
      : GetScalarType<T[P], AggregateFoundationObjective[P]>
  }




  export type FoundationObjectiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationObjectiveWhereInput
    orderBy?: FoundationObjectiveOrderByWithAggregationInput | FoundationObjectiveOrderByWithAggregationInput[]
    by: FoundationObjectiveScalarFieldEnum[] | FoundationObjectiveScalarFieldEnum
    having?: FoundationObjectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoundationObjectiveCountAggregateInputType | true
    _avg?: FoundationObjectiveAvgAggregateInputType
    _sum?: FoundationObjectiveSumAggregateInputType
    _min?: FoundationObjectiveMinAggregateInputType
    _max?: FoundationObjectiveMaxAggregateInputType
  }

  export type FoundationObjectiveGroupByOutputType = {
    id: number
    foundationId: number
    title: string
    description: string | null
    objectiveType: $Enums.ObjectiveType
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: FoundationObjectiveCountAggregateOutputType | null
    _avg: FoundationObjectiveAvgAggregateOutputType | null
    _sum: FoundationObjectiveSumAggregateOutputType | null
    _min: FoundationObjectiveMinAggregateOutputType | null
    _max: FoundationObjectiveMaxAggregateOutputType | null
  }

  type GetFoundationObjectiveGroupByPayload<T extends FoundationObjectiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoundationObjectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoundationObjectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoundationObjectiveGroupByOutputType[P]>
            : GetScalarType<T[P], FoundationObjectiveGroupByOutputType[P]>
        }
      >
    >


  export type FoundationObjectiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foundationId?: boolean
    title?: boolean
    description?: boolean
    objectiveType?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    foundation?: boolean | FoundationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foundationObjective"]>



  export type FoundationObjectiveSelectScalar = {
    id?: boolean
    foundationId?: boolean
    title?: boolean
    description?: boolean
    objectiveType?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoundationObjectiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "foundationId" | "title" | "description" | "objectiveType" | "displayOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["foundationObjective"]>
  export type FoundationObjectiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foundation?: boolean | FoundationDefaultArgs<ExtArgs>
  }

  export type $FoundationObjectivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoundationObjective"
    objects: {
      foundation: Prisma.$FoundationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      foundationId: number
      title: string
      description: string | null
      objectiveType: $Enums.ObjectiveType
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foundationObjective"]>
    composites: {}
  }

  type FoundationObjectiveGetPayload<S extends boolean | null | undefined | FoundationObjectiveDefaultArgs> = $Result.GetResult<Prisma.$FoundationObjectivePayload, S>

  type FoundationObjectiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoundationObjectiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoundationObjectiveCountAggregateInputType | true
    }

  export interface FoundationObjectiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoundationObjective'], meta: { name: 'FoundationObjective' } }
    /**
     * Find zero or one FoundationObjective that matches the filter.
     * @param {FoundationObjectiveFindUniqueArgs} args - Arguments to find a FoundationObjective
     * @example
     * // Get one FoundationObjective
     * const foundationObjective = await prisma.foundationObjective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoundationObjectiveFindUniqueArgs>(args: SelectSubset<T, FoundationObjectiveFindUniqueArgs<ExtArgs>>): Prisma__FoundationObjectiveClient<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoundationObjective that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoundationObjectiveFindUniqueOrThrowArgs} args - Arguments to find a FoundationObjective
     * @example
     * // Get one FoundationObjective
     * const foundationObjective = await prisma.foundationObjective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoundationObjectiveFindUniqueOrThrowArgs>(args: SelectSubset<T, FoundationObjectiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoundationObjectiveClient<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationObjective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationObjectiveFindFirstArgs} args - Arguments to find a FoundationObjective
     * @example
     * // Get one FoundationObjective
     * const foundationObjective = await prisma.foundationObjective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoundationObjectiveFindFirstArgs>(args?: SelectSubset<T, FoundationObjectiveFindFirstArgs<ExtArgs>>): Prisma__FoundationObjectiveClient<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationObjective that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationObjectiveFindFirstOrThrowArgs} args - Arguments to find a FoundationObjective
     * @example
     * // Get one FoundationObjective
     * const foundationObjective = await prisma.foundationObjective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoundationObjectiveFindFirstOrThrowArgs>(args?: SelectSubset<T, FoundationObjectiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoundationObjectiveClient<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoundationObjectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationObjectiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoundationObjectives
     * const foundationObjectives = await prisma.foundationObjective.findMany()
     * 
     * // Get first 10 FoundationObjectives
     * const foundationObjectives = await prisma.foundationObjective.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foundationObjectiveWithIdOnly = await prisma.foundationObjective.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoundationObjectiveFindManyArgs>(args?: SelectSubset<T, FoundationObjectiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoundationObjective.
     * @param {FoundationObjectiveCreateArgs} args - Arguments to create a FoundationObjective.
     * @example
     * // Create one FoundationObjective
     * const FoundationObjective = await prisma.foundationObjective.create({
     *   data: {
     *     // ... data to create a FoundationObjective
     *   }
     * })
     * 
     */
    create<T extends FoundationObjectiveCreateArgs>(args: SelectSubset<T, FoundationObjectiveCreateArgs<ExtArgs>>): Prisma__FoundationObjectiveClient<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoundationObjectives.
     * @param {FoundationObjectiveCreateManyArgs} args - Arguments to create many FoundationObjectives.
     * @example
     * // Create many FoundationObjectives
     * const foundationObjective = await prisma.foundationObjective.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoundationObjectiveCreateManyArgs>(args?: SelectSubset<T, FoundationObjectiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FoundationObjective.
     * @param {FoundationObjectiveDeleteArgs} args - Arguments to delete one FoundationObjective.
     * @example
     * // Delete one FoundationObjective
     * const FoundationObjective = await prisma.foundationObjective.delete({
     *   where: {
     *     // ... filter to delete one FoundationObjective
     *   }
     * })
     * 
     */
    delete<T extends FoundationObjectiveDeleteArgs>(args: SelectSubset<T, FoundationObjectiveDeleteArgs<ExtArgs>>): Prisma__FoundationObjectiveClient<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoundationObjective.
     * @param {FoundationObjectiveUpdateArgs} args - Arguments to update one FoundationObjective.
     * @example
     * // Update one FoundationObjective
     * const foundationObjective = await prisma.foundationObjective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoundationObjectiveUpdateArgs>(args: SelectSubset<T, FoundationObjectiveUpdateArgs<ExtArgs>>): Prisma__FoundationObjectiveClient<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoundationObjectives.
     * @param {FoundationObjectiveDeleteManyArgs} args - Arguments to filter FoundationObjectives to delete.
     * @example
     * // Delete a few FoundationObjectives
     * const { count } = await prisma.foundationObjective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoundationObjectiveDeleteManyArgs>(args?: SelectSubset<T, FoundationObjectiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoundationObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationObjectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoundationObjectives
     * const foundationObjective = await prisma.foundationObjective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoundationObjectiveUpdateManyArgs>(args: SelectSubset<T, FoundationObjectiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoundationObjective.
     * @param {FoundationObjectiveUpsertArgs} args - Arguments to update or create a FoundationObjective.
     * @example
     * // Update or create a FoundationObjective
     * const foundationObjective = await prisma.foundationObjective.upsert({
     *   create: {
     *     // ... data to create a FoundationObjective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoundationObjective we want to update
     *   }
     * })
     */
    upsert<T extends FoundationObjectiveUpsertArgs>(args: SelectSubset<T, FoundationObjectiveUpsertArgs<ExtArgs>>): Prisma__FoundationObjectiveClient<$Result.GetResult<Prisma.$FoundationObjectivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoundationObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationObjectiveCountArgs} args - Arguments to filter FoundationObjectives to count.
     * @example
     * // Count the number of FoundationObjectives
     * const count = await prisma.foundationObjective.count({
     *   where: {
     *     // ... the filter for the FoundationObjectives we want to count
     *   }
     * })
    **/
    count<T extends FoundationObjectiveCountArgs>(
      args?: Subset<T, FoundationObjectiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoundationObjectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoundationObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationObjectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoundationObjectiveAggregateArgs>(args: Subset<T, FoundationObjectiveAggregateArgs>): Prisma.PrismaPromise<GetFoundationObjectiveAggregateType<T>>

    /**
     * Group by FoundationObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationObjectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoundationObjectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoundationObjectiveGroupByArgs['orderBy'] }
        : { orderBy?: FoundationObjectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoundationObjectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoundationObjectiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoundationObjective model
   */
  readonly fields: FoundationObjectiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoundationObjective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoundationObjectiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    foundation<T extends FoundationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoundationDefaultArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoundationObjective model
   */
  interface FoundationObjectiveFieldRefs {
    readonly id: FieldRef<"FoundationObjective", 'Int'>
    readonly foundationId: FieldRef<"FoundationObjective", 'Int'>
    readonly title: FieldRef<"FoundationObjective", 'String'>
    readonly description: FieldRef<"FoundationObjective", 'String'>
    readonly objectiveType: FieldRef<"FoundationObjective", 'ObjectiveType'>
    readonly displayOrder: FieldRef<"FoundationObjective", 'Int'>
    readonly createdAt: FieldRef<"FoundationObjective", 'DateTime'>
    readonly updatedAt: FieldRef<"FoundationObjective", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoundationObjective findUnique
   */
  export type FoundationObjectiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which FoundationObjective to fetch.
     */
    where: FoundationObjectiveWhereUniqueInput
  }

  /**
   * FoundationObjective findUniqueOrThrow
   */
  export type FoundationObjectiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which FoundationObjective to fetch.
     */
    where: FoundationObjectiveWhereUniqueInput
  }

  /**
   * FoundationObjective findFirst
   */
  export type FoundationObjectiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which FoundationObjective to fetch.
     */
    where?: FoundationObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationObjectives to fetch.
     */
    orderBy?: FoundationObjectiveOrderByWithRelationInput | FoundationObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationObjectives.
     */
    cursor?: FoundationObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationObjectives.
     */
    distinct?: FoundationObjectiveScalarFieldEnum | FoundationObjectiveScalarFieldEnum[]
  }

  /**
   * FoundationObjective findFirstOrThrow
   */
  export type FoundationObjectiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which FoundationObjective to fetch.
     */
    where?: FoundationObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationObjectives to fetch.
     */
    orderBy?: FoundationObjectiveOrderByWithRelationInput | FoundationObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationObjectives.
     */
    cursor?: FoundationObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationObjectives.
     */
    distinct?: FoundationObjectiveScalarFieldEnum | FoundationObjectiveScalarFieldEnum[]
  }

  /**
   * FoundationObjective findMany
   */
  export type FoundationObjectiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which FoundationObjectives to fetch.
     */
    where?: FoundationObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationObjectives to fetch.
     */
    orderBy?: FoundationObjectiveOrderByWithRelationInput | FoundationObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoundationObjectives.
     */
    cursor?: FoundationObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationObjectives.
     */
    skip?: number
    distinct?: FoundationObjectiveScalarFieldEnum | FoundationObjectiveScalarFieldEnum[]
  }

  /**
   * FoundationObjective create
   */
  export type FoundationObjectiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to create a FoundationObjective.
     */
    data: XOR<FoundationObjectiveCreateInput, FoundationObjectiveUncheckedCreateInput>
  }

  /**
   * FoundationObjective createMany
   */
  export type FoundationObjectiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoundationObjectives.
     */
    data: FoundationObjectiveCreateManyInput | FoundationObjectiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoundationObjective update
   */
  export type FoundationObjectiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to update a FoundationObjective.
     */
    data: XOR<FoundationObjectiveUpdateInput, FoundationObjectiveUncheckedUpdateInput>
    /**
     * Choose, which FoundationObjective to update.
     */
    where: FoundationObjectiveWhereUniqueInput
  }

  /**
   * FoundationObjective updateMany
   */
  export type FoundationObjectiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoundationObjectives.
     */
    data: XOR<FoundationObjectiveUpdateManyMutationInput, FoundationObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which FoundationObjectives to update
     */
    where?: FoundationObjectiveWhereInput
    /**
     * Limit how many FoundationObjectives to update.
     */
    limit?: number
  }

  /**
   * FoundationObjective upsert
   */
  export type FoundationObjectiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * The filter to search for the FoundationObjective to update in case it exists.
     */
    where: FoundationObjectiveWhereUniqueInput
    /**
     * In case the FoundationObjective found by the `where` argument doesn't exist, create a new FoundationObjective with this data.
     */
    create: XOR<FoundationObjectiveCreateInput, FoundationObjectiveUncheckedCreateInput>
    /**
     * In case the FoundationObjective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoundationObjectiveUpdateInput, FoundationObjectiveUncheckedUpdateInput>
  }

  /**
   * FoundationObjective delete
   */
  export type FoundationObjectiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
    /**
     * Filter which FoundationObjective to delete.
     */
    where: FoundationObjectiveWhereUniqueInput
  }

  /**
   * FoundationObjective deleteMany
   */
  export type FoundationObjectiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationObjectives to delete
     */
    where?: FoundationObjectiveWhereInput
    /**
     * Limit how many FoundationObjectives to delete.
     */
    limit?: number
  }

  /**
   * FoundationObjective without action
   */
  export type FoundationObjectiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationObjective
     */
    select?: FoundationObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationObjective
     */
    omit?: FoundationObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationObjectiveInclude<ExtArgs> | null
  }


  /**
   * Model FoundationContact
   */

  export type AggregateFoundationContact = {
    _count: FoundationContactCountAggregateOutputType | null
    _avg: FoundationContactAvgAggregateOutputType | null
    _sum: FoundationContactSumAggregateOutputType | null
    _min: FoundationContactMinAggregateOutputType | null
    _max: FoundationContactMaxAggregateOutputType | null
  }

  export type FoundationContactAvgAggregateOutputType = {
    id: number | null
    foundationId: number | null
  }

  export type FoundationContactSumAggregateOutputType = {
    id: number | null
    foundationId: number | null
  }

  export type FoundationContactMinAggregateOutputType = {
    id: number | null
    foundationId: number | null
    email: string | null
    phone: string | null
    address: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoundationContactMaxAggregateOutputType = {
    id: number | null
    foundationId: number | null
    email: string | null
    phone: string | null
    address: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoundationContactCountAggregateOutputType = {
    id: number
    foundationId: number
    email: number
    phone: number
    address: number
    website: number
    socialMediaLinks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoundationContactAvgAggregateInputType = {
    id?: true
    foundationId?: true
  }

  export type FoundationContactSumAggregateInputType = {
    id?: true
    foundationId?: true
  }

  export type FoundationContactMinAggregateInputType = {
    id?: true
    foundationId?: true
    email?: true
    phone?: true
    address?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoundationContactMaxAggregateInputType = {
    id?: true
    foundationId?: true
    email?: true
    phone?: true
    address?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoundationContactCountAggregateInputType = {
    id?: true
    foundationId?: true
    email?: true
    phone?: true
    address?: true
    website?: true
    socialMediaLinks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoundationContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationContact to aggregate.
     */
    where?: FoundationContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationContacts to fetch.
     */
    orderBy?: FoundationContactOrderByWithRelationInput | FoundationContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoundationContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoundationContacts
    **/
    _count?: true | FoundationContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoundationContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoundationContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoundationContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoundationContactMaxAggregateInputType
  }

  export type GetFoundationContactAggregateType<T extends FoundationContactAggregateArgs> = {
        [P in keyof T & keyof AggregateFoundationContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoundationContact[P]>
      : GetScalarType<T[P], AggregateFoundationContact[P]>
  }




  export type FoundationContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationContactWhereInput
    orderBy?: FoundationContactOrderByWithAggregationInput | FoundationContactOrderByWithAggregationInput[]
    by: FoundationContactScalarFieldEnum[] | FoundationContactScalarFieldEnum
    having?: FoundationContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoundationContactCountAggregateInputType | true
    _avg?: FoundationContactAvgAggregateInputType
    _sum?: FoundationContactSumAggregateInputType
    _min?: FoundationContactMinAggregateInputType
    _max?: FoundationContactMaxAggregateInputType
  }

  export type FoundationContactGroupByOutputType = {
    id: number
    foundationId: number
    email: string | null
    phone: string | null
    address: string | null
    website: string | null
    socialMediaLinks: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: FoundationContactCountAggregateOutputType | null
    _avg: FoundationContactAvgAggregateOutputType | null
    _sum: FoundationContactSumAggregateOutputType | null
    _min: FoundationContactMinAggregateOutputType | null
    _max: FoundationContactMaxAggregateOutputType | null
  }

  type GetFoundationContactGroupByPayload<T extends FoundationContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoundationContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoundationContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoundationContactGroupByOutputType[P]>
            : GetScalarType<T[P], FoundationContactGroupByOutputType[P]>
        }
      >
    >


  export type FoundationContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foundationId?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    website?: boolean
    socialMediaLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    foundation?: boolean | FoundationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foundationContact"]>



  export type FoundationContactSelectScalar = {
    id?: boolean
    foundationId?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    website?: boolean
    socialMediaLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoundationContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "foundationId" | "email" | "phone" | "address" | "website" | "socialMediaLinks" | "createdAt" | "updatedAt", ExtArgs["result"]["foundationContact"]>
  export type FoundationContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foundation?: boolean | FoundationDefaultArgs<ExtArgs>
  }

  export type $FoundationContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoundationContact"
    objects: {
      foundation: Prisma.$FoundationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      foundationId: number
      email: string | null
      phone: string | null
      address: string | null
      website: string | null
      socialMediaLinks: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foundationContact"]>
    composites: {}
  }

  type FoundationContactGetPayload<S extends boolean | null | undefined | FoundationContactDefaultArgs> = $Result.GetResult<Prisma.$FoundationContactPayload, S>

  type FoundationContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoundationContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoundationContactCountAggregateInputType | true
    }

  export interface FoundationContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoundationContact'], meta: { name: 'FoundationContact' } }
    /**
     * Find zero or one FoundationContact that matches the filter.
     * @param {FoundationContactFindUniqueArgs} args - Arguments to find a FoundationContact
     * @example
     * // Get one FoundationContact
     * const foundationContact = await prisma.foundationContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoundationContactFindUniqueArgs>(args: SelectSubset<T, FoundationContactFindUniqueArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoundationContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoundationContactFindUniqueOrThrowArgs} args - Arguments to find a FoundationContact
     * @example
     * // Get one FoundationContact
     * const foundationContact = await prisma.foundationContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoundationContactFindUniqueOrThrowArgs>(args: SelectSubset<T, FoundationContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationContactFindFirstArgs} args - Arguments to find a FoundationContact
     * @example
     * // Get one FoundationContact
     * const foundationContact = await prisma.foundationContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoundationContactFindFirstArgs>(args?: SelectSubset<T, FoundationContactFindFirstArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationContactFindFirstOrThrowArgs} args - Arguments to find a FoundationContact
     * @example
     * // Get one FoundationContact
     * const foundationContact = await prisma.foundationContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoundationContactFindFirstOrThrowArgs>(args?: SelectSubset<T, FoundationContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoundationContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoundationContacts
     * const foundationContacts = await prisma.foundationContact.findMany()
     * 
     * // Get first 10 FoundationContacts
     * const foundationContacts = await prisma.foundationContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foundationContactWithIdOnly = await prisma.foundationContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoundationContactFindManyArgs>(args?: SelectSubset<T, FoundationContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoundationContact.
     * @param {FoundationContactCreateArgs} args - Arguments to create a FoundationContact.
     * @example
     * // Create one FoundationContact
     * const FoundationContact = await prisma.foundationContact.create({
     *   data: {
     *     // ... data to create a FoundationContact
     *   }
     * })
     * 
     */
    create<T extends FoundationContactCreateArgs>(args: SelectSubset<T, FoundationContactCreateArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoundationContacts.
     * @param {FoundationContactCreateManyArgs} args - Arguments to create many FoundationContacts.
     * @example
     * // Create many FoundationContacts
     * const foundationContact = await prisma.foundationContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoundationContactCreateManyArgs>(args?: SelectSubset<T, FoundationContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FoundationContact.
     * @param {FoundationContactDeleteArgs} args - Arguments to delete one FoundationContact.
     * @example
     * // Delete one FoundationContact
     * const FoundationContact = await prisma.foundationContact.delete({
     *   where: {
     *     // ... filter to delete one FoundationContact
     *   }
     * })
     * 
     */
    delete<T extends FoundationContactDeleteArgs>(args: SelectSubset<T, FoundationContactDeleteArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoundationContact.
     * @param {FoundationContactUpdateArgs} args - Arguments to update one FoundationContact.
     * @example
     * // Update one FoundationContact
     * const foundationContact = await prisma.foundationContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoundationContactUpdateArgs>(args: SelectSubset<T, FoundationContactUpdateArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoundationContacts.
     * @param {FoundationContactDeleteManyArgs} args - Arguments to filter FoundationContacts to delete.
     * @example
     * // Delete a few FoundationContacts
     * const { count } = await prisma.foundationContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoundationContactDeleteManyArgs>(args?: SelectSubset<T, FoundationContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoundationContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoundationContacts
     * const foundationContact = await prisma.foundationContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoundationContactUpdateManyArgs>(args: SelectSubset<T, FoundationContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoundationContact.
     * @param {FoundationContactUpsertArgs} args - Arguments to update or create a FoundationContact.
     * @example
     * // Update or create a FoundationContact
     * const foundationContact = await prisma.foundationContact.upsert({
     *   create: {
     *     // ... data to create a FoundationContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoundationContact we want to update
     *   }
     * })
     */
    upsert<T extends FoundationContactUpsertArgs>(args: SelectSubset<T, FoundationContactUpsertArgs<ExtArgs>>): Prisma__FoundationContactClient<$Result.GetResult<Prisma.$FoundationContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoundationContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationContactCountArgs} args - Arguments to filter FoundationContacts to count.
     * @example
     * // Count the number of FoundationContacts
     * const count = await prisma.foundationContact.count({
     *   where: {
     *     // ... the filter for the FoundationContacts we want to count
     *   }
     * })
    **/
    count<T extends FoundationContactCountArgs>(
      args?: Subset<T, FoundationContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoundationContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoundationContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoundationContactAggregateArgs>(args: Subset<T, FoundationContactAggregateArgs>): Prisma.PrismaPromise<GetFoundationContactAggregateType<T>>

    /**
     * Group by FoundationContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoundationContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoundationContactGroupByArgs['orderBy'] }
        : { orderBy?: FoundationContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoundationContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoundationContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoundationContact model
   */
  readonly fields: FoundationContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoundationContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoundationContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    foundation<T extends FoundationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoundationDefaultArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoundationContact model
   */
  interface FoundationContactFieldRefs {
    readonly id: FieldRef<"FoundationContact", 'Int'>
    readonly foundationId: FieldRef<"FoundationContact", 'Int'>
    readonly email: FieldRef<"FoundationContact", 'String'>
    readonly phone: FieldRef<"FoundationContact", 'String'>
    readonly address: FieldRef<"FoundationContact", 'String'>
    readonly website: FieldRef<"FoundationContact", 'String'>
    readonly socialMediaLinks: FieldRef<"FoundationContact", 'Json'>
    readonly createdAt: FieldRef<"FoundationContact", 'DateTime'>
    readonly updatedAt: FieldRef<"FoundationContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoundationContact findUnique
   */
  export type FoundationContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * Filter, which FoundationContact to fetch.
     */
    where: FoundationContactWhereUniqueInput
  }

  /**
   * FoundationContact findUniqueOrThrow
   */
  export type FoundationContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * Filter, which FoundationContact to fetch.
     */
    where: FoundationContactWhereUniqueInput
  }

  /**
   * FoundationContact findFirst
   */
  export type FoundationContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * Filter, which FoundationContact to fetch.
     */
    where?: FoundationContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationContacts to fetch.
     */
    orderBy?: FoundationContactOrderByWithRelationInput | FoundationContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationContacts.
     */
    cursor?: FoundationContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationContacts.
     */
    distinct?: FoundationContactScalarFieldEnum | FoundationContactScalarFieldEnum[]
  }

  /**
   * FoundationContact findFirstOrThrow
   */
  export type FoundationContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * Filter, which FoundationContact to fetch.
     */
    where?: FoundationContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationContacts to fetch.
     */
    orderBy?: FoundationContactOrderByWithRelationInput | FoundationContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationContacts.
     */
    cursor?: FoundationContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationContacts.
     */
    distinct?: FoundationContactScalarFieldEnum | FoundationContactScalarFieldEnum[]
  }

  /**
   * FoundationContact findMany
   */
  export type FoundationContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * Filter, which FoundationContacts to fetch.
     */
    where?: FoundationContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationContacts to fetch.
     */
    orderBy?: FoundationContactOrderByWithRelationInput | FoundationContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoundationContacts.
     */
    cursor?: FoundationContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationContacts.
     */
    skip?: number
    distinct?: FoundationContactScalarFieldEnum | FoundationContactScalarFieldEnum[]
  }

  /**
   * FoundationContact create
   */
  export type FoundationContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * The data needed to create a FoundationContact.
     */
    data: XOR<FoundationContactCreateInput, FoundationContactUncheckedCreateInput>
  }

  /**
   * FoundationContact createMany
   */
  export type FoundationContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoundationContacts.
     */
    data: FoundationContactCreateManyInput | FoundationContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoundationContact update
   */
  export type FoundationContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * The data needed to update a FoundationContact.
     */
    data: XOR<FoundationContactUpdateInput, FoundationContactUncheckedUpdateInput>
    /**
     * Choose, which FoundationContact to update.
     */
    where: FoundationContactWhereUniqueInput
  }

  /**
   * FoundationContact updateMany
   */
  export type FoundationContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoundationContacts.
     */
    data: XOR<FoundationContactUpdateManyMutationInput, FoundationContactUncheckedUpdateManyInput>
    /**
     * Filter which FoundationContacts to update
     */
    where?: FoundationContactWhereInput
    /**
     * Limit how many FoundationContacts to update.
     */
    limit?: number
  }

  /**
   * FoundationContact upsert
   */
  export type FoundationContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * The filter to search for the FoundationContact to update in case it exists.
     */
    where: FoundationContactWhereUniqueInput
    /**
     * In case the FoundationContact found by the `where` argument doesn't exist, create a new FoundationContact with this data.
     */
    create: XOR<FoundationContactCreateInput, FoundationContactUncheckedCreateInput>
    /**
     * In case the FoundationContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoundationContactUpdateInput, FoundationContactUncheckedUpdateInput>
  }

  /**
   * FoundationContact delete
   */
  export type FoundationContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
    /**
     * Filter which FoundationContact to delete.
     */
    where: FoundationContactWhereUniqueInput
  }

  /**
   * FoundationContact deleteMany
   */
  export type FoundationContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationContacts to delete
     */
    where?: FoundationContactWhereInput
    /**
     * Limit how many FoundationContacts to delete.
     */
    limit?: number
  }

  /**
   * FoundationContact without action
   */
  export type FoundationContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationContact
     */
    select?: FoundationContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationContact
     */
    omit?: FoundationContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationContactInclude<ExtArgs> | null
  }


  /**
   * Model FoundationMedia
   */

  export type AggregateFoundationMedia = {
    _count: FoundationMediaCountAggregateOutputType | null
    _avg: FoundationMediaAvgAggregateOutputType | null
    _sum: FoundationMediaSumAggregateOutputType | null
    _min: FoundationMediaMinAggregateOutputType | null
    _max: FoundationMediaMaxAggregateOutputType | null
  }

  export type FoundationMediaAvgAggregateOutputType = {
    id: number | null
    foundationId: number | null
    fileSize: number | null
  }

  export type FoundationMediaSumAggregateOutputType = {
    id: number | null
    foundationId: number | null
    fileSize: number | null
  }

  export type FoundationMediaMinAggregateOutputType = {
    id: number | null
    foundationId: number | null
    fileName: string | null
    filePath: string | null
    fileType: string | null
    fileSize: number | null
    mediaType: $Enums.MediaType | null
    altText: string | null
    createdAt: Date | null
  }

  export type FoundationMediaMaxAggregateOutputType = {
    id: number | null
    foundationId: number | null
    fileName: string | null
    filePath: string | null
    fileType: string | null
    fileSize: number | null
    mediaType: $Enums.MediaType | null
    altText: string | null
    createdAt: Date | null
  }

  export type FoundationMediaCountAggregateOutputType = {
    id: number
    foundationId: number
    fileName: number
    filePath: number
    fileType: number
    fileSize: number
    mediaType: number
    altText: number
    createdAt: number
    _all: number
  }


  export type FoundationMediaAvgAggregateInputType = {
    id?: true
    foundationId?: true
    fileSize?: true
  }

  export type FoundationMediaSumAggregateInputType = {
    id?: true
    foundationId?: true
    fileSize?: true
  }

  export type FoundationMediaMinAggregateInputType = {
    id?: true
    foundationId?: true
    fileName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    mediaType?: true
    altText?: true
    createdAt?: true
  }

  export type FoundationMediaMaxAggregateInputType = {
    id?: true
    foundationId?: true
    fileName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    mediaType?: true
    altText?: true
    createdAt?: true
  }

  export type FoundationMediaCountAggregateInputType = {
    id?: true
    foundationId?: true
    fileName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    mediaType?: true
    altText?: true
    createdAt?: true
    _all?: true
  }

  export type FoundationMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationMedia to aggregate.
     */
    where?: FoundationMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationMedias to fetch.
     */
    orderBy?: FoundationMediaOrderByWithRelationInput | FoundationMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoundationMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoundationMedias
    **/
    _count?: true | FoundationMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoundationMediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoundationMediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoundationMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoundationMediaMaxAggregateInputType
  }

  export type GetFoundationMediaAggregateType<T extends FoundationMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateFoundationMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoundationMedia[P]>
      : GetScalarType<T[P], AggregateFoundationMedia[P]>
  }




  export type FoundationMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoundationMediaWhereInput
    orderBy?: FoundationMediaOrderByWithAggregationInput | FoundationMediaOrderByWithAggregationInput[]
    by: FoundationMediaScalarFieldEnum[] | FoundationMediaScalarFieldEnum
    having?: FoundationMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoundationMediaCountAggregateInputType | true
    _avg?: FoundationMediaAvgAggregateInputType
    _sum?: FoundationMediaSumAggregateInputType
    _min?: FoundationMediaMinAggregateInputType
    _max?: FoundationMediaMaxAggregateInputType
  }

  export type FoundationMediaGroupByOutputType = {
    id: number
    foundationId: number | null
    fileName: string
    filePath: string
    fileType: string | null
    fileSize: number | null
    mediaType: $Enums.MediaType
    altText: string | null
    createdAt: Date
    _count: FoundationMediaCountAggregateOutputType | null
    _avg: FoundationMediaAvgAggregateOutputType | null
    _sum: FoundationMediaSumAggregateOutputType | null
    _min: FoundationMediaMinAggregateOutputType | null
    _max: FoundationMediaMaxAggregateOutputType | null
  }

  type GetFoundationMediaGroupByPayload<T extends FoundationMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoundationMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoundationMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoundationMediaGroupByOutputType[P]>
            : GetScalarType<T[P], FoundationMediaGroupByOutputType[P]>
        }
      >
    >


  export type FoundationMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foundationId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileType?: boolean
    fileSize?: boolean
    mediaType?: boolean
    altText?: boolean
    createdAt?: boolean
    foundation?: boolean | FoundationMedia$foundationArgs<ExtArgs>
  }, ExtArgs["result"]["foundationMedia"]>



  export type FoundationMediaSelectScalar = {
    id?: boolean
    foundationId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileType?: boolean
    fileSize?: boolean
    mediaType?: boolean
    altText?: boolean
    createdAt?: boolean
  }

  export type FoundationMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "foundationId" | "fileName" | "filePath" | "fileType" | "fileSize" | "mediaType" | "altText" | "createdAt", ExtArgs["result"]["foundationMedia"]>
  export type FoundationMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foundation?: boolean | FoundationMedia$foundationArgs<ExtArgs>
  }

  export type $FoundationMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoundationMedia"
    objects: {
      foundation: Prisma.$FoundationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      foundationId: number | null
      fileName: string
      filePath: string
      fileType: string | null
      fileSize: number | null
      mediaType: $Enums.MediaType
      altText: string | null
      createdAt: Date
    }, ExtArgs["result"]["foundationMedia"]>
    composites: {}
  }

  type FoundationMediaGetPayload<S extends boolean | null | undefined | FoundationMediaDefaultArgs> = $Result.GetResult<Prisma.$FoundationMediaPayload, S>

  type FoundationMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoundationMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoundationMediaCountAggregateInputType | true
    }

  export interface FoundationMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoundationMedia'], meta: { name: 'FoundationMedia' } }
    /**
     * Find zero or one FoundationMedia that matches the filter.
     * @param {FoundationMediaFindUniqueArgs} args - Arguments to find a FoundationMedia
     * @example
     * // Get one FoundationMedia
     * const foundationMedia = await prisma.foundationMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoundationMediaFindUniqueArgs>(args: SelectSubset<T, FoundationMediaFindUniqueArgs<ExtArgs>>): Prisma__FoundationMediaClient<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoundationMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoundationMediaFindUniqueOrThrowArgs} args - Arguments to find a FoundationMedia
     * @example
     * // Get one FoundationMedia
     * const foundationMedia = await prisma.foundationMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoundationMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, FoundationMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoundationMediaClient<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationMediaFindFirstArgs} args - Arguments to find a FoundationMedia
     * @example
     * // Get one FoundationMedia
     * const foundationMedia = await prisma.foundationMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoundationMediaFindFirstArgs>(args?: SelectSubset<T, FoundationMediaFindFirstArgs<ExtArgs>>): Prisma__FoundationMediaClient<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoundationMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationMediaFindFirstOrThrowArgs} args - Arguments to find a FoundationMedia
     * @example
     * // Get one FoundationMedia
     * const foundationMedia = await prisma.foundationMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoundationMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, FoundationMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoundationMediaClient<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoundationMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoundationMedias
     * const foundationMedias = await prisma.foundationMedia.findMany()
     * 
     * // Get first 10 FoundationMedias
     * const foundationMedias = await prisma.foundationMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foundationMediaWithIdOnly = await prisma.foundationMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoundationMediaFindManyArgs>(args?: SelectSubset<T, FoundationMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoundationMedia.
     * @param {FoundationMediaCreateArgs} args - Arguments to create a FoundationMedia.
     * @example
     * // Create one FoundationMedia
     * const FoundationMedia = await prisma.foundationMedia.create({
     *   data: {
     *     // ... data to create a FoundationMedia
     *   }
     * })
     * 
     */
    create<T extends FoundationMediaCreateArgs>(args: SelectSubset<T, FoundationMediaCreateArgs<ExtArgs>>): Prisma__FoundationMediaClient<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoundationMedias.
     * @param {FoundationMediaCreateManyArgs} args - Arguments to create many FoundationMedias.
     * @example
     * // Create many FoundationMedias
     * const foundationMedia = await prisma.foundationMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoundationMediaCreateManyArgs>(args?: SelectSubset<T, FoundationMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FoundationMedia.
     * @param {FoundationMediaDeleteArgs} args - Arguments to delete one FoundationMedia.
     * @example
     * // Delete one FoundationMedia
     * const FoundationMedia = await prisma.foundationMedia.delete({
     *   where: {
     *     // ... filter to delete one FoundationMedia
     *   }
     * })
     * 
     */
    delete<T extends FoundationMediaDeleteArgs>(args: SelectSubset<T, FoundationMediaDeleteArgs<ExtArgs>>): Prisma__FoundationMediaClient<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoundationMedia.
     * @param {FoundationMediaUpdateArgs} args - Arguments to update one FoundationMedia.
     * @example
     * // Update one FoundationMedia
     * const foundationMedia = await prisma.foundationMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoundationMediaUpdateArgs>(args: SelectSubset<T, FoundationMediaUpdateArgs<ExtArgs>>): Prisma__FoundationMediaClient<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoundationMedias.
     * @param {FoundationMediaDeleteManyArgs} args - Arguments to filter FoundationMedias to delete.
     * @example
     * // Delete a few FoundationMedias
     * const { count } = await prisma.foundationMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoundationMediaDeleteManyArgs>(args?: SelectSubset<T, FoundationMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoundationMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoundationMedias
     * const foundationMedia = await prisma.foundationMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoundationMediaUpdateManyArgs>(args: SelectSubset<T, FoundationMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoundationMedia.
     * @param {FoundationMediaUpsertArgs} args - Arguments to update or create a FoundationMedia.
     * @example
     * // Update or create a FoundationMedia
     * const foundationMedia = await prisma.foundationMedia.upsert({
     *   create: {
     *     // ... data to create a FoundationMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoundationMedia we want to update
     *   }
     * })
     */
    upsert<T extends FoundationMediaUpsertArgs>(args: SelectSubset<T, FoundationMediaUpsertArgs<ExtArgs>>): Prisma__FoundationMediaClient<$Result.GetResult<Prisma.$FoundationMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoundationMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationMediaCountArgs} args - Arguments to filter FoundationMedias to count.
     * @example
     * // Count the number of FoundationMedias
     * const count = await prisma.foundationMedia.count({
     *   where: {
     *     // ... the filter for the FoundationMedias we want to count
     *   }
     * })
    **/
    count<T extends FoundationMediaCountArgs>(
      args?: Subset<T, FoundationMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoundationMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoundationMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoundationMediaAggregateArgs>(args: Subset<T, FoundationMediaAggregateArgs>): Prisma.PrismaPromise<GetFoundationMediaAggregateType<T>>

    /**
     * Group by FoundationMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundationMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoundationMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoundationMediaGroupByArgs['orderBy'] }
        : { orderBy?: FoundationMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoundationMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoundationMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoundationMedia model
   */
  readonly fields: FoundationMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoundationMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoundationMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    foundation<T extends FoundationMedia$foundationArgs<ExtArgs> = {}>(args?: Subset<T, FoundationMedia$foundationArgs<ExtArgs>>): Prisma__FoundationClient<$Result.GetResult<Prisma.$FoundationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoundationMedia model
   */
  interface FoundationMediaFieldRefs {
    readonly id: FieldRef<"FoundationMedia", 'Int'>
    readonly foundationId: FieldRef<"FoundationMedia", 'Int'>
    readonly fileName: FieldRef<"FoundationMedia", 'String'>
    readonly filePath: FieldRef<"FoundationMedia", 'String'>
    readonly fileType: FieldRef<"FoundationMedia", 'String'>
    readonly fileSize: FieldRef<"FoundationMedia", 'Int'>
    readonly mediaType: FieldRef<"FoundationMedia", 'MediaType'>
    readonly altText: FieldRef<"FoundationMedia", 'String'>
    readonly createdAt: FieldRef<"FoundationMedia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoundationMedia findUnique
   */
  export type FoundationMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * Filter, which FoundationMedia to fetch.
     */
    where: FoundationMediaWhereUniqueInput
  }

  /**
   * FoundationMedia findUniqueOrThrow
   */
  export type FoundationMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * Filter, which FoundationMedia to fetch.
     */
    where: FoundationMediaWhereUniqueInput
  }

  /**
   * FoundationMedia findFirst
   */
  export type FoundationMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * Filter, which FoundationMedia to fetch.
     */
    where?: FoundationMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationMedias to fetch.
     */
    orderBy?: FoundationMediaOrderByWithRelationInput | FoundationMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationMedias.
     */
    cursor?: FoundationMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationMedias.
     */
    distinct?: FoundationMediaScalarFieldEnum | FoundationMediaScalarFieldEnum[]
  }

  /**
   * FoundationMedia findFirstOrThrow
   */
  export type FoundationMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * Filter, which FoundationMedia to fetch.
     */
    where?: FoundationMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationMedias to fetch.
     */
    orderBy?: FoundationMediaOrderByWithRelationInput | FoundationMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoundationMedias.
     */
    cursor?: FoundationMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoundationMedias.
     */
    distinct?: FoundationMediaScalarFieldEnum | FoundationMediaScalarFieldEnum[]
  }

  /**
   * FoundationMedia findMany
   */
  export type FoundationMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * Filter, which FoundationMedias to fetch.
     */
    where?: FoundationMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoundationMedias to fetch.
     */
    orderBy?: FoundationMediaOrderByWithRelationInput | FoundationMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoundationMedias.
     */
    cursor?: FoundationMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoundationMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoundationMedias.
     */
    skip?: number
    distinct?: FoundationMediaScalarFieldEnum | FoundationMediaScalarFieldEnum[]
  }

  /**
   * FoundationMedia create
   */
  export type FoundationMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a FoundationMedia.
     */
    data: XOR<FoundationMediaCreateInput, FoundationMediaUncheckedCreateInput>
  }

  /**
   * FoundationMedia createMany
   */
  export type FoundationMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoundationMedias.
     */
    data: FoundationMediaCreateManyInput | FoundationMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoundationMedia update
   */
  export type FoundationMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a FoundationMedia.
     */
    data: XOR<FoundationMediaUpdateInput, FoundationMediaUncheckedUpdateInput>
    /**
     * Choose, which FoundationMedia to update.
     */
    where: FoundationMediaWhereUniqueInput
  }

  /**
   * FoundationMedia updateMany
   */
  export type FoundationMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoundationMedias.
     */
    data: XOR<FoundationMediaUpdateManyMutationInput, FoundationMediaUncheckedUpdateManyInput>
    /**
     * Filter which FoundationMedias to update
     */
    where?: FoundationMediaWhereInput
    /**
     * Limit how many FoundationMedias to update.
     */
    limit?: number
  }

  /**
   * FoundationMedia upsert
   */
  export type FoundationMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the FoundationMedia to update in case it exists.
     */
    where: FoundationMediaWhereUniqueInput
    /**
     * In case the FoundationMedia found by the `where` argument doesn't exist, create a new FoundationMedia with this data.
     */
    create: XOR<FoundationMediaCreateInput, FoundationMediaUncheckedCreateInput>
    /**
     * In case the FoundationMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoundationMediaUpdateInput, FoundationMediaUncheckedUpdateInput>
  }

  /**
   * FoundationMedia delete
   */
  export type FoundationMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
    /**
     * Filter which FoundationMedia to delete.
     */
    where: FoundationMediaWhereUniqueInput
  }

  /**
   * FoundationMedia deleteMany
   */
  export type FoundationMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoundationMedias to delete
     */
    where?: FoundationMediaWhereInput
    /**
     * Limit how many FoundationMedias to delete.
     */
    limit?: number
  }

  /**
   * FoundationMedia.foundation
   */
  export type FoundationMedia$foundationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foundation
     */
    select?: FoundationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Foundation
     */
    omit?: FoundationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationInclude<ExtArgs> | null
    where?: FoundationWhereInput
  }

  /**
   * FoundationMedia without action
   */
  export type FoundationMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundationMedia
     */
    select?: FoundationMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoundationMedia
     */
    omit?: FoundationMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoundationMediaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    image: 'image',
    address: 'address',
    phone: 'phone',
    otpCode: 'otpCode',
    otpExpires: 'otpExpires',
    resetToken: 'resetToken',
    resetTokenExpires: 'resetTokenExpires',
    isVerified: 'isVerified',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    providerType: 'providerType',
    providerId: 'providerId',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const DonationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    status: 'status',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DonationScalarFieldEnum = (typeof DonationScalarFieldEnum)[keyof typeof DonationScalarFieldEnum]


  export const PdfBookScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    price: 'price',
    pdfUrl: 'pdfUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PdfBookScalarFieldEnum = (typeof PdfBookScalarFieldEnum)[keyof typeof PdfBookScalarFieldEnum]


  export const PdfOrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    pdfBookId: 'pdfBookId',
    quantity: 'quantity',
    totalPrice: 'totalPrice',
    status: 'status',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PdfOrderScalarFieldEnum = (typeof PdfOrderScalarFieldEnum)[keyof typeof PdfOrderScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    referenceId: 'referenceId',
    provider: 'provider',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const NewsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    titleEn: 'titleEn',
    slug: 'slug',
    featuredImage: 'featuredImage',
    authorName: 'authorName',
    authorAvatar: 'authorAvatar',
    authorRole: 'authorRole',
    publishedDate: 'publishedDate',
    readTime: 'readTime',
    views: 'views',
    category: 'category',
    tags: 'tags',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NewsScalarFieldEnum = (typeof NewsScalarFieldEnum)[keyof typeof NewsScalarFieldEnum]


  export const GopalPariwarScalarFieldEnum: {
    id: 'id',
    heroImage: 'heroImage',
    heroTitle: 'heroTitle',
    heroSubtitle: 'heroSubtitle',
    personalInfo: 'personalInfo',
    spiritualEducation: 'spiritualEducation',
    lifeJourney: 'lifeJourney',
    responsibilities: 'responsibilities',
    pledges: 'pledges',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GopalPariwarScalarFieldEnum = (typeof GopalPariwarScalarFieldEnum)[keyof typeof GopalPariwarScalarFieldEnum]


  export const GaushalaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    establishmentYear: 'establishmentYear',
    contactDetails: 'contactDetails',
    totalCows: 'totalCows',
    capacity: 'capacity',
    description: 'description',
    city: 'city',
    state: 'state',
    pincode: 'pincode',
    contactPerson: 'contactPerson',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GaushalaScalarFieldEnum = (typeof GaushalaScalarFieldEnum)[keyof typeof GaushalaScalarFieldEnum]


  export const CardScalarFieldEnum: {
    id: 'id',
    title: 'title',
    titleEn: 'titleEn',
    link: 'link',
    image: 'image',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CardScalarFieldEnum = (typeof CardScalarFieldEnum)[keyof typeof CardScalarFieldEnum]


  export const DtaSanssthanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    person: 'person',
    image: 'image',
    description: 'description',
    email: 'email',
    phone: 'phone',
    altPhone: 'altPhone',
    website: 'website',
    timing: 'timing',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DtaSanssthanScalarFieldEnum = (typeof DtaSanssthanScalarFieldEnum)[keyof typeof DtaSanssthanScalarFieldEnum]


  export const PrivacyPolicyScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    sections: 'sections',
    email: 'email',
    phone: 'phone',
    callingHours: 'callingHours',
    mailingAddress: 'mailingAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PrivacyPolicyScalarFieldEnum = (typeof PrivacyPolicyScalarFieldEnum)[keyof typeof PrivacyPolicyScalarFieldEnum]


  export const TermsConditionsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    sections: 'sections',
    email: 'email',
    phone: 'phone',
    callingHours: 'callingHours',
    mailingAddress: 'mailingAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TermsConditionsScalarFieldEnum = (typeof TermsConditionsScalarFieldEnum)[keyof typeof TermsConditionsScalarFieldEnum]


  export const BannerScalarFieldEnum: {
    id: 'id',
    title: 'title',
    image: 'image',
    active: 'active',
    order: 'order',
    publicId: 'publicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BannerScalarFieldEnum = (typeof BannerScalarFieldEnum)[keyof typeof BannerScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    info: 'info',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const FoundationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tagline: 'tagline',
    logoUrl: 'logoUrl',
    description: 'description',
    establishedYear: 'establishedYear',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type FoundationScalarFieldEnum = (typeof FoundationScalarFieldEnum)[keyof typeof FoundationScalarFieldEnum]


  export const FoundationStatScalarFieldEnum: {
    id: 'id',
    foundationId: 'foundationId',
    label: 'label',
    value: 'value',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoundationStatScalarFieldEnum = (typeof FoundationStatScalarFieldEnum)[keyof typeof FoundationStatScalarFieldEnum]


  export const FoundationActivityScalarFieldEnum: {
    id: 'id',
    foundationId: 'foundationId',
    activityText: 'activityText',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoundationActivityScalarFieldEnum = (typeof FoundationActivityScalarFieldEnum)[keyof typeof FoundationActivityScalarFieldEnum]


  export const FoundationObjectiveScalarFieldEnum: {
    id: 'id',
    foundationId: 'foundationId',
    title: 'title',
    description: 'description',
    objectiveType: 'objectiveType',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoundationObjectiveScalarFieldEnum = (typeof FoundationObjectiveScalarFieldEnum)[keyof typeof FoundationObjectiveScalarFieldEnum]


  export const FoundationContactScalarFieldEnum: {
    id: 'id',
    foundationId: 'foundationId',
    email: 'email',
    phone: 'phone',
    address: 'address',
    website: 'website',
    socialMediaLinks: 'socialMediaLinks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoundationContactScalarFieldEnum = (typeof FoundationContactScalarFieldEnum)[keyof typeof FoundationContactScalarFieldEnum]


  export const FoundationMediaScalarFieldEnum: {
    id: 'id',
    foundationId: 'foundationId',
    fileName: 'fileName',
    filePath: 'filePath',
    fileType: 'fileType',
    fileSize: 'fileSize',
    mediaType: 'mediaType',
    altText: 'altText',
    createdAt: 'createdAt'
  };

  export type FoundationMediaScalarFieldEnum = (typeof FoundationMediaScalarFieldEnum)[keyof typeof FoundationMediaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    password: 'password',
    image: 'image',
    address: 'address',
    phone: 'phone',
    otpCode: 'otpCode',
    resetToken: 'resetToken',
    role: 'role'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const AccountOrderByRelevanceFieldEnum: {
    providerType: 'providerType',
    providerId: 'providerId',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


  export const SessionOrderByRelevanceFieldEnum: {
    sessionToken: 'sessionToken'
  };

  export type SessionOrderByRelevanceFieldEnum = (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum]


  export const DonationOrderByRelevanceFieldEnum: {
    status: 'status',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId'
  };

  export type DonationOrderByRelevanceFieldEnum = (typeof DonationOrderByRelevanceFieldEnum)[keyof typeof DonationOrderByRelevanceFieldEnum]


  export const PdfBookOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    pdfUrl: 'pdfUrl'
  };

  export type PdfBookOrderByRelevanceFieldEnum = (typeof PdfBookOrderByRelevanceFieldEnum)[keyof typeof PdfBookOrderByRelevanceFieldEnum]


  export const PdfOrderOrderByRelevanceFieldEnum: {
    status: 'status',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId'
  };

  export type PdfOrderOrderByRelevanceFieldEnum = (typeof PdfOrderOrderByRelevanceFieldEnum)[keyof typeof PdfOrderOrderByRelevanceFieldEnum]


  export const PaymentOrderByRelevanceFieldEnum: {
    referenceId: 'referenceId',
    provider: 'provider',
    status: 'status'
  };

  export type PaymentOrderByRelevanceFieldEnum = (typeof PaymentOrderByRelevanceFieldEnum)[keyof typeof PaymentOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NewsOrderByRelevanceFieldEnum: {
    title: 'title',
    titleEn: 'titleEn',
    slug: 'slug',
    featuredImage: 'featuredImage',
    authorName: 'authorName',
    authorAvatar: 'authorAvatar',
    authorRole: 'authorRole',
    publishedDate: 'publishedDate',
    readTime: 'readTime',
    views: 'views',
    category: 'category',
    tags: 'tags'
  };

  export type NewsOrderByRelevanceFieldEnum = (typeof NewsOrderByRelevanceFieldEnum)[keyof typeof NewsOrderByRelevanceFieldEnum]


  export const GopalPariwarOrderByRelevanceFieldEnum: {
    heroImage: 'heroImage',
    heroTitle: 'heroTitle',
    heroSubtitle: 'heroSubtitle',
    spiritualEducation: 'spiritualEducation'
  };

  export type GopalPariwarOrderByRelevanceFieldEnum = (typeof GopalPariwarOrderByRelevanceFieldEnum)[keyof typeof GopalPariwarOrderByRelevanceFieldEnum]


  export const GaushalaOrderByRelevanceFieldEnum: {
    name: 'name',
    address: 'address',
    contactDetails: 'contactDetails',
    description: 'description',
    city: 'city',
    state: 'state',
    pincode: 'pincode',
    contactPerson: 'contactPerson'
  };

  export type GaushalaOrderByRelevanceFieldEnum = (typeof GaushalaOrderByRelevanceFieldEnum)[keyof typeof GaushalaOrderByRelevanceFieldEnum]


  export const CardOrderByRelevanceFieldEnum: {
    title: 'title',
    titleEn: 'titleEn',
    link: 'link',
    image: 'image'
  };

  export type CardOrderByRelevanceFieldEnum = (typeof CardOrderByRelevanceFieldEnum)[keyof typeof CardOrderByRelevanceFieldEnum]


  export const DtaSanssthanOrderByRelevanceFieldEnum: {
    name: 'name',
    person: 'person',
    image: 'image',
    description: 'description',
    email: 'email',
    phone: 'phone',
    altPhone: 'altPhone',
    website: 'website',
    timing: 'timing'
  };

  export type DtaSanssthanOrderByRelevanceFieldEnum = (typeof DtaSanssthanOrderByRelevanceFieldEnum)[keyof typeof DtaSanssthanOrderByRelevanceFieldEnum]


  export const PrivacyPolicyOrderByRelevanceFieldEnum: {
    title: 'title',
    subtitle: 'subtitle',
    email: 'email',
    phone: 'phone',
    callingHours: 'callingHours',
    mailingAddress: 'mailingAddress'
  };

  export type PrivacyPolicyOrderByRelevanceFieldEnum = (typeof PrivacyPolicyOrderByRelevanceFieldEnum)[keyof typeof PrivacyPolicyOrderByRelevanceFieldEnum]


  export const TermsConditionsOrderByRelevanceFieldEnum: {
    title: 'title',
    subtitle: 'subtitle',
    email: 'email',
    phone: 'phone',
    callingHours: 'callingHours',
    mailingAddress: 'mailingAddress'
  };

  export type TermsConditionsOrderByRelevanceFieldEnum = (typeof TermsConditionsOrderByRelevanceFieldEnum)[keyof typeof TermsConditionsOrderByRelevanceFieldEnum]


  export const BannerOrderByRelevanceFieldEnum: {
    title: 'title',
    image: 'image',
    publicId: 'publicId'
  };

  export type BannerOrderByRelevanceFieldEnum = (typeof BannerOrderByRelevanceFieldEnum)[keyof typeof BannerOrderByRelevanceFieldEnum]


  export const MessageOrderByRelevanceFieldEnum: {
    info: 'info'
  };

  export type MessageOrderByRelevanceFieldEnum = (typeof MessageOrderByRelevanceFieldEnum)[keyof typeof MessageOrderByRelevanceFieldEnum]


  export const FoundationOrderByRelevanceFieldEnum: {
    name: 'name',
    tagline: 'tagline',
    logoUrl: 'logoUrl',
    description: 'description',
    establishedYear: 'establishedYear'
  };

  export type FoundationOrderByRelevanceFieldEnum = (typeof FoundationOrderByRelevanceFieldEnum)[keyof typeof FoundationOrderByRelevanceFieldEnum]


  export const FoundationStatOrderByRelevanceFieldEnum: {
    label: 'label',
    value: 'value'
  };

  export type FoundationStatOrderByRelevanceFieldEnum = (typeof FoundationStatOrderByRelevanceFieldEnum)[keyof typeof FoundationStatOrderByRelevanceFieldEnum]


  export const FoundationActivityOrderByRelevanceFieldEnum: {
    activityText: 'activityText'
  };

  export type FoundationActivityOrderByRelevanceFieldEnum = (typeof FoundationActivityOrderByRelevanceFieldEnum)[keyof typeof FoundationActivityOrderByRelevanceFieldEnum]


  export const FoundationObjectiveOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description'
  };

  export type FoundationObjectiveOrderByRelevanceFieldEnum = (typeof FoundationObjectiveOrderByRelevanceFieldEnum)[keyof typeof FoundationObjectiveOrderByRelevanceFieldEnum]


  export const FoundationContactOrderByRelevanceFieldEnum: {
    email: 'email',
    phone: 'phone',
    address: 'address',
    website: 'website'
  };

  export type FoundationContactOrderByRelevanceFieldEnum = (typeof FoundationContactOrderByRelevanceFieldEnum)[keyof typeof FoundationContactOrderByRelevanceFieldEnum]


  export const FoundationMediaOrderByRelevanceFieldEnum: {
    fileName: 'fileName',
    filePath: 'filePath',
    fileType: 'fileType',
    altText: 'altText'
  };

  export type FoundationMediaOrderByRelevanceFieldEnum = (typeof FoundationMediaOrderByRelevanceFieldEnum)[keyof typeof FoundationMediaOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ObjectiveType'
   */
  export type EnumObjectiveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ObjectiveType'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    otpCode?: StringNullableFilter<"User"> | string | null
    otpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerified?: BoolFilter<"User"> | boolean
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    donations?: DonationListRelationFilter
    pdfOrders?: PdfOrderListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    otpCode?: SortOrderInput | SortOrder
    otpExpires?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpires?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    donations?: DonationOrderByRelationAggregateInput
    pdfOrders?: PdfOrderOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    otpCode?: StringNullableFilter<"User"> | string | null
    otpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerified?: BoolFilter<"User"> | boolean
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    donations?: DonationListRelationFilter
    pdfOrders?: PdfOrderListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    otpCode?: SortOrderInput | SortOrder
    otpExpires?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpires?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    otpCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    otpExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: IntFilter<"Account"> | number
    userId?: IntFilter<"Account"> | number
    providerType?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    providerType?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AccountOrderByRelevanceInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: IntFilter<"Account"> | number
    providerType?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    providerType?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Account"> | number
    userId?: IntWithAggregatesFilter<"Account"> | number
    providerType?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: IntFilter<"Session"> | number
    sessionToken?: StringFilter<"Session"> | string
    userId?: IntFilter<"Session"> | number
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: SessionOrderByRelevanceInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: IntFilter<"Session"> | number
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Session"> | number
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: IntWithAggregatesFilter<"Session"> | number
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type DonationWhereInput = {
    AND?: DonationWhereInput | DonationWhereInput[]
    OR?: DonationWhereInput[]
    NOT?: DonationWhereInput | DonationWhereInput[]
    id?: IntFilter<"Donation"> | number
    userId?: IntFilter<"Donation"> | number
    amount?: FloatFilter<"Donation"> | number
    status?: StringFilter<"Donation"> | string
    paymentMethod?: StringNullableFilter<"Donation"> | string | null
    transactionId?: StringNullableFilter<"Donation"> | string | null
    createdAt?: DateTimeFilter<"Donation"> | Date | string
    updatedAt?: DateTimeFilter<"Donation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DonationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: DonationOrderByRelevanceInput
  }

  export type DonationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DonationWhereInput | DonationWhereInput[]
    OR?: DonationWhereInput[]
    NOT?: DonationWhereInput | DonationWhereInput[]
    userId?: IntFilter<"Donation"> | number
    amount?: FloatFilter<"Donation"> | number
    status?: StringFilter<"Donation"> | string
    paymentMethod?: StringNullableFilter<"Donation"> | string | null
    transactionId?: StringNullableFilter<"Donation"> | string | null
    createdAt?: DateTimeFilter<"Donation"> | Date | string
    updatedAt?: DateTimeFilter<"Donation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DonationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DonationCountOrderByAggregateInput
    _avg?: DonationAvgOrderByAggregateInput
    _max?: DonationMaxOrderByAggregateInput
    _min?: DonationMinOrderByAggregateInput
    _sum?: DonationSumOrderByAggregateInput
  }

  export type DonationScalarWhereWithAggregatesInput = {
    AND?: DonationScalarWhereWithAggregatesInput | DonationScalarWhereWithAggregatesInput[]
    OR?: DonationScalarWhereWithAggregatesInput[]
    NOT?: DonationScalarWhereWithAggregatesInput | DonationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Donation"> | number
    userId?: IntWithAggregatesFilter<"Donation"> | number
    amount?: FloatWithAggregatesFilter<"Donation"> | number
    status?: StringWithAggregatesFilter<"Donation"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"Donation"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"Donation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Donation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Donation"> | Date | string
  }

  export type PdfBookWhereInput = {
    AND?: PdfBookWhereInput | PdfBookWhereInput[]
    OR?: PdfBookWhereInput[]
    NOT?: PdfBookWhereInput | PdfBookWhereInput[]
    id?: IntFilter<"PdfBook"> | number
    title?: StringFilter<"PdfBook"> | string
    description?: StringNullableFilter<"PdfBook"> | string | null
    price?: FloatFilter<"PdfBook"> | number
    pdfUrl?: StringFilter<"PdfBook"> | string
    createdAt?: DateTimeFilter<"PdfBook"> | Date | string
    updatedAt?: DateTimeFilter<"PdfBook"> | Date | string
    orders?: PdfOrderListRelationFilter
  }

  export type PdfBookOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: PdfOrderOrderByRelationAggregateInput
    _relevance?: PdfBookOrderByRelevanceInput
  }

  export type PdfBookWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PdfBookWhereInput | PdfBookWhereInput[]
    OR?: PdfBookWhereInput[]
    NOT?: PdfBookWhereInput | PdfBookWhereInput[]
    title?: StringFilter<"PdfBook"> | string
    description?: StringNullableFilter<"PdfBook"> | string | null
    price?: FloatFilter<"PdfBook"> | number
    pdfUrl?: StringFilter<"PdfBook"> | string
    createdAt?: DateTimeFilter<"PdfBook"> | Date | string
    updatedAt?: DateTimeFilter<"PdfBook"> | Date | string
    orders?: PdfOrderListRelationFilter
  }, "id">

  export type PdfBookOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PdfBookCountOrderByAggregateInput
    _avg?: PdfBookAvgOrderByAggregateInput
    _max?: PdfBookMaxOrderByAggregateInput
    _min?: PdfBookMinOrderByAggregateInput
    _sum?: PdfBookSumOrderByAggregateInput
  }

  export type PdfBookScalarWhereWithAggregatesInput = {
    AND?: PdfBookScalarWhereWithAggregatesInput | PdfBookScalarWhereWithAggregatesInput[]
    OR?: PdfBookScalarWhereWithAggregatesInput[]
    NOT?: PdfBookScalarWhereWithAggregatesInput | PdfBookScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PdfBook"> | number
    title?: StringWithAggregatesFilter<"PdfBook"> | string
    description?: StringNullableWithAggregatesFilter<"PdfBook"> | string | null
    price?: FloatWithAggregatesFilter<"PdfBook"> | number
    pdfUrl?: StringWithAggregatesFilter<"PdfBook"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PdfBook"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PdfBook"> | Date | string
  }

  export type PdfOrderWhereInput = {
    AND?: PdfOrderWhereInput | PdfOrderWhereInput[]
    OR?: PdfOrderWhereInput[]
    NOT?: PdfOrderWhereInput | PdfOrderWhereInput[]
    id?: IntFilter<"PdfOrder"> | number
    userId?: IntFilter<"PdfOrder"> | number
    pdfBookId?: IntFilter<"PdfOrder"> | number
    quantity?: IntFilter<"PdfOrder"> | number
    totalPrice?: FloatFilter<"PdfOrder"> | number
    status?: StringFilter<"PdfOrder"> | string
    paymentMethod?: StringNullableFilter<"PdfOrder"> | string | null
    transactionId?: StringNullableFilter<"PdfOrder"> | string | null
    createdAt?: DateTimeFilter<"PdfOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PdfOrder"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    pdfBook?: XOR<PdfBookScalarRelationFilter, PdfBookWhereInput>
  }

  export type PdfOrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    pdfBookId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    pdfBook?: PdfBookOrderByWithRelationInput
    _relevance?: PdfOrderOrderByRelevanceInput
  }

  export type PdfOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PdfOrderWhereInput | PdfOrderWhereInput[]
    OR?: PdfOrderWhereInput[]
    NOT?: PdfOrderWhereInput | PdfOrderWhereInput[]
    userId?: IntFilter<"PdfOrder"> | number
    pdfBookId?: IntFilter<"PdfOrder"> | number
    quantity?: IntFilter<"PdfOrder"> | number
    totalPrice?: FloatFilter<"PdfOrder"> | number
    status?: StringFilter<"PdfOrder"> | string
    paymentMethod?: StringNullableFilter<"PdfOrder"> | string | null
    transactionId?: StringNullableFilter<"PdfOrder"> | string | null
    createdAt?: DateTimeFilter<"PdfOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PdfOrder"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    pdfBook?: XOR<PdfBookScalarRelationFilter, PdfBookWhereInput>
  }, "id">

  export type PdfOrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    pdfBookId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PdfOrderCountOrderByAggregateInput
    _avg?: PdfOrderAvgOrderByAggregateInput
    _max?: PdfOrderMaxOrderByAggregateInput
    _min?: PdfOrderMinOrderByAggregateInput
    _sum?: PdfOrderSumOrderByAggregateInput
  }

  export type PdfOrderScalarWhereWithAggregatesInput = {
    AND?: PdfOrderScalarWhereWithAggregatesInput | PdfOrderScalarWhereWithAggregatesInput[]
    OR?: PdfOrderScalarWhereWithAggregatesInput[]
    NOT?: PdfOrderScalarWhereWithAggregatesInput | PdfOrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PdfOrder"> | number
    userId?: IntWithAggregatesFilter<"PdfOrder"> | number
    pdfBookId?: IntWithAggregatesFilter<"PdfOrder"> | number
    quantity?: IntWithAggregatesFilter<"PdfOrder"> | number
    totalPrice?: FloatWithAggregatesFilter<"PdfOrder"> | number
    status?: StringWithAggregatesFilter<"PdfOrder"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"PdfOrder"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"PdfOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PdfOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PdfOrder"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    userId?: IntFilter<"Payment"> | number
    referenceId?: StringFilter<"Payment"> | string
    provider?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    referenceId?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: PaymentOrderByRelevanceInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    userId?: IntFilter<"Payment"> | number
    referenceId?: StringFilter<"Payment"> | string
    provider?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    referenceId?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    userId?: IntWithAggregatesFilter<"Payment"> | number
    referenceId?: StringWithAggregatesFilter<"Payment"> | string
    provider?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    status?: StringWithAggregatesFilter<"Payment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type NewsWhereInput = {
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    id?: IntFilter<"News"> | number
    title?: StringFilter<"News"> | string
    titleEn?: StringNullableFilter<"News"> | string | null
    slug?: StringFilter<"News"> | string
    featuredImage?: StringNullableFilter<"News"> | string | null
    authorName?: StringNullableFilter<"News"> | string | null
    authorAvatar?: StringNullableFilter<"News"> | string | null
    authorRole?: StringNullableFilter<"News"> | string | null
    publishedDate?: StringNullableFilter<"News"> | string | null
    readTime?: StringNullableFilter<"News"> | string | null
    views?: StringNullableFilter<"News"> | string | null
    category?: StringNullableFilter<"News"> | string | null
    tags?: StringNullableFilter<"News"> | string | null
    content?: JsonFilter<"News">
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
  }

  export type NewsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrderInput | SortOrder
    slug?: SortOrder
    featuredImage?: SortOrderInput | SortOrder
    authorName?: SortOrderInput | SortOrder
    authorAvatar?: SortOrderInput | SortOrder
    authorRole?: SortOrderInput | SortOrder
    publishedDate?: SortOrderInput | SortOrder
    readTime?: SortOrderInput | SortOrder
    views?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: NewsOrderByRelevanceInput
  }

  export type NewsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    title?: StringFilter<"News"> | string
    titleEn?: StringNullableFilter<"News"> | string | null
    featuredImage?: StringNullableFilter<"News"> | string | null
    authorName?: StringNullableFilter<"News"> | string | null
    authorAvatar?: StringNullableFilter<"News"> | string | null
    authorRole?: StringNullableFilter<"News"> | string | null
    publishedDate?: StringNullableFilter<"News"> | string | null
    readTime?: StringNullableFilter<"News"> | string | null
    views?: StringNullableFilter<"News"> | string | null
    category?: StringNullableFilter<"News"> | string | null
    tags?: StringNullableFilter<"News"> | string | null
    content?: JsonFilter<"News">
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
  }, "id" | "slug">

  export type NewsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrderInput | SortOrder
    slug?: SortOrder
    featuredImage?: SortOrderInput | SortOrder
    authorName?: SortOrderInput | SortOrder
    authorAvatar?: SortOrderInput | SortOrder
    authorRole?: SortOrderInput | SortOrder
    publishedDate?: SortOrderInput | SortOrder
    readTime?: SortOrderInput | SortOrder
    views?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NewsCountOrderByAggregateInput
    _avg?: NewsAvgOrderByAggregateInput
    _max?: NewsMaxOrderByAggregateInput
    _min?: NewsMinOrderByAggregateInput
    _sum?: NewsSumOrderByAggregateInput
  }

  export type NewsScalarWhereWithAggregatesInput = {
    AND?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    OR?: NewsScalarWhereWithAggregatesInput[]
    NOT?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"News"> | number
    title?: StringWithAggregatesFilter<"News"> | string
    titleEn?: StringNullableWithAggregatesFilter<"News"> | string | null
    slug?: StringWithAggregatesFilter<"News"> | string
    featuredImage?: StringNullableWithAggregatesFilter<"News"> | string | null
    authorName?: StringNullableWithAggregatesFilter<"News"> | string | null
    authorAvatar?: StringNullableWithAggregatesFilter<"News"> | string | null
    authorRole?: StringNullableWithAggregatesFilter<"News"> | string | null
    publishedDate?: StringNullableWithAggregatesFilter<"News"> | string | null
    readTime?: StringNullableWithAggregatesFilter<"News"> | string | null
    views?: StringNullableWithAggregatesFilter<"News"> | string | null
    category?: StringNullableWithAggregatesFilter<"News"> | string | null
    tags?: StringNullableWithAggregatesFilter<"News"> | string | null
    content?: JsonWithAggregatesFilter<"News">
    createdAt?: DateTimeWithAggregatesFilter<"News"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"News"> | Date | string
  }

  export type GopalPariwarWhereInput = {
    AND?: GopalPariwarWhereInput | GopalPariwarWhereInput[]
    OR?: GopalPariwarWhereInput[]
    NOT?: GopalPariwarWhereInput | GopalPariwarWhereInput[]
    id?: IntFilter<"GopalPariwar"> | number
    heroImage?: StringFilter<"GopalPariwar"> | string
    heroTitle?: StringFilter<"GopalPariwar"> | string
    heroSubtitle?: StringFilter<"GopalPariwar"> | string
    personalInfo?: JsonFilter<"GopalPariwar">
    spiritualEducation?: StringNullableFilter<"GopalPariwar"> | string | null
    lifeJourney?: JsonFilter<"GopalPariwar">
    responsibilities?: JsonFilter<"GopalPariwar">
    pledges?: JsonFilter<"GopalPariwar">
    createdAt?: DateTimeFilter<"GopalPariwar"> | Date | string
    updatedAt?: DateTimeFilter<"GopalPariwar"> | Date | string
  }

  export type GopalPariwarOrderByWithRelationInput = {
    id?: SortOrder
    heroImage?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    personalInfo?: SortOrder
    spiritualEducation?: SortOrderInput | SortOrder
    lifeJourney?: SortOrder
    responsibilities?: SortOrder
    pledges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: GopalPariwarOrderByRelevanceInput
  }

  export type GopalPariwarWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GopalPariwarWhereInput | GopalPariwarWhereInput[]
    OR?: GopalPariwarWhereInput[]
    NOT?: GopalPariwarWhereInput | GopalPariwarWhereInput[]
    heroImage?: StringFilter<"GopalPariwar"> | string
    heroTitle?: StringFilter<"GopalPariwar"> | string
    heroSubtitle?: StringFilter<"GopalPariwar"> | string
    personalInfo?: JsonFilter<"GopalPariwar">
    spiritualEducation?: StringNullableFilter<"GopalPariwar"> | string | null
    lifeJourney?: JsonFilter<"GopalPariwar">
    responsibilities?: JsonFilter<"GopalPariwar">
    pledges?: JsonFilter<"GopalPariwar">
    createdAt?: DateTimeFilter<"GopalPariwar"> | Date | string
    updatedAt?: DateTimeFilter<"GopalPariwar"> | Date | string
  }, "id">

  export type GopalPariwarOrderByWithAggregationInput = {
    id?: SortOrder
    heroImage?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    personalInfo?: SortOrder
    spiritualEducation?: SortOrderInput | SortOrder
    lifeJourney?: SortOrder
    responsibilities?: SortOrder
    pledges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GopalPariwarCountOrderByAggregateInput
    _avg?: GopalPariwarAvgOrderByAggregateInput
    _max?: GopalPariwarMaxOrderByAggregateInput
    _min?: GopalPariwarMinOrderByAggregateInput
    _sum?: GopalPariwarSumOrderByAggregateInput
  }

  export type GopalPariwarScalarWhereWithAggregatesInput = {
    AND?: GopalPariwarScalarWhereWithAggregatesInput | GopalPariwarScalarWhereWithAggregatesInput[]
    OR?: GopalPariwarScalarWhereWithAggregatesInput[]
    NOT?: GopalPariwarScalarWhereWithAggregatesInput | GopalPariwarScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GopalPariwar"> | number
    heroImage?: StringWithAggregatesFilter<"GopalPariwar"> | string
    heroTitle?: StringWithAggregatesFilter<"GopalPariwar"> | string
    heroSubtitle?: StringWithAggregatesFilter<"GopalPariwar"> | string
    personalInfo?: JsonWithAggregatesFilter<"GopalPariwar">
    spiritualEducation?: StringNullableWithAggregatesFilter<"GopalPariwar"> | string | null
    lifeJourney?: JsonWithAggregatesFilter<"GopalPariwar">
    responsibilities?: JsonWithAggregatesFilter<"GopalPariwar">
    pledges?: JsonWithAggregatesFilter<"GopalPariwar">
    createdAt?: DateTimeWithAggregatesFilter<"GopalPariwar"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GopalPariwar"> | Date | string
  }

  export type GaushalaWhereInput = {
    AND?: GaushalaWhereInput | GaushalaWhereInput[]
    OR?: GaushalaWhereInput[]
    NOT?: GaushalaWhereInput | GaushalaWhereInput[]
    id?: IntFilter<"Gaushala"> | number
    name?: StringFilter<"Gaushala"> | string
    address?: StringFilter<"Gaushala"> | string
    establishmentYear?: IntFilter<"Gaushala"> | number
    contactDetails?: StringFilter<"Gaushala"> | string
    totalCows?: IntFilter<"Gaushala"> | number
    capacity?: IntFilter<"Gaushala"> | number
    description?: StringNullableFilter<"Gaushala"> | string | null
    city?: StringFilter<"Gaushala"> | string
    state?: StringFilter<"Gaushala"> | string
    pincode?: StringFilter<"Gaushala"> | string
    contactPerson?: StringFilter<"Gaushala"> | string
    createdAt?: DateTimeFilter<"Gaushala"> | Date | string
    updatedAt?: DateTimeFilter<"Gaushala"> | Date | string
  }

  export type GaushalaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    establishmentYear?: SortOrder
    contactDetails?: SortOrder
    totalCows?: SortOrder
    capacity?: SortOrder
    description?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    contactPerson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: GaushalaOrderByRelevanceInput
  }

  export type GaushalaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GaushalaWhereInput | GaushalaWhereInput[]
    OR?: GaushalaWhereInput[]
    NOT?: GaushalaWhereInput | GaushalaWhereInput[]
    name?: StringFilter<"Gaushala"> | string
    address?: StringFilter<"Gaushala"> | string
    establishmentYear?: IntFilter<"Gaushala"> | number
    contactDetails?: StringFilter<"Gaushala"> | string
    totalCows?: IntFilter<"Gaushala"> | number
    capacity?: IntFilter<"Gaushala"> | number
    description?: StringNullableFilter<"Gaushala"> | string | null
    city?: StringFilter<"Gaushala"> | string
    state?: StringFilter<"Gaushala"> | string
    pincode?: StringFilter<"Gaushala"> | string
    contactPerson?: StringFilter<"Gaushala"> | string
    createdAt?: DateTimeFilter<"Gaushala"> | Date | string
    updatedAt?: DateTimeFilter<"Gaushala"> | Date | string
  }, "id">

  export type GaushalaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    establishmentYear?: SortOrder
    contactDetails?: SortOrder
    totalCows?: SortOrder
    capacity?: SortOrder
    description?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    contactPerson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GaushalaCountOrderByAggregateInput
    _avg?: GaushalaAvgOrderByAggregateInput
    _max?: GaushalaMaxOrderByAggregateInput
    _min?: GaushalaMinOrderByAggregateInput
    _sum?: GaushalaSumOrderByAggregateInput
  }

  export type GaushalaScalarWhereWithAggregatesInput = {
    AND?: GaushalaScalarWhereWithAggregatesInput | GaushalaScalarWhereWithAggregatesInput[]
    OR?: GaushalaScalarWhereWithAggregatesInput[]
    NOT?: GaushalaScalarWhereWithAggregatesInput | GaushalaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Gaushala"> | number
    name?: StringWithAggregatesFilter<"Gaushala"> | string
    address?: StringWithAggregatesFilter<"Gaushala"> | string
    establishmentYear?: IntWithAggregatesFilter<"Gaushala"> | number
    contactDetails?: StringWithAggregatesFilter<"Gaushala"> | string
    totalCows?: IntWithAggregatesFilter<"Gaushala"> | number
    capacity?: IntWithAggregatesFilter<"Gaushala"> | number
    description?: StringNullableWithAggregatesFilter<"Gaushala"> | string | null
    city?: StringWithAggregatesFilter<"Gaushala"> | string
    state?: StringWithAggregatesFilter<"Gaushala"> | string
    pincode?: StringWithAggregatesFilter<"Gaushala"> | string
    contactPerson?: StringWithAggregatesFilter<"Gaushala"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Gaushala"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Gaushala"> | Date | string
  }

  export type CardWhereInput = {
    AND?: CardWhereInput | CardWhereInput[]
    OR?: CardWhereInput[]
    NOT?: CardWhereInput | CardWhereInput[]
    id?: IntFilter<"Card"> | number
    title?: StringFilter<"Card"> | string
    titleEn?: StringNullableFilter<"Card"> | string | null
    link?: StringFilter<"Card"> | string
    image?: StringNullableFilter<"Card"> | string | null
    order?: IntNullableFilter<"Card"> | number | null
    createdAt?: DateTimeFilter<"Card"> | Date | string
    updatedAt?: DateTimeFilter<"Card"> | Date | string
  }

  export type CardOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrderInput | SortOrder
    link?: SortOrder
    image?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: CardOrderByRelevanceInput
  }

  export type CardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CardWhereInput | CardWhereInput[]
    OR?: CardWhereInput[]
    NOT?: CardWhereInput | CardWhereInput[]
    title?: StringFilter<"Card"> | string
    titleEn?: StringNullableFilter<"Card"> | string | null
    link?: StringFilter<"Card"> | string
    image?: StringNullableFilter<"Card"> | string | null
    order?: IntNullableFilter<"Card"> | number | null
    createdAt?: DateTimeFilter<"Card"> | Date | string
    updatedAt?: DateTimeFilter<"Card"> | Date | string
  }, "id">

  export type CardOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrderInput | SortOrder
    link?: SortOrder
    image?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CardCountOrderByAggregateInput
    _avg?: CardAvgOrderByAggregateInput
    _max?: CardMaxOrderByAggregateInput
    _min?: CardMinOrderByAggregateInput
    _sum?: CardSumOrderByAggregateInput
  }

  export type CardScalarWhereWithAggregatesInput = {
    AND?: CardScalarWhereWithAggregatesInput | CardScalarWhereWithAggregatesInput[]
    OR?: CardScalarWhereWithAggregatesInput[]
    NOT?: CardScalarWhereWithAggregatesInput | CardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Card"> | number
    title?: StringWithAggregatesFilter<"Card"> | string
    titleEn?: StringNullableWithAggregatesFilter<"Card"> | string | null
    link?: StringWithAggregatesFilter<"Card"> | string
    image?: StringNullableWithAggregatesFilter<"Card"> | string | null
    order?: IntNullableWithAggregatesFilter<"Card"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Card"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Card"> | Date | string
  }

  export type DtaSanssthanWhereInput = {
    AND?: DtaSanssthanWhereInput | DtaSanssthanWhereInput[]
    OR?: DtaSanssthanWhereInput[]
    NOT?: DtaSanssthanWhereInput | DtaSanssthanWhereInput[]
    id?: IntFilter<"DtaSanssthan"> | number
    name?: StringFilter<"DtaSanssthan"> | string
    person?: StringNullableFilter<"DtaSanssthan"> | string | null
    image?: StringNullableFilter<"DtaSanssthan"> | string | null
    description?: StringNullableFilter<"DtaSanssthan"> | string | null
    email?: StringNullableFilter<"DtaSanssthan"> | string | null
    phone?: StringNullableFilter<"DtaSanssthan"> | string | null
    altPhone?: StringNullableFilter<"DtaSanssthan"> | string | null
    website?: StringNullableFilter<"DtaSanssthan"> | string | null
    timing?: StringNullableFilter<"DtaSanssthan"> | string | null
    createdAt?: DateTimeFilter<"DtaSanssthan"> | Date | string
    updatedAt?: DateTimeFilter<"DtaSanssthan"> | Date | string
  }

  export type DtaSanssthanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    person?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    altPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    timing?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: DtaSanssthanOrderByRelevanceInput
  }

  export type DtaSanssthanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DtaSanssthanWhereInput | DtaSanssthanWhereInput[]
    OR?: DtaSanssthanWhereInput[]
    NOT?: DtaSanssthanWhereInput | DtaSanssthanWhereInput[]
    name?: StringFilter<"DtaSanssthan"> | string
    person?: StringNullableFilter<"DtaSanssthan"> | string | null
    image?: StringNullableFilter<"DtaSanssthan"> | string | null
    description?: StringNullableFilter<"DtaSanssthan"> | string | null
    email?: StringNullableFilter<"DtaSanssthan"> | string | null
    phone?: StringNullableFilter<"DtaSanssthan"> | string | null
    altPhone?: StringNullableFilter<"DtaSanssthan"> | string | null
    website?: StringNullableFilter<"DtaSanssthan"> | string | null
    timing?: StringNullableFilter<"DtaSanssthan"> | string | null
    createdAt?: DateTimeFilter<"DtaSanssthan"> | Date | string
    updatedAt?: DateTimeFilter<"DtaSanssthan"> | Date | string
  }, "id">

  export type DtaSanssthanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    person?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    altPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    timing?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DtaSanssthanCountOrderByAggregateInput
    _avg?: DtaSanssthanAvgOrderByAggregateInput
    _max?: DtaSanssthanMaxOrderByAggregateInput
    _min?: DtaSanssthanMinOrderByAggregateInput
    _sum?: DtaSanssthanSumOrderByAggregateInput
  }

  export type DtaSanssthanScalarWhereWithAggregatesInput = {
    AND?: DtaSanssthanScalarWhereWithAggregatesInput | DtaSanssthanScalarWhereWithAggregatesInput[]
    OR?: DtaSanssthanScalarWhereWithAggregatesInput[]
    NOT?: DtaSanssthanScalarWhereWithAggregatesInput | DtaSanssthanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DtaSanssthan"> | number
    name?: StringWithAggregatesFilter<"DtaSanssthan"> | string
    person?: StringNullableWithAggregatesFilter<"DtaSanssthan"> | string | null
    image?: StringNullableWithAggregatesFilter<"DtaSanssthan"> | string | null
    description?: StringNullableWithAggregatesFilter<"DtaSanssthan"> | string | null
    email?: StringNullableWithAggregatesFilter<"DtaSanssthan"> | string | null
    phone?: StringNullableWithAggregatesFilter<"DtaSanssthan"> | string | null
    altPhone?: StringNullableWithAggregatesFilter<"DtaSanssthan"> | string | null
    website?: StringNullableWithAggregatesFilter<"DtaSanssthan"> | string | null
    timing?: StringNullableWithAggregatesFilter<"DtaSanssthan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DtaSanssthan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DtaSanssthan"> | Date | string
  }

  export type PrivacyPolicyWhereInput = {
    AND?: PrivacyPolicyWhereInput | PrivacyPolicyWhereInput[]
    OR?: PrivacyPolicyWhereInput[]
    NOT?: PrivacyPolicyWhereInput | PrivacyPolicyWhereInput[]
    id?: IntFilter<"PrivacyPolicy"> | number
    title?: StringFilter<"PrivacyPolicy"> | string
    subtitle?: StringNullableFilter<"PrivacyPolicy"> | string | null
    sections?: JsonFilter<"PrivacyPolicy">
    email?: StringNullableFilter<"PrivacyPolicy"> | string | null
    phone?: StringNullableFilter<"PrivacyPolicy"> | string | null
    callingHours?: StringNullableFilter<"PrivacyPolicy"> | string | null
    mailingAddress?: StringNullableFilter<"PrivacyPolicy"> | string | null
    createdAt?: DateTimeFilter<"PrivacyPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"PrivacyPolicy"> | Date | string
  }

  export type PrivacyPolicyOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    sections?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    callingHours?: SortOrderInput | SortOrder
    mailingAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: PrivacyPolicyOrderByRelevanceInput
  }

  export type PrivacyPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PrivacyPolicyWhereInput | PrivacyPolicyWhereInput[]
    OR?: PrivacyPolicyWhereInput[]
    NOT?: PrivacyPolicyWhereInput | PrivacyPolicyWhereInput[]
    title?: StringFilter<"PrivacyPolicy"> | string
    subtitle?: StringNullableFilter<"PrivacyPolicy"> | string | null
    sections?: JsonFilter<"PrivacyPolicy">
    email?: StringNullableFilter<"PrivacyPolicy"> | string | null
    phone?: StringNullableFilter<"PrivacyPolicy"> | string | null
    callingHours?: StringNullableFilter<"PrivacyPolicy"> | string | null
    mailingAddress?: StringNullableFilter<"PrivacyPolicy"> | string | null
    createdAt?: DateTimeFilter<"PrivacyPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"PrivacyPolicy"> | Date | string
  }, "id">

  export type PrivacyPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    sections?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    callingHours?: SortOrderInput | SortOrder
    mailingAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PrivacyPolicyCountOrderByAggregateInput
    _avg?: PrivacyPolicyAvgOrderByAggregateInput
    _max?: PrivacyPolicyMaxOrderByAggregateInput
    _min?: PrivacyPolicyMinOrderByAggregateInput
    _sum?: PrivacyPolicySumOrderByAggregateInput
  }

  export type PrivacyPolicyScalarWhereWithAggregatesInput = {
    AND?: PrivacyPolicyScalarWhereWithAggregatesInput | PrivacyPolicyScalarWhereWithAggregatesInput[]
    OR?: PrivacyPolicyScalarWhereWithAggregatesInput[]
    NOT?: PrivacyPolicyScalarWhereWithAggregatesInput | PrivacyPolicyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PrivacyPolicy"> | number
    title?: StringWithAggregatesFilter<"PrivacyPolicy"> | string
    subtitle?: StringNullableWithAggregatesFilter<"PrivacyPolicy"> | string | null
    sections?: JsonWithAggregatesFilter<"PrivacyPolicy">
    email?: StringNullableWithAggregatesFilter<"PrivacyPolicy"> | string | null
    phone?: StringNullableWithAggregatesFilter<"PrivacyPolicy"> | string | null
    callingHours?: StringNullableWithAggregatesFilter<"PrivacyPolicy"> | string | null
    mailingAddress?: StringNullableWithAggregatesFilter<"PrivacyPolicy"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PrivacyPolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PrivacyPolicy"> | Date | string
  }

  export type TermsConditionsWhereInput = {
    AND?: TermsConditionsWhereInput | TermsConditionsWhereInput[]
    OR?: TermsConditionsWhereInput[]
    NOT?: TermsConditionsWhereInput | TermsConditionsWhereInput[]
    id?: IntFilter<"TermsConditions"> | number
    title?: StringFilter<"TermsConditions"> | string
    subtitle?: StringNullableFilter<"TermsConditions"> | string | null
    sections?: JsonFilter<"TermsConditions">
    email?: StringNullableFilter<"TermsConditions"> | string | null
    phone?: StringNullableFilter<"TermsConditions"> | string | null
    callingHours?: StringNullableFilter<"TermsConditions"> | string | null
    mailingAddress?: StringNullableFilter<"TermsConditions"> | string | null
    createdAt?: DateTimeFilter<"TermsConditions"> | Date | string
    updatedAt?: DateTimeFilter<"TermsConditions"> | Date | string
  }

  export type TermsConditionsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    sections?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    callingHours?: SortOrderInput | SortOrder
    mailingAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: TermsConditionsOrderByRelevanceInput
  }

  export type TermsConditionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TermsConditionsWhereInput | TermsConditionsWhereInput[]
    OR?: TermsConditionsWhereInput[]
    NOT?: TermsConditionsWhereInput | TermsConditionsWhereInput[]
    title?: StringFilter<"TermsConditions"> | string
    subtitle?: StringNullableFilter<"TermsConditions"> | string | null
    sections?: JsonFilter<"TermsConditions">
    email?: StringNullableFilter<"TermsConditions"> | string | null
    phone?: StringNullableFilter<"TermsConditions"> | string | null
    callingHours?: StringNullableFilter<"TermsConditions"> | string | null
    mailingAddress?: StringNullableFilter<"TermsConditions"> | string | null
    createdAt?: DateTimeFilter<"TermsConditions"> | Date | string
    updatedAt?: DateTimeFilter<"TermsConditions"> | Date | string
  }, "id">

  export type TermsConditionsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    sections?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    callingHours?: SortOrderInput | SortOrder
    mailingAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TermsConditionsCountOrderByAggregateInput
    _avg?: TermsConditionsAvgOrderByAggregateInput
    _max?: TermsConditionsMaxOrderByAggregateInput
    _min?: TermsConditionsMinOrderByAggregateInput
    _sum?: TermsConditionsSumOrderByAggregateInput
  }

  export type TermsConditionsScalarWhereWithAggregatesInput = {
    AND?: TermsConditionsScalarWhereWithAggregatesInput | TermsConditionsScalarWhereWithAggregatesInput[]
    OR?: TermsConditionsScalarWhereWithAggregatesInput[]
    NOT?: TermsConditionsScalarWhereWithAggregatesInput | TermsConditionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TermsConditions"> | number
    title?: StringWithAggregatesFilter<"TermsConditions"> | string
    subtitle?: StringNullableWithAggregatesFilter<"TermsConditions"> | string | null
    sections?: JsonWithAggregatesFilter<"TermsConditions">
    email?: StringNullableWithAggregatesFilter<"TermsConditions"> | string | null
    phone?: StringNullableWithAggregatesFilter<"TermsConditions"> | string | null
    callingHours?: StringNullableWithAggregatesFilter<"TermsConditions"> | string | null
    mailingAddress?: StringNullableWithAggregatesFilter<"TermsConditions"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TermsConditions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TermsConditions"> | Date | string
  }

  export type BannerWhereInput = {
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    id?: IntFilter<"Banner"> | number
    title?: StringFilter<"Banner"> | string
    image?: StringFilter<"Banner"> | string
    active?: BoolFilter<"Banner"> | boolean
    order?: IntFilter<"Banner"> | number
    publicId?: StringFilter<"Banner"> | string
    createdAt?: DateTimeFilter<"Banner"> | Date | string
    updatedAt?: DateTimeFilter<"Banner"> | Date | string
  }

  export type BannerOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    active?: SortOrder
    order?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: BannerOrderByRelevanceInput
  }

  export type BannerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    title?: StringFilter<"Banner"> | string
    image?: StringFilter<"Banner"> | string
    active?: BoolFilter<"Banner"> | boolean
    order?: IntFilter<"Banner"> | number
    publicId?: StringFilter<"Banner"> | string
    createdAt?: DateTimeFilter<"Banner"> | Date | string
    updatedAt?: DateTimeFilter<"Banner"> | Date | string
  }, "id">

  export type BannerOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    active?: SortOrder
    order?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BannerCountOrderByAggregateInput
    _avg?: BannerAvgOrderByAggregateInput
    _max?: BannerMaxOrderByAggregateInput
    _min?: BannerMinOrderByAggregateInput
    _sum?: BannerSumOrderByAggregateInput
  }

  export type BannerScalarWhereWithAggregatesInput = {
    AND?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    OR?: BannerScalarWhereWithAggregatesInput[]
    NOT?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Banner"> | number
    title?: StringWithAggregatesFilter<"Banner"> | string
    image?: StringWithAggregatesFilter<"Banner"> | string
    active?: BoolWithAggregatesFilter<"Banner"> | boolean
    order?: IntWithAggregatesFilter<"Banner"> | number
    publicId?: StringWithAggregatesFilter<"Banner"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: IntFilter<"Message"> | number
    info?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    info?: SortOrder
    createdAt?: SortOrder
    _relevance?: MessageOrderByRelevanceInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    info?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    info?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Message"> | number
    info?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type FoundationWhereInput = {
    AND?: FoundationWhereInput | FoundationWhereInput[]
    OR?: FoundationWhereInput[]
    NOT?: FoundationWhereInput | FoundationWhereInput[]
    id?: IntFilter<"Foundation"> | number
    name?: StringFilter<"Foundation"> | string
    tagline?: StringNullableFilter<"Foundation"> | string | null
    logoUrl?: StringNullableFilter<"Foundation"> | string | null
    description?: StringNullableFilter<"Foundation"> | string | null
    establishedYear?: StringNullableFilter<"Foundation"> | string | null
    isActive?: BoolFilter<"Foundation"> | boolean
    createdAt?: DateTimeFilter<"Foundation"> | Date | string
    updatedAt?: DateTimeFilter<"Foundation"> | Date | string
    createdById?: IntNullableFilter<"Foundation"> | number | null
    updatedById?: IntNullableFilter<"Foundation"> | number | null
    stats?: FoundationStatListRelationFilter
    activities?: FoundationActivityListRelationFilter
    objectives?: FoundationObjectiveListRelationFilter
    contact?: XOR<FoundationContactNullableScalarRelationFilter, FoundationContactWhereInput> | null
    media?: FoundationMediaListRelationFilter
  }

  export type FoundationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tagline?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    establishedYear?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    stats?: FoundationStatOrderByRelationAggregateInput
    activities?: FoundationActivityOrderByRelationAggregateInput
    objectives?: FoundationObjectiveOrderByRelationAggregateInput
    contact?: FoundationContactOrderByWithRelationInput
    media?: FoundationMediaOrderByRelationAggregateInput
    _relevance?: FoundationOrderByRelevanceInput
  }

  export type FoundationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoundationWhereInput | FoundationWhereInput[]
    OR?: FoundationWhereInput[]
    NOT?: FoundationWhereInput | FoundationWhereInput[]
    name?: StringFilter<"Foundation"> | string
    tagline?: StringNullableFilter<"Foundation"> | string | null
    logoUrl?: StringNullableFilter<"Foundation"> | string | null
    description?: StringNullableFilter<"Foundation"> | string | null
    establishedYear?: StringNullableFilter<"Foundation"> | string | null
    isActive?: BoolFilter<"Foundation"> | boolean
    createdAt?: DateTimeFilter<"Foundation"> | Date | string
    updatedAt?: DateTimeFilter<"Foundation"> | Date | string
    createdById?: IntNullableFilter<"Foundation"> | number | null
    updatedById?: IntNullableFilter<"Foundation"> | number | null
    stats?: FoundationStatListRelationFilter
    activities?: FoundationActivityListRelationFilter
    objectives?: FoundationObjectiveListRelationFilter
    contact?: XOR<FoundationContactNullableScalarRelationFilter, FoundationContactWhereInput> | null
    media?: FoundationMediaListRelationFilter
  }, "id">

  export type FoundationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    tagline?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    establishedYear?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: FoundationCountOrderByAggregateInput
    _avg?: FoundationAvgOrderByAggregateInput
    _max?: FoundationMaxOrderByAggregateInput
    _min?: FoundationMinOrderByAggregateInput
    _sum?: FoundationSumOrderByAggregateInput
  }

  export type FoundationScalarWhereWithAggregatesInput = {
    AND?: FoundationScalarWhereWithAggregatesInput | FoundationScalarWhereWithAggregatesInput[]
    OR?: FoundationScalarWhereWithAggregatesInput[]
    NOT?: FoundationScalarWhereWithAggregatesInput | FoundationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Foundation"> | number
    name?: StringWithAggregatesFilter<"Foundation"> | string
    tagline?: StringNullableWithAggregatesFilter<"Foundation"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Foundation"> | string | null
    description?: StringNullableWithAggregatesFilter<"Foundation"> | string | null
    establishedYear?: StringNullableWithAggregatesFilter<"Foundation"> | string | null
    isActive?: BoolWithAggregatesFilter<"Foundation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Foundation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Foundation"> | Date | string
    createdById?: IntNullableWithAggregatesFilter<"Foundation"> | number | null
    updatedById?: IntNullableWithAggregatesFilter<"Foundation"> | number | null
  }

  export type FoundationStatWhereInput = {
    AND?: FoundationStatWhereInput | FoundationStatWhereInput[]
    OR?: FoundationStatWhereInput[]
    NOT?: FoundationStatWhereInput | FoundationStatWhereInput[]
    id?: IntFilter<"FoundationStat"> | number
    foundationId?: IntFilter<"FoundationStat"> | number
    label?: StringFilter<"FoundationStat"> | string
    value?: StringFilter<"FoundationStat"> | string
    displayOrder?: IntFilter<"FoundationStat"> | number
    createdAt?: DateTimeFilter<"FoundationStat"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationStat"> | Date | string
    foundation?: XOR<FoundationScalarRelationFilter, FoundationWhereInput>
  }

  export type FoundationStatOrderByWithRelationInput = {
    id?: SortOrder
    foundationId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    foundation?: FoundationOrderByWithRelationInput
    _relevance?: FoundationStatOrderByRelevanceInput
  }

  export type FoundationStatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoundationStatWhereInput | FoundationStatWhereInput[]
    OR?: FoundationStatWhereInput[]
    NOT?: FoundationStatWhereInput | FoundationStatWhereInput[]
    foundationId?: IntFilter<"FoundationStat"> | number
    label?: StringFilter<"FoundationStat"> | string
    value?: StringFilter<"FoundationStat"> | string
    displayOrder?: IntFilter<"FoundationStat"> | number
    createdAt?: DateTimeFilter<"FoundationStat"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationStat"> | Date | string
    foundation?: XOR<FoundationScalarRelationFilter, FoundationWhereInput>
  }, "id">

  export type FoundationStatOrderByWithAggregationInput = {
    id?: SortOrder
    foundationId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoundationStatCountOrderByAggregateInput
    _avg?: FoundationStatAvgOrderByAggregateInput
    _max?: FoundationStatMaxOrderByAggregateInput
    _min?: FoundationStatMinOrderByAggregateInput
    _sum?: FoundationStatSumOrderByAggregateInput
  }

  export type FoundationStatScalarWhereWithAggregatesInput = {
    AND?: FoundationStatScalarWhereWithAggregatesInput | FoundationStatScalarWhereWithAggregatesInput[]
    OR?: FoundationStatScalarWhereWithAggregatesInput[]
    NOT?: FoundationStatScalarWhereWithAggregatesInput | FoundationStatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoundationStat"> | number
    foundationId?: IntWithAggregatesFilter<"FoundationStat"> | number
    label?: StringWithAggregatesFilter<"FoundationStat"> | string
    value?: StringWithAggregatesFilter<"FoundationStat"> | string
    displayOrder?: IntWithAggregatesFilter<"FoundationStat"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FoundationStat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoundationStat"> | Date | string
  }

  export type FoundationActivityWhereInput = {
    AND?: FoundationActivityWhereInput | FoundationActivityWhereInput[]
    OR?: FoundationActivityWhereInput[]
    NOT?: FoundationActivityWhereInput | FoundationActivityWhereInput[]
    id?: IntFilter<"FoundationActivity"> | number
    foundationId?: IntFilter<"FoundationActivity"> | number
    activityText?: StringFilter<"FoundationActivity"> | string
    displayOrder?: IntFilter<"FoundationActivity"> | number
    createdAt?: DateTimeFilter<"FoundationActivity"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationActivity"> | Date | string
    foundation?: XOR<FoundationScalarRelationFilter, FoundationWhereInput>
  }

  export type FoundationActivityOrderByWithRelationInput = {
    id?: SortOrder
    foundationId?: SortOrder
    activityText?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    foundation?: FoundationOrderByWithRelationInput
    _relevance?: FoundationActivityOrderByRelevanceInput
  }

  export type FoundationActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoundationActivityWhereInput | FoundationActivityWhereInput[]
    OR?: FoundationActivityWhereInput[]
    NOT?: FoundationActivityWhereInput | FoundationActivityWhereInput[]
    foundationId?: IntFilter<"FoundationActivity"> | number
    activityText?: StringFilter<"FoundationActivity"> | string
    displayOrder?: IntFilter<"FoundationActivity"> | number
    createdAt?: DateTimeFilter<"FoundationActivity"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationActivity"> | Date | string
    foundation?: XOR<FoundationScalarRelationFilter, FoundationWhereInput>
  }, "id">

  export type FoundationActivityOrderByWithAggregationInput = {
    id?: SortOrder
    foundationId?: SortOrder
    activityText?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoundationActivityCountOrderByAggregateInput
    _avg?: FoundationActivityAvgOrderByAggregateInput
    _max?: FoundationActivityMaxOrderByAggregateInput
    _min?: FoundationActivityMinOrderByAggregateInput
    _sum?: FoundationActivitySumOrderByAggregateInput
  }

  export type FoundationActivityScalarWhereWithAggregatesInput = {
    AND?: FoundationActivityScalarWhereWithAggregatesInput | FoundationActivityScalarWhereWithAggregatesInput[]
    OR?: FoundationActivityScalarWhereWithAggregatesInput[]
    NOT?: FoundationActivityScalarWhereWithAggregatesInput | FoundationActivityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoundationActivity"> | number
    foundationId?: IntWithAggregatesFilter<"FoundationActivity"> | number
    activityText?: StringWithAggregatesFilter<"FoundationActivity"> | string
    displayOrder?: IntWithAggregatesFilter<"FoundationActivity"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FoundationActivity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoundationActivity"> | Date | string
  }

  export type FoundationObjectiveWhereInput = {
    AND?: FoundationObjectiveWhereInput | FoundationObjectiveWhereInput[]
    OR?: FoundationObjectiveWhereInput[]
    NOT?: FoundationObjectiveWhereInput | FoundationObjectiveWhereInput[]
    id?: IntFilter<"FoundationObjective"> | number
    foundationId?: IntFilter<"FoundationObjective"> | number
    title?: StringFilter<"FoundationObjective"> | string
    description?: StringNullableFilter<"FoundationObjective"> | string | null
    objectiveType?: EnumObjectiveTypeFilter<"FoundationObjective"> | $Enums.ObjectiveType
    displayOrder?: IntFilter<"FoundationObjective"> | number
    createdAt?: DateTimeFilter<"FoundationObjective"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationObjective"> | Date | string
    foundation?: XOR<FoundationScalarRelationFilter, FoundationWhereInput>
  }

  export type FoundationObjectiveOrderByWithRelationInput = {
    id?: SortOrder
    foundationId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    objectiveType?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    foundation?: FoundationOrderByWithRelationInput
    _relevance?: FoundationObjectiveOrderByRelevanceInput
  }

  export type FoundationObjectiveWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoundationObjectiveWhereInput | FoundationObjectiveWhereInput[]
    OR?: FoundationObjectiveWhereInput[]
    NOT?: FoundationObjectiveWhereInput | FoundationObjectiveWhereInput[]
    foundationId?: IntFilter<"FoundationObjective"> | number
    title?: StringFilter<"FoundationObjective"> | string
    description?: StringNullableFilter<"FoundationObjective"> | string | null
    objectiveType?: EnumObjectiveTypeFilter<"FoundationObjective"> | $Enums.ObjectiveType
    displayOrder?: IntFilter<"FoundationObjective"> | number
    createdAt?: DateTimeFilter<"FoundationObjective"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationObjective"> | Date | string
    foundation?: XOR<FoundationScalarRelationFilter, FoundationWhereInput>
  }, "id">

  export type FoundationObjectiveOrderByWithAggregationInput = {
    id?: SortOrder
    foundationId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    objectiveType?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoundationObjectiveCountOrderByAggregateInput
    _avg?: FoundationObjectiveAvgOrderByAggregateInput
    _max?: FoundationObjectiveMaxOrderByAggregateInput
    _min?: FoundationObjectiveMinOrderByAggregateInput
    _sum?: FoundationObjectiveSumOrderByAggregateInput
  }

  export type FoundationObjectiveScalarWhereWithAggregatesInput = {
    AND?: FoundationObjectiveScalarWhereWithAggregatesInput | FoundationObjectiveScalarWhereWithAggregatesInput[]
    OR?: FoundationObjectiveScalarWhereWithAggregatesInput[]
    NOT?: FoundationObjectiveScalarWhereWithAggregatesInput | FoundationObjectiveScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoundationObjective"> | number
    foundationId?: IntWithAggregatesFilter<"FoundationObjective"> | number
    title?: StringWithAggregatesFilter<"FoundationObjective"> | string
    description?: StringNullableWithAggregatesFilter<"FoundationObjective"> | string | null
    objectiveType?: EnumObjectiveTypeWithAggregatesFilter<"FoundationObjective"> | $Enums.ObjectiveType
    displayOrder?: IntWithAggregatesFilter<"FoundationObjective"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FoundationObjective"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoundationObjective"> | Date | string
  }

  export type FoundationContactWhereInput = {
    AND?: FoundationContactWhereInput | FoundationContactWhereInput[]
    OR?: FoundationContactWhereInput[]
    NOT?: FoundationContactWhereInput | FoundationContactWhereInput[]
    id?: IntFilter<"FoundationContact"> | number
    foundationId?: IntFilter<"FoundationContact"> | number
    email?: StringNullableFilter<"FoundationContact"> | string | null
    phone?: StringNullableFilter<"FoundationContact"> | string | null
    address?: StringNullableFilter<"FoundationContact"> | string | null
    website?: StringNullableFilter<"FoundationContact"> | string | null
    socialMediaLinks?: JsonNullableFilter<"FoundationContact">
    createdAt?: DateTimeFilter<"FoundationContact"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationContact"> | Date | string
    foundation?: XOR<FoundationScalarRelationFilter, FoundationWhereInput>
  }

  export type FoundationContactOrderByWithRelationInput = {
    id?: SortOrder
    foundationId?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    socialMediaLinks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    foundation?: FoundationOrderByWithRelationInput
    _relevance?: FoundationContactOrderByRelevanceInput
  }

  export type FoundationContactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    foundationId?: number
    AND?: FoundationContactWhereInput | FoundationContactWhereInput[]
    OR?: FoundationContactWhereInput[]
    NOT?: FoundationContactWhereInput | FoundationContactWhereInput[]
    email?: StringNullableFilter<"FoundationContact"> | string | null
    phone?: StringNullableFilter<"FoundationContact"> | string | null
    address?: StringNullableFilter<"FoundationContact"> | string | null
    website?: StringNullableFilter<"FoundationContact"> | string | null
    socialMediaLinks?: JsonNullableFilter<"FoundationContact">
    createdAt?: DateTimeFilter<"FoundationContact"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationContact"> | Date | string
    foundation?: XOR<FoundationScalarRelationFilter, FoundationWhereInput>
  }, "id" | "foundationId">

  export type FoundationContactOrderByWithAggregationInput = {
    id?: SortOrder
    foundationId?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    socialMediaLinks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoundationContactCountOrderByAggregateInput
    _avg?: FoundationContactAvgOrderByAggregateInput
    _max?: FoundationContactMaxOrderByAggregateInput
    _min?: FoundationContactMinOrderByAggregateInput
    _sum?: FoundationContactSumOrderByAggregateInput
  }

  export type FoundationContactScalarWhereWithAggregatesInput = {
    AND?: FoundationContactScalarWhereWithAggregatesInput | FoundationContactScalarWhereWithAggregatesInput[]
    OR?: FoundationContactScalarWhereWithAggregatesInput[]
    NOT?: FoundationContactScalarWhereWithAggregatesInput | FoundationContactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoundationContact"> | number
    foundationId?: IntWithAggregatesFilter<"FoundationContact"> | number
    email?: StringNullableWithAggregatesFilter<"FoundationContact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"FoundationContact"> | string | null
    address?: StringNullableWithAggregatesFilter<"FoundationContact"> | string | null
    website?: StringNullableWithAggregatesFilter<"FoundationContact"> | string | null
    socialMediaLinks?: JsonNullableWithAggregatesFilter<"FoundationContact">
    createdAt?: DateTimeWithAggregatesFilter<"FoundationContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoundationContact"> | Date | string
  }

  export type FoundationMediaWhereInput = {
    AND?: FoundationMediaWhereInput | FoundationMediaWhereInput[]
    OR?: FoundationMediaWhereInput[]
    NOT?: FoundationMediaWhereInput | FoundationMediaWhereInput[]
    id?: IntFilter<"FoundationMedia"> | number
    foundationId?: IntNullableFilter<"FoundationMedia"> | number | null
    fileName?: StringFilter<"FoundationMedia"> | string
    filePath?: StringFilter<"FoundationMedia"> | string
    fileType?: StringNullableFilter<"FoundationMedia"> | string | null
    fileSize?: IntNullableFilter<"FoundationMedia"> | number | null
    mediaType?: EnumMediaTypeFilter<"FoundationMedia"> | $Enums.MediaType
    altText?: StringNullableFilter<"FoundationMedia"> | string | null
    createdAt?: DateTimeFilter<"FoundationMedia"> | Date | string
    foundation?: XOR<FoundationNullableScalarRelationFilter, FoundationWhereInput> | null
  }

  export type FoundationMediaOrderByWithRelationInput = {
    id?: SortOrder
    foundationId?: SortOrderInput | SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    altText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    foundation?: FoundationOrderByWithRelationInput
    _relevance?: FoundationMediaOrderByRelevanceInput
  }

  export type FoundationMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoundationMediaWhereInput | FoundationMediaWhereInput[]
    OR?: FoundationMediaWhereInput[]
    NOT?: FoundationMediaWhereInput | FoundationMediaWhereInput[]
    foundationId?: IntNullableFilter<"FoundationMedia"> | number | null
    fileName?: StringFilter<"FoundationMedia"> | string
    filePath?: StringFilter<"FoundationMedia"> | string
    fileType?: StringNullableFilter<"FoundationMedia"> | string | null
    fileSize?: IntNullableFilter<"FoundationMedia"> | number | null
    mediaType?: EnumMediaTypeFilter<"FoundationMedia"> | $Enums.MediaType
    altText?: StringNullableFilter<"FoundationMedia"> | string | null
    createdAt?: DateTimeFilter<"FoundationMedia"> | Date | string
    foundation?: XOR<FoundationNullableScalarRelationFilter, FoundationWhereInput> | null
  }, "id">

  export type FoundationMediaOrderByWithAggregationInput = {
    id?: SortOrder
    foundationId?: SortOrderInput | SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    altText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FoundationMediaCountOrderByAggregateInput
    _avg?: FoundationMediaAvgOrderByAggregateInput
    _max?: FoundationMediaMaxOrderByAggregateInput
    _min?: FoundationMediaMinOrderByAggregateInput
    _sum?: FoundationMediaSumOrderByAggregateInput
  }

  export type FoundationMediaScalarWhereWithAggregatesInput = {
    AND?: FoundationMediaScalarWhereWithAggregatesInput | FoundationMediaScalarWhereWithAggregatesInput[]
    OR?: FoundationMediaScalarWhereWithAggregatesInput[]
    NOT?: FoundationMediaScalarWhereWithAggregatesInput | FoundationMediaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoundationMedia"> | number
    foundationId?: IntNullableWithAggregatesFilter<"FoundationMedia"> | number | null
    fileName?: StringWithAggregatesFilter<"FoundationMedia"> | string
    filePath?: StringWithAggregatesFilter<"FoundationMedia"> | string
    fileType?: StringNullableWithAggregatesFilter<"FoundationMedia"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"FoundationMedia"> | number | null
    mediaType?: EnumMediaTypeWithAggregatesFilter<"FoundationMedia"> | $Enums.MediaType
    altText?: StringNullableWithAggregatesFilter<"FoundationMedia"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FoundationMedia"> | Date | string
  }

  export type UserCreateInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    donations?: DonationCreateNestedManyWithoutUserInput
    pdfOrders?: PdfOrderCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    pdfOrders?: PdfOrderUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    donations?: DonationUpdateManyWithoutUserNestedInput
    pdfOrders?: PdfOrderUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    pdfOrders?: PdfOrderUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    providerType: string
    providerId: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: number
    userId: number
    providerType: string
    providerId: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: number
    userId: number
    providerType: string
    providerId: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: number
    sessionToken: string
    userId: number
    expires: Date | string
  }

  export type SessionUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: number
    sessionToken: string
    userId: number
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationCreateInput = {
    amount: number
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDonationsInput
  }

  export type DonationUncheckedCreateInput = {
    id?: number
    userId: number
    amount: number
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDonationsNestedInput
  }

  export type DonationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationCreateManyInput = {
    id?: number
    userId: number
    amount: number
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfBookCreateInput = {
    title: string
    description?: string | null
    price: number
    pdfUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: PdfOrderCreateNestedManyWithoutPdfBookInput
  }

  export type PdfBookUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    price: number
    pdfUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: PdfOrderUncheckedCreateNestedManyWithoutPdfBookInput
  }

  export type PdfBookUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: PdfOrderUpdateManyWithoutPdfBookNestedInput
  }

  export type PdfBookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: PdfOrderUncheckedUpdateManyWithoutPdfBookNestedInput
  }

  export type PdfBookCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    price: number
    pdfUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PdfBookUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfBookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfOrderCreateInput = {
    quantity?: number
    totalPrice: number
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPdfOrdersInput
    pdfBook: PdfBookCreateNestedOneWithoutOrdersInput
  }

  export type PdfOrderUncheckedCreateInput = {
    id?: number
    userId: number
    pdfBookId: number
    quantity?: number
    totalPrice: number
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PdfOrderUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPdfOrdersNestedInput
    pdfBook?: PdfBookUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type PdfOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    pdfBookId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfOrderCreateManyInput = {
    id?: number
    userId: number
    pdfBookId: number
    quantity?: number
    totalPrice: number
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PdfOrderUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    pdfBookId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    referenceId: string
    provider: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    userId: number
    referenceId: string
    provider: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    referenceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    referenceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    userId: number
    referenceId: string
    provider: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    referenceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    referenceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsCreateInput = {
    title: string
    titleEn?: string | null
    slug: string
    featuredImage?: string | null
    authorName?: string | null
    authorAvatar?: string | null
    authorRole?: string | null
    publishedDate?: string | null
    readTime?: string | null
    views?: string | null
    category?: string | null
    tags?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsUncheckedCreateInput = {
    id?: number
    title: string
    titleEn?: string | null
    slug: string
    featuredImage?: string | null
    authorName?: string | null
    authorAvatar?: string | null
    authorRole?: string | null
    publishedDate?: string | null
    readTime?: string | null
    views?: string | null
    category?: string | null
    tags?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    authorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    authorRole?: NullableStringFieldUpdateOperationsInput | string | null
    publishedDate?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    authorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    authorRole?: NullableStringFieldUpdateOperationsInput | string | null
    publishedDate?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsCreateManyInput = {
    id?: number
    title: string
    titleEn?: string | null
    slug: string
    featuredImage?: string | null
    authorName?: string | null
    authorAvatar?: string | null
    authorRole?: string | null
    publishedDate?: string | null
    readTime?: string | null
    views?: string | null
    category?: string | null
    tags?: string | null
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    authorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    authorRole?: NullableStringFieldUpdateOperationsInput | string | null
    publishedDate?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    authorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    authorRole?: NullableStringFieldUpdateOperationsInput | string | null
    publishedDate?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: NullableStringFieldUpdateOperationsInput | string | null
    views?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GopalPariwarCreateInput = {
    heroImage: string
    heroTitle: string
    heroSubtitle: string
    personalInfo: JsonNullValueInput | InputJsonValue
    spiritualEducation?: string | null
    lifeJourney: JsonNullValueInput | InputJsonValue
    responsibilities: JsonNullValueInput | InputJsonValue
    pledges: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GopalPariwarUncheckedCreateInput = {
    id?: number
    heroImage: string
    heroTitle: string
    heroSubtitle: string
    personalInfo: JsonNullValueInput | InputJsonValue
    spiritualEducation?: string | null
    lifeJourney: JsonNullValueInput | InputJsonValue
    responsibilities: JsonNullValueInput | InputJsonValue
    pledges: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GopalPariwarUpdateInput = {
    heroImage?: StringFieldUpdateOperationsInput | string
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    personalInfo?: JsonNullValueInput | InputJsonValue
    spiritualEducation?: NullableStringFieldUpdateOperationsInput | string | null
    lifeJourney?: JsonNullValueInput | InputJsonValue
    responsibilities?: JsonNullValueInput | InputJsonValue
    pledges?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GopalPariwarUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    heroImage?: StringFieldUpdateOperationsInput | string
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    personalInfo?: JsonNullValueInput | InputJsonValue
    spiritualEducation?: NullableStringFieldUpdateOperationsInput | string | null
    lifeJourney?: JsonNullValueInput | InputJsonValue
    responsibilities?: JsonNullValueInput | InputJsonValue
    pledges?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GopalPariwarCreateManyInput = {
    id?: number
    heroImage: string
    heroTitle: string
    heroSubtitle: string
    personalInfo: JsonNullValueInput | InputJsonValue
    spiritualEducation?: string | null
    lifeJourney: JsonNullValueInput | InputJsonValue
    responsibilities: JsonNullValueInput | InputJsonValue
    pledges: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GopalPariwarUpdateManyMutationInput = {
    heroImage?: StringFieldUpdateOperationsInput | string
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    personalInfo?: JsonNullValueInput | InputJsonValue
    spiritualEducation?: NullableStringFieldUpdateOperationsInput | string | null
    lifeJourney?: JsonNullValueInput | InputJsonValue
    responsibilities?: JsonNullValueInput | InputJsonValue
    pledges?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GopalPariwarUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    heroImage?: StringFieldUpdateOperationsInput | string
    heroTitle?: StringFieldUpdateOperationsInput | string
    heroSubtitle?: StringFieldUpdateOperationsInput | string
    personalInfo?: JsonNullValueInput | InputJsonValue
    spiritualEducation?: NullableStringFieldUpdateOperationsInput | string | null
    lifeJourney?: JsonNullValueInput | InputJsonValue
    responsibilities?: JsonNullValueInput | InputJsonValue
    pledges?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaushalaCreateInput = {
    name: string
    address: string
    establishmentYear: number
    contactDetails: string
    totalCows: number
    capacity: number
    description?: string | null
    city: string
    state: string
    pincode: string
    contactPerson: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaushalaUncheckedCreateInput = {
    id?: number
    name: string
    address: string
    establishmentYear: number
    contactDetails: string
    totalCows: number
    capacity: number
    description?: string | null
    city: string
    state: string
    pincode: string
    contactPerson: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaushalaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    establishmentYear?: IntFieldUpdateOperationsInput | number
    contactDetails?: StringFieldUpdateOperationsInput | string
    totalCows?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaushalaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    establishmentYear?: IntFieldUpdateOperationsInput | number
    contactDetails?: StringFieldUpdateOperationsInput | string
    totalCows?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaushalaCreateManyInput = {
    id?: number
    name: string
    address: string
    establishmentYear: number
    contactDetails: string
    totalCows: number
    capacity: number
    description?: string | null
    city: string
    state: string
    pincode: string
    contactPerson: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GaushalaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    establishmentYear?: IntFieldUpdateOperationsInput | number
    contactDetails?: StringFieldUpdateOperationsInput | string
    totalCows?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GaushalaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    establishmentYear?: IntFieldUpdateOperationsInput | number
    contactDetails?: StringFieldUpdateOperationsInput | string
    totalCows?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardCreateInput = {
    title: string
    titleEn?: string | null
    link: string
    image?: string | null
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CardUncheckedCreateInput = {
    id?: number
    title: string
    titleEn?: string | null
    link: string
    image?: string | null
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CardUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardCreateManyInput = {
    id?: number
    title: string
    titleEn?: string | null
    link: string
    image?: string | null
    order?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CardUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DtaSanssthanCreateInput = {
    name: string
    person?: string | null
    image?: string | null
    description?: string | null
    email?: string | null
    phone?: string | null
    altPhone?: string | null
    website?: string | null
    timing?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DtaSanssthanUncheckedCreateInput = {
    id?: number
    name: string
    person?: string | null
    image?: string | null
    description?: string | null
    email?: string | null
    phone?: string | null
    altPhone?: string | null
    website?: string | null
    timing?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DtaSanssthanUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    person?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DtaSanssthanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    person?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DtaSanssthanCreateManyInput = {
    id?: number
    name: string
    person?: string | null
    image?: string | null
    description?: string | null
    email?: string | null
    phone?: string | null
    altPhone?: string | null
    website?: string | null
    timing?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DtaSanssthanUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    person?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DtaSanssthanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    person?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    altPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyPolicyCreateInput = {
    title: string
    subtitle?: string | null
    sections: JsonNullValueInput | InputJsonValue
    email?: string | null
    phone?: string | null
    callingHours?: string | null
    mailingAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivacyPolicyUncheckedCreateInput = {
    id?: number
    title: string
    subtitle?: string | null
    sections: JsonNullValueInput | InputJsonValue
    email?: string | null
    phone?: string | null
    callingHours?: string | null
    mailingAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivacyPolicyUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    callingHours?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyPolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    callingHours?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyPolicyCreateManyInput = {
    id?: number
    title: string
    subtitle?: string | null
    sections: JsonNullValueInput | InputJsonValue
    email?: string | null
    phone?: string | null
    callingHours?: string | null
    mailingAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivacyPolicyUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    callingHours?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyPolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    callingHours?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermsConditionsCreateInput = {
    title: string
    subtitle?: string | null
    sections: JsonNullValueInput | InputJsonValue
    email?: string | null
    phone?: string | null
    callingHours?: string | null
    mailingAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermsConditionsUncheckedCreateInput = {
    id?: number
    title: string
    subtitle?: string | null
    sections: JsonNullValueInput | InputJsonValue
    email?: string | null
    phone?: string | null
    callingHours?: string | null
    mailingAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermsConditionsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    callingHours?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermsConditionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    callingHours?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermsConditionsCreateManyInput = {
    id?: number
    title: string
    subtitle?: string | null
    sections: JsonNullValueInput | InputJsonValue
    email?: string | null
    phone?: string | null
    callingHours?: string | null
    mailingAddress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermsConditionsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    callingHours?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermsConditionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: JsonNullValueInput | InputJsonValue
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    callingHours?: NullableStringFieldUpdateOperationsInput | string | null
    mailingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerCreateInput = {
    title: string
    image: string
    active?: boolean
    order: number
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUncheckedCreateInput = {
    id?: number
    title: string
    image: string
    active?: boolean
    order: number
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerCreateManyInput = {
    id?: number
    title: string
    image: string
    active?: boolean
    order: number
    publicId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    publicId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    info: string
    createdAt?: Date | string
  }

  export type MessageUncheckedCreateInput = {
    id?: number
    info: string
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    info?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    info?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: number
    info: string
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    info?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    info?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationCreateInput = {
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatCreateNestedManyWithoutFoundationInput
    activities?: FoundationActivityCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactCreateNestedOneWithoutFoundationInput
    media?: FoundationMediaCreateNestedManyWithoutFoundationInput
  }

  export type FoundationUncheckedCreateInput = {
    id?: number
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatUncheckedCreateNestedManyWithoutFoundationInput
    activities?: FoundationActivityUncheckedCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveUncheckedCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactUncheckedCreateNestedOneWithoutFoundationInput
    media?: FoundationMediaUncheckedCreateNestedManyWithoutFoundationInput
  }

  export type FoundationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUpdateManyWithoutFoundationNestedInput
    activities?: FoundationActivityUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUpdateOneWithoutFoundationNestedInput
    media?: FoundationMediaUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUncheckedUpdateManyWithoutFoundationNestedInput
    activities?: FoundationActivityUncheckedUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUncheckedUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUncheckedUpdateOneWithoutFoundationNestedInput
    media?: FoundationMediaUncheckedUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationCreateManyInput = {
    id?: number
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
  }

  export type FoundationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FoundationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FoundationStatCreateInput = {
    label: string
    value: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    foundation: FoundationCreateNestedOneWithoutStatsInput
  }

  export type FoundationStatUncheckedCreateInput = {
    id?: number
    foundationId: number
    label: string
    value: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationStatUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foundation?: FoundationUpdateOneRequiredWithoutStatsNestedInput
  }

  export type FoundationStatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationStatCreateManyInput = {
    id?: number
    foundationId: number
    label: string
    value: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationStatUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationStatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationActivityCreateInput = {
    activityText: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    foundation: FoundationCreateNestedOneWithoutActivitiesInput
  }

  export type FoundationActivityUncheckedCreateInput = {
    id?: number
    foundationId: number
    activityText: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationActivityUpdateInput = {
    activityText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foundation?: FoundationUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type FoundationActivityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: IntFieldUpdateOperationsInput | number
    activityText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationActivityCreateManyInput = {
    id?: number
    foundationId: number
    activityText: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationActivityUpdateManyMutationInput = {
    activityText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationActivityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: IntFieldUpdateOperationsInput | number
    activityText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationObjectiveCreateInput = {
    title: string
    description?: string | null
    objectiveType?: $Enums.ObjectiveType
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    foundation: FoundationCreateNestedOneWithoutObjectivesInput
  }

  export type FoundationObjectiveUncheckedCreateInput = {
    id?: number
    foundationId: number
    title: string
    description?: string | null
    objectiveType?: $Enums.ObjectiveType
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationObjectiveUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveType?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foundation?: FoundationUpdateOneRequiredWithoutObjectivesNestedInput
  }

  export type FoundationObjectiveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveType?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationObjectiveCreateManyInput = {
    id?: number
    foundationId: number
    title: string
    description?: string | null
    objectiveType?: $Enums.ObjectiveType
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationObjectiveUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveType?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationObjectiveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveType?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationContactCreateInput = {
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    foundation: FoundationCreateNestedOneWithoutContactInput
  }

  export type FoundationContactUncheckedCreateInput = {
    id?: number
    foundationId: number
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationContactUpdateInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foundation?: FoundationUpdateOneRequiredWithoutContactNestedInput
  }

  export type FoundationContactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationContactCreateManyInput = {
    id?: number
    foundationId: number
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationContactUpdateManyMutationInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationContactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationMediaCreateInput = {
    fileName: string
    filePath: string
    fileType?: string | null
    fileSize?: number | null
    mediaType?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
    foundation?: FoundationCreateNestedOneWithoutMediaInput
  }

  export type FoundationMediaUncheckedCreateInput = {
    id?: number
    foundationId?: number | null
    fileName: string
    filePath: string
    fileType?: string | null
    fileSize?: number | null
    mediaType?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
  }

  export type FoundationMediaUpdateInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foundation?: FoundationUpdateOneWithoutMediaNestedInput
  }

  export type FoundationMediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: NullableIntFieldUpdateOperationsInput | number | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationMediaCreateManyInput = {
    id?: number
    foundationId?: number | null
    fileName: string
    filePath: string
    fileType?: string | null
    fileSize?: number | null
    mediaType?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
  }

  export type FoundationMediaUpdateManyMutationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationMediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    foundationId?: NullableIntFieldUpdateOperationsInput | number | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DonationListRelationFilter = {
    every?: DonationWhereInput
    some?: DonationWhereInput
    none?: DonationWhereInput
  }

  export type PdfOrderListRelationFilter = {
    every?: PdfOrderWhereInput
    some?: PdfOrderWhereInput
    none?: PdfOrderWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DonationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PdfOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    image?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    otpCode?: SortOrder
    otpExpires?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    image?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    otpCode?: SortOrder
    otpExpires?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    image?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    otpCode?: SortOrder
    otpExpires?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountOrderByRelevanceInput = {
    fields: AccountOrderByRelevanceFieldEnum | AccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    providerType?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    providerType?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    providerType?: SortOrder
    providerId?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionOrderByRelevanceInput = {
    fields: SessionOrderByRelevanceFieldEnum | SessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DonationOrderByRelevanceInput = {
    fields: DonationOrderByRelevanceFieldEnum | DonationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DonationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DonationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }

  export type DonationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DonationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DonationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type PdfBookOrderByRelevanceInput = {
    fields: PdfBookOrderByRelevanceFieldEnum | PdfBookOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PdfBookCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PdfBookAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type PdfBookMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PdfBookMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PdfBookSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type PdfBookScalarRelationFilter = {
    is?: PdfBookWhereInput
    isNot?: PdfBookWhereInput
  }

  export type PdfOrderOrderByRelevanceInput = {
    fields: PdfOrderOrderByRelevanceFieldEnum | PdfOrderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PdfOrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pdfBookId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PdfOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pdfBookId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type PdfOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pdfBookId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PdfOrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pdfBookId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PdfOrderSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    pdfBookId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type PaymentOrderByRelevanceInput = {
    fields: PaymentOrderByRelevanceFieldEnum | PaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    referenceId?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    referenceId?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    referenceId?: SortOrder
    provider?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NewsOrderByRelevanceInput = {
    fields: NewsOrderByRelevanceFieldEnum | NewsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NewsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    slug?: SortOrder
    featuredImage?: SortOrder
    authorName?: SortOrder
    authorAvatar?: SortOrder
    authorRole?: SortOrder
    publishedDate?: SortOrder
    readTime?: SortOrder
    views?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NewsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    slug?: SortOrder
    featuredImage?: SortOrder
    authorName?: SortOrder
    authorAvatar?: SortOrder
    authorRole?: SortOrder
    publishedDate?: SortOrder
    readTime?: SortOrder
    views?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    slug?: SortOrder
    featuredImage?: SortOrder
    authorName?: SortOrder
    authorAvatar?: SortOrder
    authorRole?: SortOrder
    publishedDate?: SortOrder
    readTime?: SortOrder
    views?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type GopalPariwarOrderByRelevanceInput = {
    fields: GopalPariwarOrderByRelevanceFieldEnum | GopalPariwarOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GopalPariwarCountOrderByAggregateInput = {
    id?: SortOrder
    heroImage?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    personalInfo?: SortOrder
    spiritualEducation?: SortOrder
    lifeJourney?: SortOrder
    responsibilities?: SortOrder
    pledges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GopalPariwarAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GopalPariwarMaxOrderByAggregateInput = {
    id?: SortOrder
    heroImage?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    spiritualEducation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GopalPariwarMinOrderByAggregateInput = {
    id?: SortOrder
    heroImage?: SortOrder
    heroTitle?: SortOrder
    heroSubtitle?: SortOrder
    spiritualEducation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GopalPariwarSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GaushalaOrderByRelevanceInput = {
    fields: GaushalaOrderByRelevanceFieldEnum | GaushalaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GaushalaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    establishmentYear?: SortOrder
    contactDetails?: SortOrder
    totalCows?: SortOrder
    capacity?: SortOrder
    description?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    contactPerson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaushalaAvgOrderByAggregateInput = {
    id?: SortOrder
    establishmentYear?: SortOrder
    totalCows?: SortOrder
    capacity?: SortOrder
  }

  export type GaushalaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    establishmentYear?: SortOrder
    contactDetails?: SortOrder
    totalCows?: SortOrder
    capacity?: SortOrder
    description?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    contactPerson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaushalaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    establishmentYear?: SortOrder
    contactDetails?: SortOrder
    totalCows?: SortOrder
    capacity?: SortOrder
    description?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    contactPerson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GaushalaSumOrderByAggregateInput = {
    id?: SortOrder
    establishmentYear?: SortOrder
    totalCows?: SortOrder
    capacity?: SortOrder
  }

  export type CardOrderByRelevanceInput = {
    fields: CardOrderByRelevanceFieldEnum | CardOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CardCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    link?: SortOrder
    image?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type CardMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    link?: SortOrder
    image?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    link?: SortOrder
    image?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CardSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type DtaSanssthanOrderByRelevanceInput = {
    fields: DtaSanssthanOrderByRelevanceFieldEnum | DtaSanssthanOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DtaSanssthanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    person?: SortOrder
    image?: SortOrder
    description?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    altPhone?: SortOrder
    website?: SortOrder
    timing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DtaSanssthanAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DtaSanssthanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    person?: SortOrder
    image?: SortOrder
    description?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    altPhone?: SortOrder
    website?: SortOrder
    timing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DtaSanssthanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    person?: SortOrder
    image?: SortOrder
    description?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    altPhone?: SortOrder
    website?: SortOrder
    timing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DtaSanssthanSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PrivacyPolicyOrderByRelevanceInput = {
    fields: PrivacyPolicyOrderByRelevanceFieldEnum | PrivacyPolicyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PrivacyPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    sections?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    callingHours?: SortOrder
    mailingAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivacyPolicyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PrivacyPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    callingHours?: SortOrder
    mailingAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivacyPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    callingHours?: SortOrder
    mailingAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivacyPolicySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TermsConditionsOrderByRelevanceInput = {
    fields: TermsConditionsOrderByRelevanceFieldEnum | TermsConditionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TermsConditionsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    sections?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    callingHours?: SortOrder
    mailingAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TermsConditionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TermsConditionsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    callingHours?: SortOrder
    mailingAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TermsConditionsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    callingHours?: SortOrder
    mailingAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TermsConditionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BannerOrderByRelevanceInput = {
    fields: BannerOrderByRelevanceFieldEnum | BannerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BannerCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    active?: SortOrder
    order?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type BannerMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    active?: SortOrder
    order?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image?: SortOrder
    active?: SortOrder
    order?: SortOrder
    publicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type MessageOrderByRelevanceInput = {
    fields: MessageOrderByRelevanceFieldEnum | MessageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    info?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    info?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    info?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FoundationStatListRelationFilter = {
    every?: FoundationStatWhereInput
    some?: FoundationStatWhereInput
    none?: FoundationStatWhereInput
  }

  export type FoundationActivityListRelationFilter = {
    every?: FoundationActivityWhereInput
    some?: FoundationActivityWhereInput
    none?: FoundationActivityWhereInput
  }

  export type FoundationObjectiveListRelationFilter = {
    every?: FoundationObjectiveWhereInput
    some?: FoundationObjectiveWhereInput
    none?: FoundationObjectiveWhereInput
  }

  export type FoundationContactNullableScalarRelationFilter = {
    is?: FoundationContactWhereInput | null
    isNot?: FoundationContactWhereInput | null
  }

  export type FoundationMediaListRelationFilter = {
    every?: FoundationMediaWhereInput
    some?: FoundationMediaWhereInput
    none?: FoundationMediaWhereInput
  }

  export type FoundationStatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoundationActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoundationObjectiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoundationMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoundationOrderByRelevanceInput = {
    fields: FoundationOrderByRelevanceFieldEnum | FoundationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FoundationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tagline?: SortOrder
    logoUrl?: SortOrder
    description?: SortOrder
    establishedYear?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type FoundationAvgOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type FoundationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tagline?: SortOrder
    logoUrl?: SortOrder
    description?: SortOrder
    establishedYear?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type FoundationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tagline?: SortOrder
    logoUrl?: SortOrder
    description?: SortOrder
    establishedYear?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type FoundationSumOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type FoundationScalarRelationFilter = {
    is?: FoundationWhereInput
    isNot?: FoundationWhereInput
  }

  export type FoundationStatOrderByRelevanceInput = {
    fields: FoundationStatOrderByRelevanceFieldEnum | FoundationStatOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FoundationStatCountOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationStatAvgOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    displayOrder?: SortOrder
  }

  export type FoundationStatMaxOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationStatMinOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationStatSumOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    displayOrder?: SortOrder
  }

  export type FoundationActivityOrderByRelevanceInput = {
    fields: FoundationActivityOrderByRelevanceFieldEnum | FoundationActivityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FoundationActivityCountOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    activityText?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationActivityAvgOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    displayOrder?: SortOrder
  }

  export type FoundationActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    activityText?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationActivityMinOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    activityText?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationActivitySumOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    displayOrder?: SortOrder
  }

  export type EnumObjectiveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectiveType | EnumObjectiveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectiveType[]
    notIn?: $Enums.ObjectiveType[]
    not?: NestedEnumObjectiveTypeFilter<$PrismaModel> | $Enums.ObjectiveType
  }

  export type FoundationObjectiveOrderByRelevanceInput = {
    fields: FoundationObjectiveOrderByRelevanceFieldEnum | FoundationObjectiveOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FoundationObjectiveCountOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    objectiveType?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationObjectiveAvgOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    displayOrder?: SortOrder
  }

  export type FoundationObjectiveMaxOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    objectiveType?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationObjectiveMinOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    objectiveType?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationObjectiveSumOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    displayOrder?: SortOrder
  }

  export type EnumObjectiveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectiveType | EnumObjectiveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectiveType[]
    notIn?: $Enums.ObjectiveType[]
    not?: NestedEnumObjectiveTypeWithAggregatesFilter<$PrismaModel> | $Enums.ObjectiveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumObjectiveTypeFilter<$PrismaModel>
    _max?: NestedEnumObjectiveTypeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FoundationContactOrderByRelevanceInput = {
    fields: FoundationContactOrderByRelevanceFieldEnum | FoundationContactOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FoundationContactCountOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    website?: SortOrder
    socialMediaLinks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationContactAvgOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
  }

  export type FoundationContactMaxOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationContactMinOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoundationContactSumOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[]
    notIn?: $Enums.MediaType[]
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type FoundationNullableScalarRelationFilter = {
    is?: FoundationWhereInput | null
    isNot?: FoundationWhereInput | null
  }

  export type FoundationMediaOrderByRelevanceInput = {
    fields: FoundationMediaOrderByRelevanceFieldEnum | FoundationMediaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FoundationMediaCountOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    mediaType?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
  }

  export type FoundationMediaAvgOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    fileSize?: SortOrder
  }

  export type FoundationMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    mediaType?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
  }

  export type FoundationMediaMinOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    mediaType?: SortOrder
    altText?: SortOrder
    createdAt?: SortOrder
  }

  export type FoundationMediaSumOrderByAggregateInput = {
    id?: SortOrder
    foundationId?: SortOrder
    fileSize?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[]
    notIn?: $Enums.MediaType[]
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type DonationCreateNestedManyWithoutUserInput = {
    create?: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput> | DonationCreateWithoutUserInput[] | DonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutUserInput | DonationCreateOrConnectWithoutUserInput[]
    createMany?: DonationCreateManyUserInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type PdfOrderCreateNestedManyWithoutUserInput = {
    create?: XOR<PdfOrderCreateWithoutUserInput, PdfOrderUncheckedCreateWithoutUserInput> | PdfOrderCreateWithoutUserInput[] | PdfOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PdfOrderCreateOrConnectWithoutUserInput | PdfOrderCreateOrConnectWithoutUserInput[]
    createMany?: PdfOrderCreateManyUserInputEnvelope
    connect?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DonationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput> | DonationCreateWithoutUserInput[] | DonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutUserInput | DonationCreateOrConnectWithoutUserInput[]
    createMany?: DonationCreateManyUserInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type PdfOrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PdfOrderCreateWithoutUserInput, PdfOrderUncheckedCreateWithoutUserInput> | PdfOrderCreateWithoutUserInput[] | PdfOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PdfOrderCreateOrConnectWithoutUserInput | PdfOrderCreateOrConnectWithoutUserInput[]
    createMany?: PdfOrderCreateManyUserInputEnvelope
    connect?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DonationUpdateManyWithoutUserNestedInput = {
    create?: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput> | DonationCreateWithoutUserInput[] | DonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutUserInput | DonationCreateOrConnectWithoutUserInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutUserInput | DonationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DonationCreateManyUserInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutUserInput | DonationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutUserInput | DonationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type PdfOrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<PdfOrderCreateWithoutUserInput, PdfOrderUncheckedCreateWithoutUserInput> | PdfOrderCreateWithoutUserInput[] | PdfOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PdfOrderCreateOrConnectWithoutUserInput | PdfOrderCreateOrConnectWithoutUserInput[]
    upsert?: PdfOrderUpsertWithWhereUniqueWithoutUserInput | PdfOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PdfOrderCreateManyUserInputEnvelope
    set?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
    disconnect?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
    delete?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
    connect?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
    update?: PdfOrderUpdateWithWhereUniqueWithoutUserInput | PdfOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PdfOrderUpdateManyWithWhereWithoutUserInput | PdfOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PdfOrderScalarWhereInput | PdfOrderScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DonationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput> | DonationCreateWithoutUserInput[] | DonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutUserInput | DonationCreateOrConnectWithoutUserInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutUserInput | DonationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DonationCreateManyUserInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutUserInput | DonationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutUserInput | DonationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type PdfOrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PdfOrderCreateWithoutUserInput, PdfOrderUncheckedCreateWithoutUserInput> | PdfOrderCreateWithoutUserInput[] | PdfOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PdfOrderCreateOrConnectWithoutUserInput | PdfOrderCreateOrConnectWithoutUserInput[]
    upsert?: PdfOrderUpsertWithWhereUniqueWithoutUserInput | PdfOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PdfOrderCreateManyUserInputEnvelope
    set?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
    disconnect?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
    delete?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
    connect?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
    update?: PdfOrderUpdateWithWhereUniqueWithoutUserInput | PdfOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PdfOrderUpdateManyWithWhereWithoutUserInput | PdfOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PdfOrderScalarWhereInput | PdfOrderScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutDonationsInput = {
    create?: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDonationsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutDonationsNestedInput = {
    create?: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDonationsInput
    upsert?: UserUpsertWithoutDonationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDonationsInput, UserUpdateWithoutDonationsInput>, UserUncheckedUpdateWithoutDonationsInput>
  }

  export type PdfOrderCreateNestedManyWithoutPdfBookInput = {
    create?: XOR<PdfOrderCreateWithoutPdfBookInput, PdfOrderUncheckedCreateWithoutPdfBookInput> | PdfOrderCreateWithoutPdfBookInput[] | PdfOrderUncheckedCreateWithoutPdfBookInput[]
    connectOrCreate?: PdfOrderCreateOrConnectWithoutPdfBookInput | PdfOrderCreateOrConnectWithoutPdfBookInput[]
    createMany?: PdfOrderCreateManyPdfBookInputEnvelope
    connect?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
  }

  export type PdfOrderUncheckedCreateNestedManyWithoutPdfBookInput = {
    create?: XOR<PdfOrderCreateWithoutPdfBookInput, PdfOrderUncheckedCreateWithoutPdfBookInput> | PdfOrderCreateWithoutPdfBookInput[] | PdfOrderUncheckedCreateWithoutPdfBookInput[]
    connectOrCreate?: PdfOrderCreateOrConnectWithoutPdfBookInput | PdfOrderCreateOrConnectWithoutPdfBookInput[]
    createMany?: PdfOrderCreateManyPdfBookInputEnvelope
    connect?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
  }

  export type PdfOrderUpdateManyWithoutPdfBookNestedInput = {
    create?: XOR<PdfOrderCreateWithoutPdfBookInput, PdfOrderUncheckedCreateWithoutPdfBookInput> | PdfOrderCreateWithoutPdfBookInput[] | PdfOrderUncheckedCreateWithoutPdfBookInput[]
    connectOrCreate?: PdfOrderCreateOrConnectWithoutPdfBookInput | PdfOrderCreateOrConnectWithoutPdfBookInput[]
    upsert?: PdfOrderUpsertWithWhereUniqueWithoutPdfBookInput | PdfOrderUpsertWithWhereUniqueWithoutPdfBookInput[]
    createMany?: PdfOrderCreateManyPdfBookInputEnvelope
    set?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
    disconnect?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
    delete?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
    connect?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
    update?: PdfOrderUpdateWithWhereUniqueWithoutPdfBookInput | PdfOrderUpdateWithWhereUniqueWithoutPdfBookInput[]
    updateMany?: PdfOrderUpdateManyWithWhereWithoutPdfBookInput | PdfOrderUpdateManyWithWhereWithoutPdfBookInput[]
    deleteMany?: PdfOrderScalarWhereInput | PdfOrderScalarWhereInput[]
  }

  export type PdfOrderUncheckedUpdateManyWithoutPdfBookNestedInput = {
    create?: XOR<PdfOrderCreateWithoutPdfBookInput, PdfOrderUncheckedCreateWithoutPdfBookInput> | PdfOrderCreateWithoutPdfBookInput[] | PdfOrderUncheckedCreateWithoutPdfBookInput[]
    connectOrCreate?: PdfOrderCreateOrConnectWithoutPdfBookInput | PdfOrderCreateOrConnectWithoutPdfBookInput[]
    upsert?: PdfOrderUpsertWithWhereUniqueWithoutPdfBookInput | PdfOrderUpsertWithWhereUniqueWithoutPdfBookInput[]
    createMany?: PdfOrderCreateManyPdfBookInputEnvelope
    set?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
    disconnect?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
    delete?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
    connect?: PdfOrderWhereUniqueInput | PdfOrderWhereUniqueInput[]
    update?: PdfOrderUpdateWithWhereUniqueWithoutPdfBookInput | PdfOrderUpdateWithWhereUniqueWithoutPdfBookInput[]
    updateMany?: PdfOrderUpdateManyWithWhereWithoutPdfBookInput | PdfOrderUpdateManyWithWhereWithoutPdfBookInput[]
    deleteMany?: PdfOrderScalarWhereInput | PdfOrderScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPdfOrdersInput = {
    create?: XOR<UserCreateWithoutPdfOrdersInput, UserUncheckedCreateWithoutPdfOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPdfOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type PdfBookCreateNestedOneWithoutOrdersInput = {
    create?: XOR<PdfBookCreateWithoutOrdersInput, PdfBookUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PdfBookCreateOrConnectWithoutOrdersInput
    connect?: PdfBookWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPdfOrdersNestedInput = {
    create?: XOR<UserCreateWithoutPdfOrdersInput, UserUncheckedCreateWithoutPdfOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPdfOrdersInput
    upsert?: UserUpsertWithoutPdfOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPdfOrdersInput, UserUpdateWithoutPdfOrdersInput>, UserUncheckedUpdateWithoutPdfOrdersInput>
  }

  export type PdfBookUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<PdfBookCreateWithoutOrdersInput, PdfBookUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PdfBookCreateOrConnectWithoutOrdersInput
    upsert?: PdfBookUpsertWithoutOrdersInput
    connect?: PdfBookWhereUniqueInput
    update?: XOR<XOR<PdfBookUpdateToOneWithWhereWithoutOrdersInput, PdfBookUpdateWithoutOrdersInput>, PdfBookUncheckedUpdateWithoutOrdersInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type FoundationStatCreateNestedManyWithoutFoundationInput = {
    create?: XOR<FoundationStatCreateWithoutFoundationInput, FoundationStatUncheckedCreateWithoutFoundationInput> | FoundationStatCreateWithoutFoundationInput[] | FoundationStatUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationStatCreateOrConnectWithoutFoundationInput | FoundationStatCreateOrConnectWithoutFoundationInput[]
    createMany?: FoundationStatCreateManyFoundationInputEnvelope
    connect?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
  }

  export type FoundationActivityCreateNestedManyWithoutFoundationInput = {
    create?: XOR<FoundationActivityCreateWithoutFoundationInput, FoundationActivityUncheckedCreateWithoutFoundationInput> | FoundationActivityCreateWithoutFoundationInput[] | FoundationActivityUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationActivityCreateOrConnectWithoutFoundationInput | FoundationActivityCreateOrConnectWithoutFoundationInput[]
    createMany?: FoundationActivityCreateManyFoundationInputEnvelope
    connect?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
  }

  export type FoundationObjectiveCreateNestedManyWithoutFoundationInput = {
    create?: XOR<FoundationObjectiveCreateWithoutFoundationInput, FoundationObjectiveUncheckedCreateWithoutFoundationInput> | FoundationObjectiveCreateWithoutFoundationInput[] | FoundationObjectiveUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationObjectiveCreateOrConnectWithoutFoundationInput | FoundationObjectiveCreateOrConnectWithoutFoundationInput[]
    createMany?: FoundationObjectiveCreateManyFoundationInputEnvelope
    connect?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
  }

  export type FoundationContactCreateNestedOneWithoutFoundationInput = {
    create?: XOR<FoundationContactCreateWithoutFoundationInput, FoundationContactUncheckedCreateWithoutFoundationInput>
    connectOrCreate?: FoundationContactCreateOrConnectWithoutFoundationInput
    connect?: FoundationContactWhereUniqueInput
  }

  export type FoundationMediaCreateNestedManyWithoutFoundationInput = {
    create?: XOR<FoundationMediaCreateWithoutFoundationInput, FoundationMediaUncheckedCreateWithoutFoundationInput> | FoundationMediaCreateWithoutFoundationInput[] | FoundationMediaUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationMediaCreateOrConnectWithoutFoundationInput | FoundationMediaCreateOrConnectWithoutFoundationInput[]
    createMany?: FoundationMediaCreateManyFoundationInputEnvelope
    connect?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
  }

  export type FoundationStatUncheckedCreateNestedManyWithoutFoundationInput = {
    create?: XOR<FoundationStatCreateWithoutFoundationInput, FoundationStatUncheckedCreateWithoutFoundationInput> | FoundationStatCreateWithoutFoundationInput[] | FoundationStatUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationStatCreateOrConnectWithoutFoundationInput | FoundationStatCreateOrConnectWithoutFoundationInput[]
    createMany?: FoundationStatCreateManyFoundationInputEnvelope
    connect?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
  }

  export type FoundationActivityUncheckedCreateNestedManyWithoutFoundationInput = {
    create?: XOR<FoundationActivityCreateWithoutFoundationInput, FoundationActivityUncheckedCreateWithoutFoundationInput> | FoundationActivityCreateWithoutFoundationInput[] | FoundationActivityUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationActivityCreateOrConnectWithoutFoundationInput | FoundationActivityCreateOrConnectWithoutFoundationInput[]
    createMany?: FoundationActivityCreateManyFoundationInputEnvelope
    connect?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
  }

  export type FoundationObjectiveUncheckedCreateNestedManyWithoutFoundationInput = {
    create?: XOR<FoundationObjectiveCreateWithoutFoundationInput, FoundationObjectiveUncheckedCreateWithoutFoundationInput> | FoundationObjectiveCreateWithoutFoundationInput[] | FoundationObjectiveUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationObjectiveCreateOrConnectWithoutFoundationInput | FoundationObjectiveCreateOrConnectWithoutFoundationInput[]
    createMany?: FoundationObjectiveCreateManyFoundationInputEnvelope
    connect?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
  }

  export type FoundationContactUncheckedCreateNestedOneWithoutFoundationInput = {
    create?: XOR<FoundationContactCreateWithoutFoundationInput, FoundationContactUncheckedCreateWithoutFoundationInput>
    connectOrCreate?: FoundationContactCreateOrConnectWithoutFoundationInput
    connect?: FoundationContactWhereUniqueInput
  }

  export type FoundationMediaUncheckedCreateNestedManyWithoutFoundationInput = {
    create?: XOR<FoundationMediaCreateWithoutFoundationInput, FoundationMediaUncheckedCreateWithoutFoundationInput> | FoundationMediaCreateWithoutFoundationInput[] | FoundationMediaUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationMediaCreateOrConnectWithoutFoundationInput | FoundationMediaCreateOrConnectWithoutFoundationInput[]
    createMany?: FoundationMediaCreateManyFoundationInputEnvelope
    connect?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
  }

  export type FoundationStatUpdateManyWithoutFoundationNestedInput = {
    create?: XOR<FoundationStatCreateWithoutFoundationInput, FoundationStatUncheckedCreateWithoutFoundationInput> | FoundationStatCreateWithoutFoundationInput[] | FoundationStatUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationStatCreateOrConnectWithoutFoundationInput | FoundationStatCreateOrConnectWithoutFoundationInput[]
    upsert?: FoundationStatUpsertWithWhereUniqueWithoutFoundationInput | FoundationStatUpsertWithWhereUniqueWithoutFoundationInput[]
    createMany?: FoundationStatCreateManyFoundationInputEnvelope
    set?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
    disconnect?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
    delete?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
    connect?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
    update?: FoundationStatUpdateWithWhereUniqueWithoutFoundationInput | FoundationStatUpdateWithWhereUniqueWithoutFoundationInput[]
    updateMany?: FoundationStatUpdateManyWithWhereWithoutFoundationInput | FoundationStatUpdateManyWithWhereWithoutFoundationInput[]
    deleteMany?: FoundationStatScalarWhereInput | FoundationStatScalarWhereInput[]
  }

  export type FoundationActivityUpdateManyWithoutFoundationNestedInput = {
    create?: XOR<FoundationActivityCreateWithoutFoundationInput, FoundationActivityUncheckedCreateWithoutFoundationInput> | FoundationActivityCreateWithoutFoundationInput[] | FoundationActivityUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationActivityCreateOrConnectWithoutFoundationInput | FoundationActivityCreateOrConnectWithoutFoundationInput[]
    upsert?: FoundationActivityUpsertWithWhereUniqueWithoutFoundationInput | FoundationActivityUpsertWithWhereUniqueWithoutFoundationInput[]
    createMany?: FoundationActivityCreateManyFoundationInputEnvelope
    set?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
    disconnect?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
    delete?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
    connect?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
    update?: FoundationActivityUpdateWithWhereUniqueWithoutFoundationInput | FoundationActivityUpdateWithWhereUniqueWithoutFoundationInput[]
    updateMany?: FoundationActivityUpdateManyWithWhereWithoutFoundationInput | FoundationActivityUpdateManyWithWhereWithoutFoundationInput[]
    deleteMany?: FoundationActivityScalarWhereInput | FoundationActivityScalarWhereInput[]
  }

  export type FoundationObjectiveUpdateManyWithoutFoundationNestedInput = {
    create?: XOR<FoundationObjectiveCreateWithoutFoundationInput, FoundationObjectiveUncheckedCreateWithoutFoundationInput> | FoundationObjectiveCreateWithoutFoundationInput[] | FoundationObjectiveUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationObjectiveCreateOrConnectWithoutFoundationInput | FoundationObjectiveCreateOrConnectWithoutFoundationInput[]
    upsert?: FoundationObjectiveUpsertWithWhereUniqueWithoutFoundationInput | FoundationObjectiveUpsertWithWhereUniqueWithoutFoundationInput[]
    createMany?: FoundationObjectiveCreateManyFoundationInputEnvelope
    set?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
    disconnect?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
    delete?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
    connect?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
    update?: FoundationObjectiveUpdateWithWhereUniqueWithoutFoundationInput | FoundationObjectiveUpdateWithWhereUniqueWithoutFoundationInput[]
    updateMany?: FoundationObjectiveUpdateManyWithWhereWithoutFoundationInput | FoundationObjectiveUpdateManyWithWhereWithoutFoundationInput[]
    deleteMany?: FoundationObjectiveScalarWhereInput | FoundationObjectiveScalarWhereInput[]
  }

  export type FoundationContactUpdateOneWithoutFoundationNestedInput = {
    create?: XOR<FoundationContactCreateWithoutFoundationInput, FoundationContactUncheckedCreateWithoutFoundationInput>
    connectOrCreate?: FoundationContactCreateOrConnectWithoutFoundationInput
    upsert?: FoundationContactUpsertWithoutFoundationInput
    disconnect?: FoundationContactWhereInput | boolean
    delete?: FoundationContactWhereInput | boolean
    connect?: FoundationContactWhereUniqueInput
    update?: XOR<XOR<FoundationContactUpdateToOneWithWhereWithoutFoundationInput, FoundationContactUpdateWithoutFoundationInput>, FoundationContactUncheckedUpdateWithoutFoundationInput>
  }

  export type FoundationMediaUpdateManyWithoutFoundationNestedInput = {
    create?: XOR<FoundationMediaCreateWithoutFoundationInput, FoundationMediaUncheckedCreateWithoutFoundationInput> | FoundationMediaCreateWithoutFoundationInput[] | FoundationMediaUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationMediaCreateOrConnectWithoutFoundationInput | FoundationMediaCreateOrConnectWithoutFoundationInput[]
    upsert?: FoundationMediaUpsertWithWhereUniqueWithoutFoundationInput | FoundationMediaUpsertWithWhereUniqueWithoutFoundationInput[]
    createMany?: FoundationMediaCreateManyFoundationInputEnvelope
    set?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
    disconnect?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
    delete?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
    connect?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
    update?: FoundationMediaUpdateWithWhereUniqueWithoutFoundationInput | FoundationMediaUpdateWithWhereUniqueWithoutFoundationInput[]
    updateMany?: FoundationMediaUpdateManyWithWhereWithoutFoundationInput | FoundationMediaUpdateManyWithWhereWithoutFoundationInput[]
    deleteMany?: FoundationMediaScalarWhereInput | FoundationMediaScalarWhereInput[]
  }

  export type FoundationStatUncheckedUpdateManyWithoutFoundationNestedInput = {
    create?: XOR<FoundationStatCreateWithoutFoundationInput, FoundationStatUncheckedCreateWithoutFoundationInput> | FoundationStatCreateWithoutFoundationInput[] | FoundationStatUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationStatCreateOrConnectWithoutFoundationInput | FoundationStatCreateOrConnectWithoutFoundationInput[]
    upsert?: FoundationStatUpsertWithWhereUniqueWithoutFoundationInput | FoundationStatUpsertWithWhereUniqueWithoutFoundationInput[]
    createMany?: FoundationStatCreateManyFoundationInputEnvelope
    set?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
    disconnect?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
    delete?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
    connect?: FoundationStatWhereUniqueInput | FoundationStatWhereUniqueInput[]
    update?: FoundationStatUpdateWithWhereUniqueWithoutFoundationInput | FoundationStatUpdateWithWhereUniqueWithoutFoundationInput[]
    updateMany?: FoundationStatUpdateManyWithWhereWithoutFoundationInput | FoundationStatUpdateManyWithWhereWithoutFoundationInput[]
    deleteMany?: FoundationStatScalarWhereInput | FoundationStatScalarWhereInput[]
  }

  export type FoundationActivityUncheckedUpdateManyWithoutFoundationNestedInput = {
    create?: XOR<FoundationActivityCreateWithoutFoundationInput, FoundationActivityUncheckedCreateWithoutFoundationInput> | FoundationActivityCreateWithoutFoundationInput[] | FoundationActivityUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationActivityCreateOrConnectWithoutFoundationInput | FoundationActivityCreateOrConnectWithoutFoundationInput[]
    upsert?: FoundationActivityUpsertWithWhereUniqueWithoutFoundationInput | FoundationActivityUpsertWithWhereUniqueWithoutFoundationInput[]
    createMany?: FoundationActivityCreateManyFoundationInputEnvelope
    set?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
    disconnect?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
    delete?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
    connect?: FoundationActivityWhereUniqueInput | FoundationActivityWhereUniqueInput[]
    update?: FoundationActivityUpdateWithWhereUniqueWithoutFoundationInput | FoundationActivityUpdateWithWhereUniqueWithoutFoundationInput[]
    updateMany?: FoundationActivityUpdateManyWithWhereWithoutFoundationInput | FoundationActivityUpdateManyWithWhereWithoutFoundationInput[]
    deleteMany?: FoundationActivityScalarWhereInput | FoundationActivityScalarWhereInput[]
  }

  export type FoundationObjectiveUncheckedUpdateManyWithoutFoundationNestedInput = {
    create?: XOR<FoundationObjectiveCreateWithoutFoundationInput, FoundationObjectiveUncheckedCreateWithoutFoundationInput> | FoundationObjectiveCreateWithoutFoundationInput[] | FoundationObjectiveUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationObjectiveCreateOrConnectWithoutFoundationInput | FoundationObjectiveCreateOrConnectWithoutFoundationInput[]
    upsert?: FoundationObjectiveUpsertWithWhereUniqueWithoutFoundationInput | FoundationObjectiveUpsertWithWhereUniqueWithoutFoundationInput[]
    createMany?: FoundationObjectiveCreateManyFoundationInputEnvelope
    set?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
    disconnect?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
    delete?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
    connect?: FoundationObjectiveWhereUniqueInput | FoundationObjectiveWhereUniqueInput[]
    update?: FoundationObjectiveUpdateWithWhereUniqueWithoutFoundationInput | FoundationObjectiveUpdateWithWhereUniqueWithoutFoundationInput[]
    updateMany?: FoundationObjectiveUpdateManyWithWhereWithoutFoundationInput | FoundationObjectiveUpdateManyWithWhereWithoutFoundationInput[]
    deleteMany?: FoundationObjectiveScalarWhereInput | FoundationObjectiveScalarWhereInput[]
  }

  export type FoundationContactUncheckedUpdateOneWithoutFoundationNestedInput = {
    create?: XOR<FoundationContactCreateWithoutFoundationInput, FoundationContactUncheckedCreateWithoutFoundationInput>
    connectOrCreate?: FoundationContactCreateOrConnectWithoutFoundationInput
    upsert?: FoundationContactUpsertWithoutFoundationInput
    disconnect?: FoundationContactWhereInput | boolean
    delete?: FoundationContactWhereInput | boolean
    connect?: FoundationContactWhereUniqueInput
    update?: XOR<XOR<FoundationContactUpdateToOneWithWhereWithoutFoundationInput, FoundationContactUpdateWithoutFoundationInput>, FoundationContactUncheckedUpdateWithoutFoundationInput>
  }

  export type FoundationMediaUncheckedUpdateManyWithoutFoundationNestedInput = {
    create?: XOR<FoundationMediaCreateWithoutFoundationInput, FoundationMediaUncheckedCreateWithoutFoundationInput> | FoundationMediaCreateWithoutFoundationInput[] | FoundationMediaUncheckedCreateWithoutFoundationInput[]
    connectOrCreate?: FoundationMediaCreateOrConnectWithoutFoundationInput | FoundationMediaCreateOrConnectWithoutFoundationInput[]
    upsert?: FoundationMediaUpsertWithWhereUniqueWithoutFoundationInput | FoundationMediaUpsertWithWhereUniqueWithoutFoundationInput[]
    createMany?: FoundationMediaCreateManyFoundationInputEnvelope
    set?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
    disconnect?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
    delete?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
    connect?: FoundationMediaWhereUniqueInput | FoundationMediaWhereUniqueInput[]
    update?: FoundationMediaUpdateWithWhereUniqueWithoutFoundationInput | FoundationMediaUpdateWithWhereUniqueWithoutFoundationInput[]
    updateMany?: FoundationMediaUpdateManyWithWhereWithoutFoundationInput | FoundationMediaUpdateManyWithWhereWithoutFoundationInput[]
    deleteMany?: FoundationMediaScalarWhereInput | FoundationMediaScalarWhereInput[]
  }

  export type FoundationCreateNestedOneWithoutStatsInput = {
    create?: XOR<FoundationCreateWithoutStatsInput, FoundationUncheckedCreateWithoutStatsInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutStatsInput
    connect?: FoundationWhereUniqueInput
  }

  export type FoundationUpdateOneRequiredWithoutStatsNestedInput = {
    create?: XOR<FoundationCreateWithoutStatsInput, FoundationUncheckedCreateWithoutStatsInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutStatsInput
    upsert?: FoundationUpsertWithoutStatsInput
    connect?: FoundationWhereUniqueInput
    update?: XOR<XOR<FoundationUpdateToOneWithWhereWithoutStatsInput, FoundationUpdateWithoutStatsInput>, FoundationUncheckedUpdateWithoutStatsInput>
  }

  export type FoundationCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<FoundationCreateWithoutActivitiesInput, FoundationUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutActivitiesInput
    connect?: FoundationWhereUniqueInput
  }

  export type FoundationUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<FoundationCreateWithoutActivitiesInput, FoundationUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutActivitiesInput
    upsert?: FoundationUpsertWithoutActivitiesInput
    connect?: FoundationWhereUniqueInput
    update?: XOR<XOR<FoundationUpdateToOneWithWhereWithoutActivitiesInput, FoundationUpdateWithoutActivitiesInput>, FoundationUncheckedUpdateWithoutActivitiesInput>
  }

  export type FoundationCreateNestedOneWithoutObjectivesInput = {
    create?: XOR<FoundationCreateWithoutObjectivesInput, FoundationUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutObjectivesInput
    connect?: FoundationWhereUniqueInput
  }

  export type EnumObjectiveTypeFieldUpdateOperationsInput = {
    set?: $Enums.ObjectiveType
  }

  export type FoundationUpdateOneRequiredWithoutObjectivesNestedInput = {
    create?: XOR<FoundationCreateWithoutObjectivesInput, FoundationUncheckedCreateWithoutObjectivesInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutObjectivesInput
    upsert?: FoundationUpsertWithoutObjectivesInput
    connect?: FoundationWhereUniqueInput
    update?: XOR<XOR<FoundationUpdateToOneWithWhereWithoutObjectivesInput, FoundationUpdateWithoutObjectivesInput>, FoundationUncheckedUpdateWithoutObjectivesInput>
  }

  export type FoundationCreateNestedOneWithoutContactInput = {
    create?: XOR<FoundationCreateWithoutContactInput, FoundationUncheckedCreateWithoutContactInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutContactInput
    connect?: FoundationWhereUniqueInput
  }

  export type FoundationUpdateOneRequiredWithoutContactNestedInput = {
    create?: XOR<FoundationCreateWithoutContactInput, FoundationUncheckedCreateWithoutContactInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutContactInput
    upsert?: FoundationUpsertWithoutContactInput
    connect?: FoundationWhereUniqueInput
    update?: XOR<XOR<FoundationUpdateToOneWithWhereWithoutContactInput, FoundationUpdateWithoutContactInput>, FoundationUncheckedUpdateWithoutContactInput>
  }

  export type FoundationCreateNestedOneWithoutMediaInput = {
    create?: XOR<FoundationCreateWithoutMediaInput, FoundationUncheckedCreateWithoutMediaInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutMediaInput
    connect?: FoundationWhereUniqueInput
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type FoundationUpdateOneWithoutMediaNestedInput = {
    create?: XOR<FoundationCreateWithoutMediaInput, FoundationUncheckedCreateWithoutMediaInput>
    connectOrCreate?: FoundationCreateOrConnectWithoutMediaInput
    upsert?: FoundationUpsertWithoutMediaInput
    disconnect?: FoundationWhereInput | boolean
    delete?: FoundationWhereInput | boolean
    connect?: FoundationWhereUniqueInput
    update?: XOR<XOR<FoundationUpdateToOneWithWhereWithoutMediaInput, FoundationUpdateWithoutMediaInput>, FoundationUncheckedUpdateWithoutMediaInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumObjectiveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectiveType | EnumObjectiveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectiveType[]
    notIn?: $Enums.ObjectiveType[]
    not?: NestedEnumObjectiveTypeFilter<$PrismaModel> | $Enums.ObjectiveType
  }

  export type NestedEnumObjectiveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectiveType | EnumObjectiveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectiveType[]
    notIn?: $Enums.ObjectiveType[]
    not?: NestedEnumObjectiveTypeWithAggregatesFilter<$PrismaModel> | $Enums.ObjectiveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumObjectiveTypeFilter<$PrismaModel>
    _max?: NestedEnumObjectiveTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[]
    notIn?: $Enums.MediaType[]
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[]
    notIn?: $Enums.MediaType[]
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type DonationCreateWithoutUserInput = {
    amount: number
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationUncheckedCreateWithoutUserInput = {
    id?: number
    amount: number
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationCreateOrConnectWithoutUserInput = {
    where: DonationWhereUniqueInput
    create: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput>
  }

  export type DonationCreateManyUserInputEnvelope = {
    data: DonationCreateManyUserInput | DonationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PdfOrderCreateWithoutUserInput = {
    quantity?: number
    totalPrice: number
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pdfBook: PdfBookCreateNestedOneWithoutOrdersInput
  }

  export type PdfOrderUncheckedCreateWithoutUserInput = {
    id?: number
    pdfBookId: number
    quantity?: number
    totalPrice: number
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PdfOrderCreateOrConnectWithoutUserInput = {
    where: PdfOrderWhereUniqueInput
    create: XOR<PdfOrderCreateWithoutUserInput, PdfOrderUncheckedCreateWithoutUserInput>
  }

  export type PdfOrderCreateManyUserInputEnvelope = {
    data: PdfOrderCreateManyUserInput | PdfOrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    providerType: string
    providerId: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: number
    providerType: string
    providerId: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: number
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    referenceId: string
    provider: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: number
    referenceId: string
    provider: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DonationUpsertWithWhereUniqueWithoutUserInput = {
    where: DonationWhereUniqueInput
    update: XOR<DonationUpdateWithoutUserInput, DonationUncheckedUpdateWithoutUserInput>
    create: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput>
  }

  export type DonationUpdateWithWhereUniqueWithoutUserInput = {
    where: DonationWhereUniqueInput
    data: XOR<DonationUpdateWithoutUserInput, DonationUncheckedUpdateWithoutUserInput>
  }

  export type DonationUpdateManyWithWhereWithoutUserInput = {
    where: DonationScalarWhereInput
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyWithoutUserInput>
  }

  export type DonationScalarWhereInput = {
    AND?: DonationScalarWhereInput | DonationScalarWhereInput[]
    OR?: DonationScalarWhereInput[]
    NOT?: DonationScalarWhereInput | DonationScalarWhereInput[]
    id?: IntFilter<"Donation"> | number
    userId?: IntFilter<"Donation"> | number
    amount?: FloatFilter<"Donation"> | number
    status?: StringFilter<"Donation"> | string
    paymentMethod?: StringNullableFilter<"Donation"> | string | null
    transactionId?: StringNullableFilter<"Donation"> | string | null
    createdAt?: DateTimeFilter<"Donation"> | Date | string
    updatedAt?: DateTimeFilter<"Donation"> | Date | string
  }

  export type PdfOrderUpsertWithWhereUniqueWithoutUserInput = {
    where: PdfOrderWhereUniqueInput
    update: XOR<PdfOrderUpdateWithoutUserInput, PdfOrderUncheckedUpdateWithoutUserInput>
    create: XOR<PdfOrderCreateWithoutUserInput, PdfOrderUncheckedCreateWithoutUserInput>
  }

  export type PdfOrderUpdateWithWhereUniqueWithoutUserInput = {
    where: PdfOrderWhereUniqueInput
    data: XOR<PdfOrderUpdateWithoutUserInput, PdfOrderUncheckedUpdateWithoutUserInput>
  }

  export type PdfOrderUpdateManyWithWhereWithoutUserInput = {
    where: PdfOrderScalarWhereInput
    data: XOR<PdfOrderUpdateManyMutationInput, PdfOrderUncheckedUpdateManyWithoutUserInput>
  }

  export type PdfOrderScalarWhereInput = {
    AND?: PdfOrderScalarWhereInput | PdfOrderScalarWhereInput[]
    OR?: PdfOrderScalarWhereInput[]
    NOT?: PdfOrderScalarWhereInput | PdfOrderScalarWhereInput[]
    id?: IntFilter<"PdfOrder"> | number
    userId?: IntFilter<"PdfOrder"> | number
    pdfBookId?: IntFilter<"PdfOrder"> | number
    quantity?: IntFilter<"PdfOrder"> | number
    totalPrice?: FloatFilter<"PdfOrder"> | number
    status?: StringFilter<"PdfOrder"> | string
    paymentMethod?: StringNullableFilter<"PdfOrder"> | string | null
    transactionId?: StringNullableFilter<"PdfOrder"> | string | null
    createdAt?: DateTimeFilter<"PdfOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PdfOrder"> | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: IntFilter<"Account"> | number
    userId?: IntFilter<"Account"> | number
    providerType?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: IntFilter<"Session"> | number
    sessionToken?: StringFilter<"Session"> | string
    userId?: IntFilter<"Session"> | number
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    userId?: IntFilter<"Payment"> | number
    referenceId?: StringFilter<"Payment"> | string
    provider?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    donations?: DonationCreateNestedManyWithoutUserInput
    pdfOrders?: PdfOrderCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    pdfOrders?: PdfOrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    donations?: DonationUpdateManyWithoutUserNestedInput
    pdfOrders?: PdfOrderUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    pdfOrders?: PdfOrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    donations?: DonationCreateNestedManyWithoutUserInput
    pdfOrders?: PdfOrderCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    pdfOrders?: PdfOrderUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    donations?: DonationUpdateManyWithoutUserNestedInput
    pdfOrders?: PdfOrderUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    pdfOrders?: PdfOrderUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDonationsInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pdfOrders?: PdfOrderCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDonationsInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pdfOrders?: PdfOrderUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDonationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
  }

  export type UserUpsertWithoutDonationsInput = {
    update: XOR<UserUpdateWithoutDonationsInput, UserUncheckedUpdateWithoutDonationsInput>
    create: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDonationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDonationsInput, UserUncheckedUpdateWithoutDonationsInput>
  }

  export type UserUpdateWithoutDonationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pdfOrders?: PdfOrderUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDonationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pdfOrders?: PdfOrderUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PdfOrderCreateWithoutPdfBookInput = {
    quantity?: number
    totalPrice: number
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPdfOrdersInput
  }

  export type PdfOrderUncheckedCreateWithoutPdfBookInput = {
    id?: number
    userId: number
    quantity?: number
    totalPrice: number
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PdfOrderCreateOrConnectWithoutPdfBookInput = {
    where: PdfOrderWhereUniqueInput
    create: XOR<PdfOrderCreateWithoutPdfBookInput, PdfOrderUncheckedCreateWithoutPdfBookInput>
  }

  export type PdfOrderCreateManyPdfBookInputEnvelope = {
    data: PdfOrderCreateManyPdfBookInput | PdfOrderCreateManyPdfBookInput[]
    skipDuplicates?: boolean
  }

  export type PdfOrderUpsertWithWhereUniqueWithoutPdfBookInput = {
    where: PdfOrderWhereUniqueInput
    update: XOR<PdfOrderUpdateWithoutPdfBookInput, PdfOrderUncheckedUpdateWithoutPdfBookInput>
    create: XOR<PdfOrderCreateWithoutPdfBookInput, PdfOrderUncheckedCreateWithoutPdfBookInput>
  }

  export type PdfOrderUpdateWithWhereUniqueWithoutPdfBookInput = {
    where: PdfOrderWhereUniqueInput
    data: XOR<PdfOrderUpdateWithoutPdfBookInput, PdfOrderUncheckedUpdateWithoutPdfBookInput>
  }

  export type PdfOrderUpdateManyWithWhereWithoutPdfBookInput = {
    where: PdfOrderScalarWhereInput
    data: XOR<PdfOrderUpdateManyMutationInput, PdfOrderUncheckedUpdateManyWithoutPdfBookInput>
  }

  export type UserCreateWithoutPdfOrdersInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    donations?: DonationCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPdfOrdersInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPdfOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPdfOrdersInput, UserUncheckedCreateWithoutPdfOrdersInput>
  }

  export type PdfBookCreateWithoutOrdersInput = {
    title: string
    description?: string | null
    price: number
    pdfUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PdfBookUncheckedCreateWithoutOrdersInput = {
    id?: number
    title: string
    description?: string | null
    price: number
    pdfUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PdfBookCreateOrConnectWithoutOrdersInput = {
    where: PdfBookWhereUniqueInput
    create: XOR<PdfBookCreateWithoutOrdersInput, PdfBookUncheckedCreateWithoutOrdersInput>
  }

  export type UserUpsertWithoutPdfOrdersInput = {
    update: XOR<UserUpdateWithoutPdfOrdersInput, UserUncheckedUpdateWithoutPdfOrdersInput>
    create: XOR<UserCreateWithoutPdfOrdersInput, UserUncheckedCreateWithoutPdfOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPdfOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPdfOrdersInput, UserUncheckedUpdateWithoutPdfOrdersInput>
  }

  export type UserUpdateWithoutPdfOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    donations?: DonationUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPdfOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PdfBookUpsertWithoutOrdersInput = {
    update: XOR<PdfBookUpdateWithoutOrdersInput, PdfBookUncheckedUpdateWithoutOrdersInput>
    create: XOR<PdfBookCreateWithoutOrdersInput, PdfBookUncheckedCreateWithoutOrdersInput>
    where?: PdfBookWhereInput
  }

  export type PdfBookUpdateToOneWithWhereWithoutOrdersInput = {
    where?: PdfBookWhereInput
    data: XOR<PdfBookUpdateWithoutOrdersInput, PdfBookUncheckedUpdateWithoutOrdersInput>
  }

  export type PdfBookUpdateWithoutOrdersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfBookUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    pdfUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutPaymentsInput = {
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    donations?: DonationCreateNestedManyWithoutUserInput
    pdfOrders?: PdfOrderCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: number
    name: string
    email: string
    password?: string | null
    image?: string | null
    address?: string | null
    phone?: string | null
    otpCode?: string | null
    otpExpires?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    isVerified?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    pdfOrders?: PdfOrderUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    donations?: DonationUpdateManyWithoutUserNestedInput
    pdfOrders?: PdfOrderUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    otpCode?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    pdfOrders?: PdfOrderUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FoundationStatCreateWithoutFoundationInput = {
    label: string
    value: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationStatUncheckedCreateWithoutFoundationInput = {
    id?: number
    label: string
    value: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationStatCreateOrConnectWithoutFoundationInput = {
    where: FoundationStatWhereUniqueInput
    create: XOR<FoundationStatCreateWithoutFoundationInput, FoundationStatUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationStatCreateManyFoundationInputEnvelope = {
    data: FoundationStatCreateManyFoundationInput | FoundationStatCreateManyFoundationInput[]
    skipDuplicates?: boolean
  }

  export type FoundationActivityCreateWithoutFoundationInput = {
    activityText: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationActivityUncheckedCreateWithoutFoundationInput = {
    id?: number
    activityText: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationActivityCreateOrConnectWithoutFoundationInput = {
    where: FoundationActivityWhereUniqueInput
    create: XOR<FoundationActivityCreateWithoutFoundationInput, FoundationActivityUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationActivityCreateManyFoundationInputEnvelope = {
    data: FoundationActivityCreateManyFoundationInput | FoundationActivityCreateManyFoundationInput[]
    skipDuplicates?: boolean
  }

  export type FoundationObjectiveCreateWithoutFoundationInput = {
    title: string
    description?: string | null
    objectiveType?: $Enums.ObjectiveType
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationObjectiveUncheckedCreateWithoutFoundationInput = {
    id?: number
    title: string
    description?: string | null
    objectiveType?: $Enums.ObjectiveType
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationObjectiveCreateOrConnectWithoutFoundationInput = {
    where: FoundationObjectiveWhereUniqueInput
    create: XOR<FoundationObjectiveCreateWithoutFoundationInput, FoundationObjectiveUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationObjectiveCreateManyFoundationInputEnvelope = {
    data: FoundationObjectiveCreateManyFoundationInput | FoundationObjectiveCreateManyFoundationInput[]
    skipDuplicates?: boolean
  }

  export type FoundationContactCreateWithoutFoundationInput = {
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationContactUncheckedCreateWithoutFoundationInput = {
    id?: number
    email?: string | null
    phone?: string | null
    address?: string | null
    website?: string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationContactCreateOrConnectWithoutFoundationInput = {
    where: FoundationContactWhereUniqueInput
    create: XOR<FoundationContactCreateWithoutFoundationInput, FoundationContactUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationMediaCreateWithoutFoundationInput = {
    fileName: string
    filePath: string
    fileType?: string | null
    fileSize?: number | null
    mediaType?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
  }

  export type FoundationMediaUncheckedCreateWithoutFoundationInput = {
    id?: number
    fileName: string
    filePath: string
    fileType?: string | null
    fileSize?: number | null
    mediaType?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
  }

  export type FoundationMediaCreateOrConnectWithoutFoundationInput = {
    where: FoundationMediaWhereUniqueInput
    create: XOR<FoundationMediaCreateWithoutFoundationInput, FoundationMediaUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationMediaCreateManyFoundationInputEnvelope = {
    data: FoundationMediaCreateManyFoundationInput | FoundationMediaCreateManyFoundationInput[]
    skipDuplicates?: boolean
  }

  export type FoundationStatUpsertWithWhereUniqueWithoutFoundationInput = {
    where: FoundationStatWhereUniqueInput
    update: XOR<FoundationStatUpdateWithoutFoundationInput, FoundationStatUncheckedUpdateWithoutFoundationInput>
    create: XOR<FoundationStatCreateWithoutFoundationInput, FoundationStatUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationStatUpdateWithWhereUniqueWithoutFoundationInput = {
    where: FoundationStatWhereUniqueInput
    data: XOR<FoundationStatUpdateWithoutFoundationInput, FoundationStatUncheckedUpdateWithoutFoundationInput>
  }

  export type FoundationStatUpdateManyWithWhereWithoutFoundationInput = {
    where: FoundationStatScalarWhereInput
    data: XOR<FoundationStatUpdateManyMutationInput, FoundationStatUncheckedUpdateManyWithoutFoundationInput>
  }

  export type FoundationStatScalarWhereInput = {
    AND?: FoundationStatScalarWhereInput | FoundationStatScalarWhereInput[]
    OR?: FoundationStatScalarWhereInput[]
    NOT?: FoundationStatScalarWhereInput | FoundationStatScalarWhereInput[]
    id?: IntFilter<"FoundationStat"> | number
    foundationId?: IntFilter<"FoundationStat"> | number
    label?: StringFilter<"FoundationStat"> | string
    value?: StringFilter<"FoundationStat"> | string
    displayOrder?: IntFilter<"FoundationStat"> | number
    createdAt?: DateTimeFilter<"FoundationStat"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationStat"> | Date | string
  }

  export type FoundationActivityUpsertWithWhereUniqueWithoutFoundationInput = {
    where: FoundationActivityWhereUniqueInput
    update: XOR<FoundationActivityUpdateWithoutFoundationInput, FoundationActivityUncheckedUpdateWithoutFoundationInput>
    create: XOR<FoundationActivityCreateWithoutFoundationInput, FoundationActivityUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationActivityUpdateWithWhereUniqueWithoutFoundationInput = {
    where: FoundationActivityWhereUniqueInput
    data: XOR<FoundationActivityUpdateWithoutFoundationInput, FoundationActivityUncheckedUpdateWithoutFoundationInput>
  }

  export type FoundationActivityUpdateManyWithWhereWithoutFoundationInput = {
    where: FoundationActivityScalarWhereInput
    data: XOR<FoundationActivityUpdateManyMutationInput, FoundationActivityUncheckedUpdateManyWithoutFoundationInput>
  }

  export type FoundationActivityScalarWhereInput = {
    AND?: FoundationActivityScalarWhereInput | FoundationActivityScalarWhereInput[]
    OR?: FoundationActivityScalarWhereInput[]
    NOT?: FoundationActivityScalarWhereInput | FoundationActivityScalarWhereInput[]
    id?: IntFilter<"FoundationActivity"> | number
    foundationId?: IntFilter<"FoundationActivity"> | number
    activityText?: StringFilter<"FoundationActivity"> | string
    displayOrder?: IntFilter<"FoundationActivity"> | number
    createdAt?: DateTimeFilter<"FoundationActivity"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationActivity"> | Date | string
  }

  export type FoundationObjectiveUpsertWithWhereUniqueWithoutFoundationInput = {
    where: FoundationObjectiveWhereUniqueInput
    update: XOR<FoundationObjectiveUpdateWithoutFoundationInput, FoundationObjectiveUncheckedUpdateWithoutFoundationInput>
    create: XOR<FoundationObjectiveCreateWithoutFoundationInput, FoundationObjectiveUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationObjectiveUpdateWithWhereUniqueWithoutFoundationInput = {
    where: FoundationObjectiveWhereUniqueInput
    data: XOR<FoundationObjectiveUpdateWithoutFoundationInput, FoundationObjectiveUncheckedUpdateWithoutFoundationInput>
  }

  export type FoundationObjectiveUpdateManyWithWhereWithoutFoundationInput = {
    where: FoundationObjectiveScalarWhereInput
    data: XOR<FoundationObjectiveUpdateManyMutationInput, FoundationObjectiveUncheckedUpdateManyWithoutFoundationInput>
  }

  export type FoundationObjectiveScalarWhereInput = {
    AND?: FoundationObjectiveScalarWhereInput | FoundationObjectiveScalarWhereInput[]
    OR?: FoundationObjectiveScalarWhereInput[]
    NOT?: FoundationObjectiveScalarWhereInput | FoundationObjectiveScalarWhereInput[]
    id?: IntFilter<"FoundationObjective"> | number
    foundationId?: IntFilter<"FoundationObjective"> | number
    title?: StringFilter<"FoundationObjective"> | string
    description?: StringNullableFilter<"FoundationObjective"> | string | null
    objectiveType?: EnumObjectiveTypeFilter<"FoundationObjective"> | $Enums.ObjectiveType
    displayOrder?: IntFilter<"FoundationObjective"> | number
    createdAt?: DateTimeFilter<"FoundationObjective"> | Date | string
    updatedAt?: DateTimeFilter<"FoundationObjective"> | Date | string
  }

  export type FoundationContactUpsertWithoutFoundationInput = {
    update: XOR<FoundationContactUpdateWithoutFoundationInput, FoundationContactUncheckedUpdateWithoutFoundationInput>
    create: XOR<FoundationContactCreateWithoutFoundationInput, FoundationContactUncheckedCreateWithoutFoundationInput>
    where?: FoundationContactWhereInput
  }

  export type FoundationContactUpdateToOneWithWhereWithoutFoundationInput = {
    where?: FoundationContactWhereInput
    data: XOR<FoundationContactUpdateWithoutFoundationInput, FoundationContactUncheckedUpdateWithoutFoundationInput>
  }

  export type FoundationContactUpdateWithoutFoundationInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationContactUncheckedUpdateWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMediaLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationMediaUpsertWithWhereUniqueWithoutFoundationInput = {
    where: FoundationMediaWhereUniqueInput
    update: XOR<FoundationMediaUpdateWithoutFoundationInput, FoundationMediaUncheckedUpdateWithoutFoundationInput>
    create: XOR<FoundationMediaCreateWithoutFoundationInput, FoundationMediaUncheckedCreateWithoutFoundationInput>
  }

  export type FoundationMediaUpdateWithWhereUniqueWithoutFoundationInput = {
    where: FoundationMediaWhereUniqueInput
    data: XOR<FoundationMediaUpdateWithoutFoundationInput, FoundationMediaUncheckedUpdateWithoutFoundationInput>
  }

  export type FoundationMediaUpdateManyWithWhereWithoutFoundationInput = {
    where: FoundationMediaScalarWhereInput
    data: XOR<FoundationMediaUpdateManyMutationInput, FoundationMediaUncheckedUpdateManyWithoutFoundationInput>
  }

  export type FoundationMediaScalarWhereInput = {
    AND?: FoundationMediaScalarWhereInput | FoundationMediaScalarWhereInput[]
    OR?: FoundationMediaScalarWhereInput[]
    NOT?: FoundationMediaScalarWhereInput | FoundationMediaScalarWhereInput[]
    id?: IntFilter<"FoundationMedia"> | number
    foundationId?: IntNullableFilter<"FoundationMedia"> | number | null
    fileName?: StringFilter<"FoundationMedia"> | string
    filePath?: StringFilter<"FoundationMedia"> | string
    fileType?: StringNullableFilter<"FoundationMedia"> | string | null
    fileSize?: IntNullableFilter<"FoundationMedia"> | number | null
    mediaType?: EnumMediaTypeFilter<"FoundationMedia"> | $Enums.MediaType
    altText?: StringNullableFilter<"FoundationMedia"> | string | null
    createdAt?: DateTimeFilter<"FoundationMedia"> | Date | string
  }

  export type FoundationCreateWithoutStatsInput = {
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    activities?: FoundationActivityCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactCreateNestedOneWithoutFoundationInput
    media?: FoundationMediaCreateNestedManyWithoutFoundationInput
  }

  export type FoundationUncheckedCreateWithoutStatsInput = {
    id?: number
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    activities?: FoundationActivityUncheckedCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveUncheckedCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactUncheckedCreateNestedOneWithoutFoundationInput
    media?: FoundationMediaUncheckedCreateNestedManyWithoutFoundationInput
  }

  export type FoundationCreateOrConnectWithoutStatsInput = {
    where: FoundationWhereUniqueInput
    create: XOR<FoundationCreateWithoutStatsInput, FoundationUncheckedCreateWithoutStatsInput>
  }

  export type FoundationUpsertWithoutStatsInput = {
    update: XOR<FoundationUpdateWithoutStatsInput, FoundationUncheckedUpdateWithoutStatsInput>
    create: XOR<FoundationCreateWithoutStatsInput, FoundationUncheckedCreateWithoutStatsInput>
    where?: FoundationWhereInput
  }

  export type FoundationUpdateToOneWithWhereWithoutStatsInput = {
    where?: FoundationWhereInput
    data: XOR<FoundationUpdateWithoutStatsInput, FoundationUncheckedUpdateWithoutStatsInput>
  }

  export type FoundationUpdateWithoutStatsInput = {
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    activities?: FoundationActivityUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUpdateOneWithoutFoundationNestedInput
    media?: FoundationMediaUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationUncheckedUpdateWithoutStatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    activities?: FoundationActivityUncheckedUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUncheckedUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUncheckedUpdateOneWithoutFoundationNestedInput
    media?: FoundationMediaUncheckedUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationCreateWithoutActivitiesInput = {
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactCreateNestedOneWithoutFoundationInput
    media?: FoundationMediaCreateNestedManyWithoutFoundationInput
  }

  export type FoundationUncheckedCreateWithoutActivitiesInput = {
    id?: number
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatUncheckedCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveUncheckedCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactUncheckedCreateNestedOneWithoutFoundationInput
    media?: FoundationMediaUncheckedCreateNestedManyWithoutFoundationInput
  }

  export type FoundationCreateOrConnectWithoutActivitiesInput = {
    where: FoundationWhereUniqueInput
    create: XOR<FoundationCreateWithoutActivitiesInput, FoundationUncheckedCreateWithoutActivitiesInput>
  }

  export type FoundationUpsertWithoutActivitiesInput = {
    update: XOR<FoundationUpdateWithoutActivitiesInput, FoundationUncheckedUpdateWithoutActivitiesInput>
    create: XOR<FoundationCreateWithoutActivitiesInput, FoundationUncheckedCreateWithoutActivitiesInput>
    where?: FoundationWhereInput
  }

  export type FoundationUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: FoundationWhereInput
    data: XOR<FoundationUpdateWithoutActivitiesInput, FoundationUncheckedUpdateWithoutActivitiesInput>
  }

  export type FoundationUpdateWithoutActivitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUpdateOneWithoutFoundationNestedInput
    media?: FoundationMediaUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationUncheckedUpdateWithoutActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUncheckedUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUncheckedUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUncheckedUpdateOneWithoutFoundationNestedInput
    media?: FoundationMediaUncheckedUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationCreateWithoutObjectivesInput = {
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatCreateNestedManyWithoutFoundationInput
    activities?: FoundationActivityCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactCreateNestedOneWithoutFoundationInput
    media?: FoundationMediaCreateNestedManyWithoutFoundationInput
  }

  export type FoundationUncheckedCreateWithoutObjectivesInput = {
    id?: number
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatUncheckedCreateNestedManyWithoutFoundationInput
    activities?: FoundationActivityUncheckedCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactUncheckedCreateNestedOneWithoutFoundationInput
    media?: FoundationMediaUncheckedCreateNestedManyWithoutFoundationInput
  }

  export type FoundationCreateOrConnectWithoutObjectivesInput = {
    where: FoundationWhereUniqueInput
    create: XOR<FoundationCreateWithoutObjectivesInput, FoundationUncheckedCreateWithoutObjectivesInput>
  }

  export type FoundationUpsertWithoutObjectivesInput = {
    update: XOR<FoundationUpdateWithoutObjectivesInput, FoundationUncheckedUpdateWithoutObjectivesInput>
    create: XOR<FoundationCreateWithoutObjectivesInput, FoundationUncheckedCreateWithoutObjectivesInput>
    where?: FoundationWhereInput
  }

  export type FoundationUpdateToOneWithWhereWithoutObjectivesInput = {
    where?: FoundationWhereInput
    data: XOR<FoundationUpdateWithoutObjectivesInput, FoundationUncheckedUpdateWithoutObjectivesInput>
  }

  export type FoundationUpdateWithoutObjectivesInput = {
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUpdateManyWithoutFoundationNestedInput
    activities?: FoundationActivityUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUpdateOneWithoutFoundationNestedInput
    media?: FoundationMediaUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationUncheckedUpdateWithoutObjectivesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUncheckedUpdateManyWithoutFoundationNestedInput
    activities?: FoundationActivityUncheckedUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUncheckedUpdateOneWithoutFoundationNestedInput
    media?: FoundationMediaUncheckedUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationCreateWithoutContactInput = {
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatCreateNestedManyWithoutFoundationInput
    activities?: FoundationActivityCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveCreateNestedManyWithoutFoundationInput
    media?: FoundationMediaCreateNestedManyWithoutFoundationInput
  }

  export type FoundationUncheckedCreateWithoutContactInput = {
    id?: number
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatUncheckedCreateNestedManyWithoutFoundationInput
    activities?: FoundationActivityUncheckedCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveUncheckedCreateNestedManyWithoutFoundationInput
    media?: FoundationMediaUncheckedCreateNestedManyWithoutFoundationInput
  }

  export type FoundationCreateOrConnectWithoutContactInput = {
    where: FoundationWhereUniqueInput
    create: XOR<FoundationCreateWithoutContactInput, FoundationUncheckedCreateWithoutContactInput>
  }

  export type FoundationUpsertWithoutContactInput = {
    update: XOR<FoundationUpdateWithoutContactInput, FoundationUncheckedUpdateWithoutContactInput>
    create: XOR<FoundationCreateWithoutContactInput, FoundationUncheckedCreateWithoutContactInput>
    where?: FoundationWhereInput
  }

  export type FoundationUpdateToOneWithWhereWithoutContactInput = {
    where?: FoundationWhereInput
    data: XOR<FoundationUpdateWithoutContactInput, FoundationUncheckedUpdateWithoutContactInput>
  }

  export type FoundationUpdateWithoutContactInput = {
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUpdateManyWithoutFoundationNestedInput
    activities?: FoundationActivityUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUpdateManyWithoutFoundationNestedInput
    media?: FoundationMediaUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUncheckedUpdateManyWithoutFoundationNestedInput
    activities?: FoundationActivityUncheckedUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUncheckedUpdateManyWithoutFoundationNestedInput
    media?: FoundationMediaUncheckedUpdateManyWithoutFoundationNestedInput
  }

  export type FoundationCreateWithoutMediaInput = {
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatCreateNestedManyWithoutFoundationInput
    activities?: FoundationActivityCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactCreateNestedOneWithoutFoundationInput
  }

  export type FoundationUncheckedCreateWithoutMediaInput = {
    id?: number
    name: string
    tagline?: string | null
    logoUrl?: string | null
    description?: string | null
    establishedYear?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    stats?: FoundationStatUncheckedCreateNestedManyWithoutFoundationInput
    activities?: FoundationActivityUncheckedCreateNestedManyWithoutFoundationInput
    objectives?: FoundationObjectiveUncheckedCreateNestedManyWithoutFoundationInput
    contact?: FoundationContactUncheckedCreateNestedOneWithoutFoundationInput
  }

  export type FoundationCreateOrConnectWithoutMediaInput = {
    where: FoundationWhereUniqueInput
    create: XOR<FoundationCreateWithoutMediaInput, FoundationUncheckedCreateWithoutMediaInput>
  }

  export type FoundationUpsertWithoutMediaInput = {
    update: XOR<FoundationUpdateWithoutMediaInput, FoundationUncheckedUpdateWithoutMediaInput>
    create: XOR<FoundationCreateWithoutMediaInput, FoundationUncheckedCreateWithoutMediaInput>
    where?: FoundationWhereInput
  }

  export type FoundationUpdateToOneWithWhereWithoutMediaInput = {
    where?: FoundationWhereInput
    data: XOR<FoundationUpdateWithoutMediaInput, FoundationUncheckedUpdateWithoutMediaInput>
  }

  export type FoundationUpdateWithoutMediaInput = {
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUpdateManyWithoutFoundationNestedInput
    activities?: FoundationActivityUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUpdateOneWithoutFoundationNestedInput
  }

  export type FoundationUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: FoundationStatUncheckedUpdateManyWithoutFoundationNestedInput
    activities?: FoundationActivityUncheckedUpdateManyWithoutFoundationNestedInput
    objectives?: FoundationObjectiveUncheckedUpdateManyWithoutFoundationNestedInput
    contact?: FoundationContactUncheckedUpdateOneWithoutFoundationNestedInput
  }

  export type DonationCreateManyUserInput = {
    id?: number
    amount: number
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PdfOrderCreateManyUserInput = {
    id?: number
    pdfBookId: number
    quantity?: number
    totalPrice: number
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: number
    providerType: string
    providerId: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: number
    sessionToken: string
    expires: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: number
    referenceId: string
    provider: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationUpdateWithoutUserInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfOrderUpdateWithoutUserInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pdfBook?: PdfBookUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type PdfOrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    pdfBookId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfOrderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    pdfBookId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    providerType?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    referenceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfOrderCreateManyPdfBookInput = {
    id?: number
    userId: number
    quantity?: number
    totalPrice: number
    status?: string
    paymentMethod?: string | null
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PdfOrderUpdateWithoutPdfBookInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPdfOrdersNestedInput
  }

  export type PdfOrderUncheckedUpdateWithoutPdfBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfOrderUncheckedUpdateManyWithoutPdfBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationStatCreateManyFoundationInput = {
    id?: number
    label: string
    value: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationActivityCreateManyFoundationInput = {
    id?: number
    activityText: string
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationObjectiveCreateManyFoundationInput = {
    id?: number
    title: string
    description?: string | null
    objectiveType?: $Enums.ObjectiveType
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoundationMediaCreateManyFoundationInput = {
    id?: number
    fileName: string
    filePath: string
    fileType?: string | null
    fileSize?: number | null
    mediaType?: $Enums.MediaType
    altText?: string | null
    createdAt?: Date | string
  }

  export type FoundationStatUpdateWithoutFoundationInput = {
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationStatUncheckedUpdateWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationStatUncheckedUpdateManyWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationActivityUpdateWithoutFoundationInput = {
    activityText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationActivityUncheckedUpdateWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    activityText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationActivityUncheckedUpdateManyWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    activityText?: StringFieldUpdateOperationsInput | string
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationObjectiveUpdateWithoutFoundationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveType?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationObjectiveUncheckedUpdateWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveType?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationObjectiveUncheckedUpdateManyWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveType?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationMediaUpdateWithoutFoundationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationMediaUncheckedUpdateWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoundationMediaUncheckedUpdateManyWithoutFoundationInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}